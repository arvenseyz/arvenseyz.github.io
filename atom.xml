<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arvense</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/blog/"/>
  <updated>2019-09-17T08:47:26.253Z</updated>
  <id>http://yoursite.com/blog/</id>
  
  <author>
    <name>Arvense</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shellscript数组与函数</title>
    <link href="http://yoursite.com/blog/2019/09/17/9-17%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2019/09/17/9-17技术笔记-1/</id>
    <published>2019-09-17T03:32:57.000Z</published>
    <updated>2019-09-17T08:47:26.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小，并且从0开始。</p><p>Shell 数组用括号来表示，元素用”空格”符号分割开。即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure><p>也可以用下标来定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure><p>和其他类似，@和*表示所有，#表示长度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">marray[0]=A</span><br><span class="line">marray[1]=B</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"content: <span class="variable">$&#123;marray[@]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"lenth: <span class="variable">$&#123;#marray[*]&#125;</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ ./array.sh</span><br><span class="line">content: A B</span><br><span class="line">lenth: 2</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数严格定义，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而function关键字可以省略，返回值也可以省略，将以最后一条命令运行结果，作为返回值。而函数不用写形式参数，传入参数后，就像bash，直接用@123取参数，就像bash，#*等的意义</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>参数个数</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">        sum=0</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> $*</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                sum=`expr <span class="variable">$sum</span> + <span class="variable">$num</span>`</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"sum=<span class="variable">$sum</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func 1 2 3 4 5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ ./func.sh</span><br><span class="line">sum=15</span><br></pre></td></tr></table></figure><p>如上，expr是运算符，表数字运算.</p><p>直接用加法就是字符串拼接，结果会是”sum=0+1+2+3+4+5”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小，并且从0开始。&lt;/p&gt;
&lt;p&gt;Shell 数组用括号来表
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>shellscript选择与循环</title>
    <link href="http://yoursite.com/blog/2019/09/10/9-10%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/09/10/9-10技术笔记/</id>
    <published>2019-09-10T07:30:22.000Z</published>
    <updated>2019-09-10T10:42:26.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件命令"><a href="#条件命令" class="headerlink" title="条件命令"></a>条件命令</h2><p>在bash脚本编程中，我们经常做一些条件判断， 我们主要用到了三种，test，单中括号，双中括号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ $? –eq 0 ]</span><br><span class="line"></span><br><span class="line">[[ $myvar == “mysql” ]]</span><br><span class="line"></span><br><span class="line">test 1 -eq 0</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>test是bash内建命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ <span class="built_in">test</span> 1 -ne 0 &amp;&amp;<span class="built_in">echo</span> ok</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>ne是不等于的意思，即1不等于0，就输出ok.</p><p>man test可以看见所有参数用法，摘录一点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">( EXPRESSION )</span><br><span class="line">       EXPRESSION is true</span><br><span class="line"></span><br><span class="line">! EXPRESSION</span><br><span class="line">       EXPRESSION is false</span><br><span class="line"></span><br><span class="line">EXPRESSION1 -a EXPRESSION2</span><br><span class="line">       both EXPRESSION1 and EXPRESSION2 are true</span><br><span class="line"></span><br><span class="line">EXPRESSION1 -o EXPRESSION2</span><br><span class="line">       either EXPRESSION1 or EXPRESSION2 is true</span><br><span class="line">       </span><br><span class="line">       STRING1 = STRING2</span><br><span class="line">       the strings are equal</span><br><span class="line"></span><br><span class="line">STRING1 != STRING2</span><br><span class="line">       the strings are not equal</span><br><span class="line"></span><br><span class="line">INTEGER1 -eq INTEGER2</span><br><span class="line">       INTEGER1 is equal to INTEGER2</span><br><span class="line"></span><br><span class="line">INTEGER1 -ge INTEGER2</span><br><span class="line">       INTEGER1 is greater than or equal to INTEGER2</span><br><span class="line"></span><br><span class="line">INTEGER1 -gt INTEGER2</span><br><span class="line">       INTEGER1 is greater than INTEGER2</span><br></pre></td></tr></table></figure><h3 id="单中括号"><a href="#单中括号" class="headerlink" title="单中括号"></a>单中括号</h3><p>实际上[ 这个是个内建命令，可以执行which [查看。</p><p>这样就可以理解奇怪的规定。即然是命令，那么命令与后面的参数就得用空格隔开，使用[时后面需要有一个空格的原因。所以[1=2]这样的写法将会报错。单中括号与test命令是等价的。</p><p>这里有一个陷阱，既然 <code>都是以参数的形式传递给</code>test` 命令的， 那么如果参数解析的结果是空或者带空格，那么就会因为缺少参数或者参数数量不丢而崩掉。</p><p>所以最好参数用双引号包起来。</p><h3 id="双中括号"><a href="#双中括号" class="headerlink" title="双中括号"></a>双中括号</h3><p>双中括号不是命令，而是shell关键字。因为不是命令，因此不受制与 Shell 的 <strong>参数展开</strong>，比如 不需要用引号包裹所有变量，也支持类似 <code>&amp;&amp;</code>，<code>||</code> 这样的逻辑操作而不需要用类似 <code>-a</code>，<code>-o</code> 这样的参数。</p><h3 id="双小括号"><a href="#双小括号" class="headerlink" title="双小括号"></a>双小括号</h3><p>算术展开的语法是  <code>$((expression))</code>，这是从其他编程语言来的人最顺手的算术操作方式。与  <code>test</code>  命令相比，</p><ul><li>C 风格的算术操作语法</li><li>Shell 会把  <code>expression</code>  内容的每一项都当做就像被引号包裹了一样。</li><li>会依次进行<strong>参数展开</strong>、<strong>命令替换</strong>，和  <strong>引号移除</strong>。</li></ul><p>因此可以不需要像  <code>test</code>  命令那样用引号包裹所有变量，也不需要注意空格，也可以写 C 风格的操作。</p><p>然后，对于C，1是ture，0是false。bah相反。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>因为test和[]是命令，所以逻辑运算符是以参数的形式体现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ [ 1 -ne 0 ]&amp;&amp;<span class="built_in">echo</span> ok</span><br><span class="line">ok</span><br><span class="line">yangzhuo@n224-019-077:~/file$ [ 1 -ne 0 || 1 -gt 0 ]&amp;&amp;<span class="built_in">echo</span> ok</span><br><span class="line">-bash: [: missing `]<span class="string">'</span></span><br><span class="line"><span class="string">-bash: 1: command not found</span></span><br></pre></td></tr></table></figure><p>只能这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ [ 1 -ne 0 ] || [ 1 -gt 0 ]&amp;&amp;<span class="built_in">echo</span> ok</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>当然[[]]就不受限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ [[ 1 -ne 0  ||  1 -gt 0 ]]&amp;&amp;echo ok</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>甚至</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ [[ 1 != 0  ||  1 &gt; 0 ]]&amp;&amp;<span class="built_in">echo</span> ok</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">"num?"</span> num</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;num&#125;</span> -gt 10 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"big"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$&#123;num&#125;</span> - eq 10]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"equal"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"small"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$&#123;yn&#125;</span>"</span> != <span class="string">"yes"</span> -a <span class="string">"<span class="variable">$&#123;yn&#125;</span>"</span> != <span class="string">"YES"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Please input yes/YES to stop this program: "</span> yn </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"OK! you input the correct answer."</span></span><br></pre></td></tr></table></figure><p>while do done结构，也有until do done，直到。。。其实没啥用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s=0 <span class="comment"># 这是加总的数值变量</span></span><br><span class="line">i=0 <span class="comment"># 这是累计的数值，亦即是 1, 2, 3....</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$&#123;i&#125;</span>"</span> != <span class="string">"100"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">i=$（（<span class="variable">$i</span>+1）） <span class="comment"># 每次 i 都会增加 1</span></span><br><span class="line">s=$（（<span class="variable">$s</span>+<span class="variable">$i</span>）） <span class="comment"># 每次都会加总一次！</span></span><br><span class="line"><span class="keyword">done</span> <span class="built_in">echo</span> <span class="string">"The result of '1+2+3+...+100' is ==&gt; <span class="variable">$s</span>"</span></span><br></pre></td></tr></table></figure><p>这是while的一般用法。</p><p>for循环支持for in 和三段式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">"Please input a number, I will count for 1+2+...+your_input: "</span> nu</span><br><span class="line">s=0</span><br><span class="line"><span class="keyword">for</span> （（ i=1; i&lt;=<span class="variable">$&#123;nu&#125;</span>; i=i+1 ））</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">s=$（（<span class="variable">$&#123;s&#125;</span>+<span class="variable">$&#123;i&#125;</span>））</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result of '1+2+3+...+<span class="variable">$&#123;nu&#125;</span>' is ==&gt; <span class="variable">$&#123;s&#125;</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"There are <span class="variable">$&#123;animal&#125;</span>s.... "</span> <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>即in后面接空格隔开的，或者seq联系数字.</p><p>也可以直接使用 bash 的内置机制来处理！可以使用 {1..100} 来取代 $（seq 1 100） 。 大括号内的前面/后面用两个字符，中间以两个小数点来代表连续出现的意思。例如要持续输出 a, b, c…g 的话， 就可以使用“ echo {a..g} ”这样的表 示方式！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sitenu <span class="keyword">in</span> $（seq 1 100） <span class="comment"># seq 为 sequence（连续） 的缩写之意</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment"># 下面的程序在取得 ping 的回传值是正确的还是失败的！</span></span><br><span class="line">ping -c 1 -w 1 <span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> &amp;&gt; /dev/null &amp;&amp; result=0 || result=1</span><br><span class="line"><span class="comment"># 开始显示结果是正确的启动 （UP） 还是错误的没有连通 （DOWN）</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;result&#125;</span>"</span> == 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Server <span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> is UP."</span> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Server <span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> is DOWN."</span> </span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;条件命令&quot;&gt;&lt;a href=&quot;#条件命令&quot; class=&quot;headerlink&quot; title=&quot;条件命令&quot;&gt;&lt;/a&gt;条件命令&lt;/h2&gt;&lt;p&gt;在bash脚本编程中，我们经常做一些条件判断， 我们主要用到了三种，test，单中括号，双中括号。&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>shellScript入门</title>
    <link href="http://yoursite.com/blog/2019/09/08/9-8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/09/08/9-8技术笔记/</id>
    <published>2019-09-08T06:56:26.000Z</published>
    <updated>2019-09-08T12:46:06.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用者输入变量内容"><a href="#使用者输入变量内容" class="headerlink" title="使用者输入变量内容"></a>使用者输入变量内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"enter cnt"</span> cnt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"will go <span class="variable">$cnt</span> num"</span></span><br><span class="line"></span><br><span class="line">yangzhuo@n224-019-077:~/file$ vim test.sh</span><br><span class="line">yangzhuo@n224-019-077:~/file$ sh test.sh</span><br><span class="line">enter cnt7</span><br><span class="line">will go 7 num</span><br></pre></td></tr></table></figure><p>read让用户输入参数</p><h2 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yesterday=`date -d last-day +%Y-%m-%d`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$yesterday</span></span><br><span class="line"></span><br><span class="line">curday=`date +%Y-%m-%d`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$curday</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"现在时间：`date '+%Y%m%d %T'`"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"现在时间：`date '+%Y%m%d %H%M%S'`"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> `date <span class="string">'+%Y%m%d-%H%M%S'</span>`</span><br><span class="line"></span><br><span class="line">send=`date --date=<span class="string">'3 hours ago'</span> <span class="string">'+%Y-%m-%d %H:%M:%S'</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$send</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-09-07</span><br><span class="line">2019-09-08</span><br><span class="line">现在时间：20190908 15:14:56</span><br><span class="line">现在时间：20190908 151456</span><br><span class="line">20190908-151456</span><br><span class="line">2019-09-08 12:14:56</span><br></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p><strong><em>= 变量为null时, 同时改变变量值</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxidc /]# unset name</span><br><span class="line">[root@linuxidc /]# echo $&#123;name=linuxmi&#125;</span><br><span class="line">linuxmi</span><br><span class="line">[root@linuxidc /]# echo $name</span><br><span class="line">linuxmi</span><br><span class="line">[root@linuxidc /]# name=&quot;&quot;</span><br><span class="line">[root@linuxidc /]# echo $&#123;name=linuxmi&#125;</span><br><span class="line"></span><br><span class="line">[root@linuxidc /]#</span><br></pre></td></tr></table></figure><p><strong><em>-  变量为null时, 取默认值</em></strong></p><p><strong><em>:- 变量为null或空字符时, 取默认值</em></strong></p><p><strong><em>:= 变量为null时, 同时改变变量值</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用者输入变量内容&quot;&gt;&lt;a href=&quot;#使用者输入变量内容&quot; class=&quot;headerlink&quot; title=&quot;使用者输入变量内容&quot;&gt;&lt;/a&gt;使用者输入变量内容&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>awk</title>
    <link href="http://yoursite.com/blog/2019/09/04/9-4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/09/04/9-4技术笔记/</id>
    <published>2019-09-04T06:08:02.000Z</published>
    <updated>2019-09-05T13:20:07.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="print"><a href="#print" class="headerlink" title="print"></a>print</h1><p>print其实和C差不多.</p><p>比如先来个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat print.txt</span><br><span class="line">Name Chinese English Math Average</span><br><span class="line">DmTsai 80 60 92 77.33</span><br><span class="line">VBird 75 55 80 70.00</span><br><span class="line">Ken 60 90 70 73.33</span><br></pre></td></tr></table></figure><p>%s,\t之类的，可以格式化输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ <span class="built_in">printf</span> <span class="string">'%s\t %s\t %s\t %s\t %s\t \n'</span> $(cat print.txt)</span><br><span class="line">Name     Chinese     English     Math     Average</span><br><span class="line">DmTsai     80     60     92     77.33</span><br><span class="line">VBird     75     55     80     70.00</span><br><span class="line">Ken     60     90     70     73.33</span><br></pre></td></tr></table></figure><p>还可以指定位数和内容，方法和C类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ <span class="built_in">printf</span> <span class="string">'%10s %5i %5i %5i %8.2f \n'</span> $(cat print.txt | grep -v Name)</span><br><span class="line">    DmTsai    80    60    92    77.33</span><br><span class="line">     VBird    75    55    80    70.00</span><br><span class="line">       Ken    60    90    70    73.33</span><br></pre></td></tr></table></figure><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><h2 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a>小栗子</h2><p>awk 主要是处理“每一行的字段内的数据”，而默认的“字段的分隔符号为 “空白键” 或 “[tab]键” ”。</p><p>比如刚才的数据，一共一行，每行有5列，这种表格状的数据，适合awk处理。</p><p>awk使用方式是<code></code>中放指令。</p><p>awk ‘条件类型1{动作1} 条件类型2{动作2} …’ filename</p><p>比如刚才的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat print.txt |awk <span class="string">'&#123;print $1 "\t" $3&#125;'</span></span><br><span class="line">Name    English</span><br><span class="line">DmTsai    60</span><br><span class="line">VBird    55</span><br><span class="line">Ken        90</span><br></pre></td></tr></table></figure><p>上表即是 awk 最常使用的动作，通过 print 的功能将字段数据列出来。字段的分隔则以空白键或 [tab] 按键来隔开。 因为不论哪一行都要处理，因此，就不需要有 “条件类型” 的限制！我所想要的是第一栏以及第三栏，每一行的每个字段都是有变量名称的，那就是 \$1, $2… 等变量名称。所以Name是第一个变量，English是第三个变量。</p><p>而\$0代表该行所有数据。</p><p>而非指令，即字符串，需要用“”包起来</p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>awk 的处理流程是：</p><ol><li><p>读入第一行，并将第一行的数据填入 $0, $1, $2…. 等变量当中； </p></li><li><p>依据 “条件类型” 的限制，判断是否需要进行后面的 “动作”； </p></li><li><p>做完所有的动作与条件类型； </p></li><li><p>若还有后续的“行”的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。</p></li></ol><p>awk 是“以行为一次处理的单位”， 而“以字段为最小的处理单位”。，那么 awk 需要知道有多少行</p><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>NF</td><td>每行字段数（总列数）</td></tr><tr><td>NR</td><td>当前在第几行</td></tr><tr><td>FS</td><td>分割字符（默认空格）</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat print.txt |awk <span class="string">'&#123;print "line @   "NR "content"$1&#125;'</span></span><br><span class="line">line @   1contentName</span><br><span class="line">line @   2contentDmTsai</span><br><span class="line">line @   3contentVBird</span><br><span class="line">line @   4contentKen</span><br></pre></td></tr></table></figure><p>awk还可以逻辑判断，比如输出英语成绩大于85的学生</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat print.txt |awk <span class="string">'$3&gt;85&#123;print $0&#125;'</span></span><br><span class="line">Name Chinese English Math Average</span><br><span class="line">Ken 60 90 70 73.33</span><br></pre></td></tr></table></figure><p>这种写法就是’条件类型1{动作1}’，第三个变量大于85是条件，输出整行是动作。至于为什么第一行可以展示，估计是asclii之类的。</p><h2 id="变量和统计"><a href="#变量和统计" class="headerlink" title="变量和统计"></a>变量和统计</h2><p>BEGIN和END表示最前和最后做某事，比如BEGIN {FS=”:”} ，意思是把分隔符变成：，不然第二行才会开始生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat print.txt |awk <span class="string">'NR==1&#123;printf "%10s %10s %10s %10s %10s %10s\n",$1,$2,$3,$4,$5,"total"&#125;</span></span><br><span class="line"><span class="string">NR&gt;=2&#123;total = $2 + $3 + $4</span></span><br><span class="line"><span class="string">printf "%10s %10d %10d %10d %10.2f %10d\n", $1, $2, $3, $4,$5, total&#125;'</span></span><br><span class="line">      Name    Chinese    English       Math    Average      total</span><br><span class="line">    DmTsai         80         60         92      77.33        232</span><br><span class="line">     VBird         75         55         80      70.00        210</span><br><span class="line">       Ken         60         90         70      73.33        220</span><br></pre></td></tr></table></figure><p>从这个例子可以看出，有这么几点</p><ol><li><p>printf格式化输出，用法和c类似</p></li><li><p>变量直接用名字和用即可，因为非变量用双引号括起来了</p></li><li><p>只要‘’的后单引号没结束，可以回车换行接着输入指令。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;print&quot;&gt;&lt;a href=&quot;#print&quot; class=&quot;headerlink&quot; title=&quot;print&quot;&gt;&lt;/a&gt;print&lt;/h1&gt;&lt;p&gt;print其实和C差不多.&lt;/p&gt;
&lt;p&gt;比如先来个文件&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>grep与正则表达式</title>
    <link href="http://yoursite.com/blog/2019/08/30/8-30%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/08/30/8-30技术笔记/</id>
    <published>2019-08-30T07:19:09.000Z</published>
    <updated>2019-08-30T08:20:53.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加单引号、双引号和不加引号"><a href="#加单引号、双引号和不加引号" class="headerlink" title="加单引号、双引号和不加引号"></a>加单引号、双引号和不加引号</h2><p><strong>单引号：</strong></p><p>可以说是所见即所得：即将单引号内的内容原样输出，或者描述为单引号里面看到的是什么就会输出什么。单引号’’是全引用，被单引号括起的内容不管是常量还是变量者不会发生替换。</p><p><strong>双引号：</strong></p><p>把双引号内的内容输出出来；如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容来。双引号””是部分引用，被双引号括起的内容常量还是常量，变量则会发生替换，替换成变量内容。</p><p><strong>不加引号：</strong></p><p>不会将含有空格的字符串视为一个整体输出, 如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容来，如果字符串中带有空格等特殊字符，则不能完整的输出，需要改加双引号，一般连续的字符串，数字，路径等可以用。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>grep搜索的内容，可以输入正则表达式，如果不想输入正则表达式，即不想被解析，可以使用fgerp。</p><p>比如，有文件a，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat a</span><br><span class="line">s</span><br><span class="line">dsa</span><br><span class="line">fasf</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fsaf</span><br><span class="line">fasdasdw</span><br><span class="line">da</span><br></pre></td></tr></table></figure><p>可以用[]来搜索集合字符，其中^表示不</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ grep l[sd] a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">yangzhuo@n224-019-077:~/file$ grep l[^<span class="built_in">cd</span>] a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br></pre></td></tr></table></figure><p>grep l[sd] a表示在a中搜索ls或者ld。</p><p>grep l[^cd] a表示a中搜索除了lc和ld其他。</p><p>正如正则表达式，[1-9][a-z][^A-Z]这些表达也是可以的。</p><h2 id="行首与行尾字符"><a href="#行首与行尾字符" class="headerlink" title="行首与行尾字符 ^ $"></a>行首与行尾字符 ^ $</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ grep ^f a</span><br><span class="line">fasf</span><br><span class="line">fsaf</span><br><span class="line">fasdasdw</span><br><span class="line">yangzhuo@n224-019-077:~/file$ grep w$ a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fasdasdw</span><br><span class="line">yangzhuo@n224-019-077:~/file$</span><br></pre></td></tr></table></figure><p>如上，^表示句首，$表示句尾。同时可以使用正则表达式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ grep ^[^sd] a</span><br><span class="line">fasf</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fsaf</span><br><span class="line">fasdasdw</span><br><span class="line">yangzhuo@n224-019-077:~/file$</span><br></pre></td></tr></table></figure><p>表示不以s或者d开头的</p><h2 id="转义与egrep"><a href="#转义与egrep" class="headerlink" title="转义与egrep"></a>转义与egrep</h2><p>正则表达式中，.表示任意字符，*表示重复前面字符0到无穷次，{a,b}表示重复前面字符a到b次，但是在grep中，输入这种特殊符号需要转义.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ grep w\* a</span><br><span class="line">s</span><br><span class="line">dsa</span><br><span class="line">fasf</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fsaf</span><br><span class="line">fasdasdw</span><br><span class="line">da</span><br></pre></td></tr></table></figure><p>再比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ grep <span class="string">'w\+'</span> a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fasdasdw</span><br><span class="line">yangzhuo@n224-019-077:~/file$ grep <span class="string">'w\&#123;2,\&#125;'</span> a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br></pre></td></tr></table></figure><p>没输一个字符都要转义，未免太麻烦了吧，可以使用egrep。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ egrep <span class="string">'w+'</span> a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fasdasdw</span><br></pre></td></tr></table></figure><p>esay~~</p><p>还有fgrep，就是怎么输都是纯文本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;加单引号、双引号和不加引号&quot;&gt;&lt;a href=&quot;#加单引号、双引号和不加引号&quot; class=&quot;headerlink&quot; title=&quot;加单引号、双引号和不加引号&quot;&gt;&lt;/a&gt;加单引号、双引号和不加引号&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单引号：&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>重定向与文件描述符</title>
    <link href="http://yoursite.com/blog/2019/08/26/8-26%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/08/26/8-26技术笔记/</id>
    <published>2019-08-26T02:31:51.000Z</published>
    <updated>2019-08-29T10:29:08.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>标准输出是键盘，标准输出是屏幕，标准错误输出是屏幕。</p><p>但是可以重定向，改变输入和输出的位置。</p><h2 id="简单重定向"><a href="#简单重定向" class="headerlink" title="简单重定向"></a>简单重定向</h2><ul><li>cmd &gt; file</li></ul><p>把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的<a href="http://linux-wiki.cn/index.php?title=Noclobber&amp;action=edit&amp;redlink=1" title="Noclobber（尚未撰写）" target="_blank" rel="noopener">noclobber</a>选项可以防止覆盖原有文件。</p><ul><li>cmd &gt;&gt; file</li></ul><p>把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件后面。</p><ul><li>cmd &lt; file</li></ul><p>使cmd命令从file读入</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>Shell 中对文件描述符的操作由三部分组成:  <code>(Left, Operation, Right)</code>:</p><ul><li>Left 可以是 0-9 的数字, 代表第 n 号文件描述符;<ul><li>Left 还可以为  <code>&amp;</code>, 表示同时操作  <code>stdout</code>  和  <code>stderr</code></li></ul></li><li>Right 可以是文件名或 0-9 的数字, 当 Right 是数字时必须要加上  <code>&amp;</code>  符号, 表示引用第 n 号文件描述符;<ul><li>Right 还可以为  <code>&amp;-</code>, 此时表示关闭 Left 描述符, 例如  <code>2&lt;&amp;-</code>  表示关闭 stderr;</li></ul></li><li>Operation 可以为  <code>&lt;</code>  或  <code>&gt;</code>;<ul><li>为  <code>&lt;</code>  时表示以读模式复制 Right 到 Left, 此时如果没有指定 Left 的话, 则为默认值 0;</li><li>当为  <code>&gt;</code>  表示以写模式复制 Right 到 Left, 此时如果没有指定 Left 的话, 则为默认值 1;</li><li>Operation 和 Left 之间不能有空格;</li><li>当 Right 为文件名时, Operation 和 Right 可以有空格, 否则也不能有空格;</li></ul></li></ul><pre><code>可以使用exec命令创建自定义的描述符。</code></pre><p>   创建一个文件a，其内容是hello。实验如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat 0&lt;a</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ ls &amp;&gt;a</span><br><span class="line">yangzhuo@n224-019-077:~/file$ cat a</span><br><span class="line">0703老清北线下发货明细 - 填写模板.csv</span><br><span class="line">7-8赠课.csv</span><br><span class="line">a</span><br><span class="line">buyGift.csv</span><br><span class="line">giftSheet.csv</span><br><span class="line">userInfo.csv</span><br><span class="line">换新单号表格.csv</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ ls noexist &amp;&gt;a</span><br><span class="line">yangzhuo@n224-019-077:~/file$ cat a</span><br><span class="line">ls: cannot access <span class="string">'noexist'</span>: No such file or directory</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ <span class="built_in">exec</span> 3&lt; a</span><br><span class="line">yangzhuo@n224-019-077:~/file$ cat &lt;&amp;3</span><br><span class="line">ls: cannot access <span class="string">'noexist'</span>: No such file or directory</span><br></pre></td></tr></table></figure><p>如果要再次读取，我们就不能再继续使用文件描述符3了，而是需要用exec重新分配文件描述符3以便用于读取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重定向&quot;&gt;&lt;a href=&quot;#重定向&quot; class=&quot;headerlink&quot; title=&quot;重定向&quot;&gt;&lt;/a&gt;重定向&lt;/h1&gt;&lt;p&gt;标准输出是键盘，标准输出是屏幕，标准错误输出是屏幕。&lt;/p&gt;
&lt;p&gt;但是可以重定向，改变输入和输出的位置。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>shell入门</title>
    <link href="http://yoursite.com/blog/2019/08/22/8-22%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2019/08/22/8-22技术笔记-1/</id>
    <published>2019-08-22T02:26:10.000Z</published>
    <updated>2019-08-22T07:01:37.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h1><p>第一个流行的 shell 是由 Steven Bourne 发展出来的，为了纪念他所以就称为 Bourne shell ，或直接简称为 sh。。至于 Linux 使用的这一种版本就称为“ Bourne Again SHell （简称 bash） ”，这个 Shell 是 Bourne Shell 的增强版本，也是基准于 GNU 的架构下发展出来的</p><h1 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h1><p>echo不但能输出字符串，还能显示变量，或者重定向到文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">read</span> name </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span> It is a test"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span> &gt; myfile</span><br></pre></td></tr></table></figure><p>如果使用单引号，表示不转义，不取变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'$name\"'</span></span><br><span class="line"><span class="comment">#输出结果：$name\"</span></span><br></pre></td></tr></table></figure><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<strong>$n</strong>。<strong>n</strong> 代表一个数字。第0个参数是文件名，后面的第1，第2，第3个参数就是传入的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Shell 传递参数实例！"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"执行的文件名：<span class="variable">$0</span>"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第一个参数为：<span class="variable">$1</span>"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第二个参数为：<span class="variable">$2</span>"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment">#$ ./test.sh 1 2 </span></span><br><span class="line"><span class="comment">#Shell 传递参数实例！</span></span><br><span class="line"><span class="comment">#执行的文件名：./test.sh</span></span><br><span class="line"><span class="comment">#第一个参数为：1</span></span><br><span class="line"><span class="comment">#第二个参数为：2</span></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>定义变量时，直接申明并赋值即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">"xx"</span></span><br></pre></td></tr></table></figure><p>使用时，\$变量名，或者\${变量名}</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">"ww"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br></pre></td></tr></table></figure><p>已定义的变量，可以被重新定义，但可以readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。用unset可以删除变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;名字&quot;&gt;&lt;a href=&quot;#名字&quot; class=&quot;headerlink&quot; title=&quot;名字&quot;&gt;&lt;/a&gt;名字&lt;/h1&gt;&lt;p&gt;第一个流行的 shell 是由 Steven Bourne 发展出来的，为了纪念他所以就称为 Bourne shell ，或直接简称为 sh
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>压缩文件</title>
    <link href="http://yoursite.com/blog/2019/08/16/8-16%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/08/16/8-16技术笔记/</id>
    <published>2019-08-16T06:32:00.000Z</published>
    <updated>2019-08-20T06:42:45.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打包和压缩"><a href="#打包和压缩" class="headerlink" title="打包和压缩"></a>打包和压缩</h1><p>常见的压缩文件，都是.tar.gz结尾的，有双重含义，即打包并压缩。</p><p>原因在于，压缩文件，压缩的是一个文件而不是文件夹，需要先把文件夹打包成一个文件，所以压缩一般都是先打包再压缩。</p><h1 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h1><p>gzip是GNUzip的缩写，最早用于UNIX系统的文件压缩。HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip。目前主流的浏览器，Chrome,firefox,IE等都支持该协议。常见的服务器如Apache，Nginx，IIS同样支持gzip。</p><h1 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h1><p>与windows习惯不同的是，Linux默认压缩后，原文件就没了，所以如果是要执行把某文件夹A压缩成压缩文件B，需要参数和指定压缩文件名</p><p>tar可以带参数-z，意思是并且用gzip压缩，所以一个指令即可打包并压缩文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcf log.tar.gz log2012.log</span><br></pre></td></tr></table></figure><p>c参数就是产生新的包，f参数指定位置。</p><p>而解压缩，则需要参数x。其中参数-C，即指定解压的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf go1.10.4.linux-amd64.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>而参数t，指的是我就看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztf log.tar.gz</span><br></pre></td></tr></table></figure><p>实际上</p><p>-c:  建立压缩档案  </p><p>-x：解压  </p><p>-t：查看内容  </p><p>-r：向压缩归档文件末尾追加文件  </p><p>-u：更新原压缩包中的文件</p><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p><p>-z：有gzip属性的  </p><p>-j：有bz2属性的 </p><p> -v：显示所有过程  </p><p>-O：将文件解开到标准输出</p><p>参数 -f 是必须的:</p><p>-f:  使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;打包和压缩&quot;&gt;&lt;a href=&quot;#打包和压缩&quot; class=&quot;headerlink&quot; title=&quot;打包和压缩&quot;&gt;&lt;/a&gt;打包和压缩&lt;/h1&gt;&lt;p&gt;常见的压缩文件，都是.tar.gz结尾的，有双重含义，即打包并压缩。&lt;/p&gt;
&lt;p&gt;原因在于，压缩文件，压缩的是一个
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux文件目录与链接</title>
    <link href="http://yoursite.com/blog/2019/08/14/8-14%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2019/08/14/8-14技术笔记-1/</id>
    <published>2019-08-14T07:18:55.000Z</published>
    <updated>2019-08-15T02:18:05.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p><code>/ 根目录</code></p><p><code>├── bin 存放用户二进制文件</code></p><p><code>├── boot 存放内核引导配置文件</code></p><p><code>├── dev 存放设备文件</code></p><p><code>├── etc 存放系统配置文件</code></p><p><code>├── home 用户主目录</code></p><p><code>├── lib 动态共享库</code></p><p><code>├── lost+found 文件系统恢复时的恢复文件</code></p><p><code>├── media 可卸载存储介质挂载点</code></p><p><code>├── mnt 文件系统临时挂载点</code></p><p><code>├── opt 附加的应用程序包</code></p><p><code>├── proc 系统内存的映射目录，提供内核与进程信息</code></p><p><code>├── root root 用户主目录</code></p><p><code>├── sbin 存放系统二进制文件</code></p><p><code>├── srv 存放服务相关数据</code></p><p><code>├── sys sys 虚拟文件系统挂载点</code></p><p><code>├── tmp 存放临时文件</code></p><p><code>├── usr 存放用户应用程序</code></p><p><code>└── var 存放邮件、系统日志等变化文件</code></p><p>Linux 与其他类 UNIX 系统一样并不区分文件与目录：目录是记录了其他文件名的文件。使用命令 mkdir 创建目录时，若期望创建的目录的名称与现有的文件名（或目录名）重复，则会创建失败。Linux 将设备当做文件进行处理。</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</p><p>为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。</p><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名。硬链接可由命令 link 或 ln 创建。</p><p>可以说，硬链接就是个文件名。</p><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>软链接则是真正的文件，但文件的内容即inode，是另一个文件的的路径名。</p><p>使用 find 命令，其不仅可查找某文件的软链接，还可以用于查找相同 inode 的所有硬链接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件目录&quot;&gt;&lt;a href=&quot;#文件目录&quot; class=&quot;headerlink&quot; title=&quot;文件目录&quot;&gt;&lt;/a&gt;文件目录&lt;/h1&gt;&lt;p&gt;&lt;code&gt;/ 根目录&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;├── bin 存放用户二进制文件&lt;/code&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux文件权限和管理</title>
    <link href="http://yoursite.com/blog/2019/08/12/8-12%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/08/12/8-12技术笔记/</id>
    <published>2019-08-12T07:36:01.000Z</published>
    <updated>2019-08-13T03:19:53.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p>linux文件系统，权限和用户有关，linux是多用户系统，在用户之上还有一层分组的概念，很容易理解。所以任何一个理解，都有三种不同不同的权限，文件拥有者的权限，群组的权限，其他人的权限。</p><p>进入一个文件目录，输入ls -al，其中一行返回如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--.  1    root     root     176  Dec 29  2013 .bash_profile</span><br></pre></td></tr></table></figure><p>返回值一共有7个，分别是权限，链接数，拥有者，群组，文件大小，修改日期，文件名。</p><p>其中权限一共十个字符，可以分为4组，即1-3-3-3.</p><p>第一组，一个字符，表示文件类型</p><ul><li>当为[ d ]则是目录；</li><li>当为[ - ]则是文件；</li><li>若是[ l ]则表示为链接文件（link file）；</li><li>若是[ b ]则表示为设备文件里面的可供储存的周边设备（可随机存取设备）；</li><li>若是[ c ]则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备）。</li></ul><p>第二组，三个字符，表示拥有者权限，分别表示可读，可写，可执行。如果有就有相应字符，没有就是减号。</p><p>比如rwx表示可读可写可执行，r-x表示可读不可写可执行。</p><p>其中目录的x权限，是指进入该目录的权限。通常要开放的目录， 至少会具备 rx 这两个权限</p><p>第三组，三个字符，表示群组权限。</p><p>第四组，三个字符，表示其他人权限。</p><p>链接数，有多少文件名链接到此节点（i-node）</p><h2 id="改变文件权限"><a href="#改变文件权限" class="headerlink" title="改变文件权限"></a>改变文件权限</h2><ul><li>chgrp ：改变文件所属群组</li><li>chown ：改变文件拥有者</li><li>chmod ：改变文件的权限,</li></ul><p>chgrp和chown类似，其中有个参数-R，指递归得进行改变，用于目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp users initial-setup-ks.cfg</span><br></pre></td></tr></table></figure><p>把initial-setup-ks.cfg的群组改变成了users。</p><p>chmod，可以用数字和符号两种写法，数字就是二进制加，参数-R，指递归得进行改变，用于目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 740 .bashrc</span><br></pre></td></tr></table></figure><p>表示把.bashrc的用户权限变成4+2+1:rwx;群组权限4:r–;其他权限0:—。</p><p>也可以直接写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,g=rx,o=r filename</span><br></pre></td></tr></table></figure><p>或者写一起；也可以用加减号表示增减</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod  u=rwx,go=rx  .bashrc</span><br><span class="line">chmod  a-x  .bashrc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件权限&quot;&gt;&lt;a href=&quot;#文件权限&quot; class=&quot;headerlink&quot; title=&quot;文件权限&quot;&gt;&lt;/a&gt;文件权限&lt;/h1&gt;&lt;p&gt;linux文件系统，权限和用户有关，linux是多用户系统，在用户之上还有一层分组的概念，很容易理解。所以任何一个理解，都有
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>channel泄漏和关闭</title>
    <link href="http://yoursite.com/blog/2019/07/29/7-29%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/07/29/7-29技术笔记/</id>
    <published>2019-07-29T09:11:53.000Z</published>
    <updated>2019-08-05T03:57:42.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="channel内存泄漏"><a href="#channel内存泄漏" class="headerlink" title="channel内存泄漏"></a>channel内存泄漏</h1><p>造成channel泄漏的原因很简单，协程持有channel，一直阻塞不释放。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineB</span><span class="params">(b <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">b&lt;<span class="number">-1</span></span><br><span class="line">b&lt;<span class="number">-2</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> goroutineB(ch)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="keyword">range</span> ch&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for range 会阻塞，读两次后，没数据了，就阻塞了。然后该channel不会被释放，死锁。或者select操作也是。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineA</span><span class="params">(a &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i:=&lt;-a: fmt.Printf(<span class="string">"%d\n"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i:=&lt;-a: fmt.Printf(<span class="string">"%d\n"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"out"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineB</span><span class="params">(b <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">b&lt;<span class="number">-1</span></span><br><span class="line"><span class="comment">//close(b)</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> goroutineA(ch)</span><br><span class="line"><span class="keyword">go</span> goroutineB(ch)</span><br><span class="line">time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图，B只产生了一个数据，A试图select读两次，造成A阻塞，同时chan也得不到释放。</p><h1 id="channel关闭"><a href="#channel关闭" class="headerlink" title="channel关闭"></a>channel关闭</h1><p>解决上面情况很简单，即去掉注释，B产生完数据后关闭通道。</p><p>然而有个问题，go在发送侧无法得知通道是否已经关闭，接受侧也只能尝试读一个，才能知道是否关闭。关闭一个已关闭的通道，向一个已关闭的通道发送数据，都会导致panic。</p><p>即channel没有提供isClosed()方法，不然直接写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !ch.isClosed()&#123;</span><br><span class="line">    ch&lt;-data</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ch.isClosed()&#123;</span><br><span class="line">    ch.<span class="built_in">close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没法实现，只能从设计侧解决。</p><h2 id="接受侧不关闭通道"><a href="#接受侧不关闭通道" class="headerlink" title="接受侧不关闭通道"></a>接受侧不关闭通道</h2><p>很简单，适用于1v1场景，发送侧觉得自己发完了，记得要关闭通道即可，接受侧不做处理。</p><h2 id="如果有多个发送侧，不关闭通道"><a href="#如果有多个发送侧，不关闭通道" class="headerlink" title="如果有多个发送侧，不关闭通道"></a>如果有多个发送侧，不关闭通道</h2><p>不关闭的意思是，不调用close，而让gc回收。而发出关闭指令，让发送侧别发了的，是接受端，怎么搞呢。</p><p>这里要分情况，一个1vn:再来个channel，用于接受侧，发送停止信号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineA</span><span class="params">(a &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, stop <span class="keyword">chan</span>&lt;-<span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">c:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, i)</span><br><span class="line">c++</span><br><span class="line"><span class="keyword">if</span> c &gt;= <span class="number">10</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(stop)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"out"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineB</span><span class="params">(b <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>,stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stop:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> b &lt;- <span class="number">1</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineC</span><span class="params">(b <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>,stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stop:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> b &lt;- <span class="number">1</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> goroutineA(ch,stop)</span><br><span class="line"><span class="keyword">go</span> goroutineB(ch,stop)</span><br><span class="line"><span class="keyword">go</span> goroutineC(ch,stop)</span><br><span class="line">time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，B和C是两个生产者，向chan里生产信息，A是接受者，A不想接受了，就关闭stop通道，BC接收到stop通道关闭信息，就不生产了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;channel内存泄漏&quot;&gt;&lt;a href=&quot;#channel内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;channel内存泄漏&quot;&gt;&lt;/a&gt;channel内存泄漏&lt;/h1&gt;&lt;p&gt;造成channel泄漏的原因很简单，协程持有channel，一直阻塞
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="go" scheme="http://yoursite.com/blog/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>goSlcie细节</title>
    <link href="http://yoursite.com/blog/2019/07/23/7-23%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/07/23/7-23技术笔记/</id>
    <published>2019-07-23T13:18:59.000Z</published>
    <updated>2019-07-23T13:20:09.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="nil切片与空切片"><a href="#nil切片与空切片" class="headerlink" title="nil切片与空切片"></a>nil切片与空切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> s2 = *<span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> s4 = []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>前两者是nil切片，==nil。</p><p>后两者是空切片，!=nil，数据指针都指向同一个地址 <code>0xc42003bda0</code></p><p>四者的len都是0，所以应该用len(list)==0来判断返回值。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>扩容规则并不是网传的小于1024两倍，大于1024就1.25倍这么简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d %d    \n"</span>,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d %d"</span>,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br></pre></td></tr></table></figure><p>输出并不是5 8 11 16</p><p>而是5 6 11 12</p><h4 id="基于cap的增长规则"><a href="#基于cap的增长规则" class="headerlink" title="基于cap的增长规则"></a>基于cap的增长规则</h4><p>根本问题在于，可能扩容后依然不够装，为了避免这个问题，当简单规则计算后，仍不够装时，会采用基于cap的增长规则。</p><p>1.计算新cap,以例子为例，翻倍仍不够，新cap是2+3=5；</p><p>2.内存对齐，内存对齐，简单来说需要多少个8（小于1024）/128（大于1024）字节，可以内存对齐，这里是6个。具体来说，一共五个数，每个数的指针大小为8（64位机），先算出空间40，算出实际需要索引4，然后查一个内存对齐表，索引4处值为48，48即6。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h1&gt;&lt;h2 id=&quot;nil切片与空切片&quot;&gt;&lt;a href=&quot;#nil切片与空切片&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="go" scheme="http://yoursite.com/blog/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>goMap细节</title>
    <link href="http://yoursite.com/blog/2019/07/18/7-18%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/07/18/7-18技术笔记/</id>
    <published>2019-07-18T06:08:30.000Z</published>
    <updated>2019-07-23T13:20:23.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map实现"><a href="#Map实现" class="headerlink" title="Map实现"></a>Map实现</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>我看来go的Map综合了开放寻址法和拉链法。</p><p>核心在于分桶，存储kv数据的在两个桶的数组中，一个数据桶，一个额外数据桶。后者是用于拉链法来解决哈希冲突的。</p><p>每个桶中可以存八对kv，在桶中是使用开发寻址法，如果溢出，有指向对应的溢出桶的指针，这时是拉链法。</p><p>通过具体的访问过程可知。首先是计算哈希值，这样就找到了对应的桶（此处有旧桶新桶问题），然后进入桶中查找，和桶中已存的一一比较，如果没有，则看桶链接的下一个桶（如果存在）。</p><p>特色在于快速试错，桶中除了key和value的大小为8的各一个数组外，还有个topbits的数组，即该键值对哈希值的前八位，这样每次访问不用直接比较key，只用比较哈希值的前八位，就可以快速试错。</p><p>其实就像是一级缓存，它存储的是哈希最高的 8 位，而选择桶时使用了桶掩码使用的是最低的几位，这种方式能够帮助我们快速判断当前的键值对是否存在并且减少碰撞。</p><p>有一个问题，哪些类型可以作为key的类型，不能比较的比如函数当然不能，float64语法上能实际上不能吗，原因在于NAN（not a number)，NAN != NAN hash(NAN) != hash(NAN)，以及float64的不能精确存储。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>扩容就是新建一个两倍大的桶数组，然后数据搬迁过去。问题在于，哈希表过大时，搬迁成本很高，这里解决方法是，同时持有新旧两个数组，逐步搬迁。所以扩容是一个非阻塞的相对缓慢完成的一个过程。</p><p>扩容原因有两个，装载因子过大，或者溢出桶太多。两种情况下扩容方法不一样。</p><p>后者与其说扩容，不如说重整，即是<strong>不改变大小的扩容动作</strong>。而前者会扩容到两倍。</p><p>造成溢出桶数量过多的原因有两种：其一，反复进行插入再删除。先插入一些元素，溢出桶创建了一些，但还没到达负载因子，再把这些元素删了然后又插入一些元素，溢出桶又创建了一些，反复进行后，最后造成负载桶都很空旷，溢出桶中有元素。</p><p>这种情况下，原大小扩容，将老 bucket 中的元素移动到新 bucket。这样，原来在 overflow bucket 中的 key 可以移动到 负载的bucket 中来。</p><p>第二种情况，插入的元素的哈希取模都一样，也就是说，所有的扩容桶都是同一个桶扩的容，这样哈希表退化成了链表，并且该原地扩容无法解决该问题。但造成该问题的原因不在扩容或者负载上，是哈希函数不好。</p><p>扩容完后不会搬迁，真正的搬迁工作，在插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。主要是申请到了新的 buckets 空间，然后把相关的标志位都进行了处理：例如标志 nevacuate 被置为 0， 表示当前搬迁进度为 0。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Map实现&quot;&gt;&lt;a href=&quot;#Map实现&quot; class=&quot;headerlink&quot; title=&quot;Map实现&quot;&gt;&lt;/a&gt;Map实现&lt;/h1&gt;&lt;h2 id=&quot;存储&quot;&gt;&lt;a href=&quot;#存储&quot; class=&quot;headerlink&quot; title=&quot;存储&quot;&gt;&lt;/a&gt;存
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="映射" scheme="http://yoursite.com/blog/tags/%E6%98%A0%E5%B0%84/"/>
    
      <category term="go" scheme="http://yoursite.com/blog/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go实现策略模式</title>
    <link href="http://yoursite.com/blog/2019/07/17/7-17%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/07/17/7-17技术笔记/</id>
    <published>2019-07-17T09:02:28.000Z</published>
    <updated>2019-07-17T09:21:46.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统策略模式"><a href="#传统策略模式" class="headerlink" title="传统策略模式"></a>传统策略模式</h1><p>传统(Java)策略模式依赖于继承，简单来说，各策略里面的实现封装一次，共同继承一个基类或者实现一个接口，然后一个策略工厂持有基类/接口对象，根据输入进行策略选择，得到对应的策略。业务方在使用时，应该首先用策略工厂获得需要的策略，然后调用策略的方法。</p><p>然而，第一，依然没有避免switch，只不过转移到了策略工厂里；第二，策略和策略工厂耦合。</p><h1 id="GO实现"><a href="#GO实现" class="headerlink" title="GO实现"></a>GO实现</h1><p>GO没有继承，但有方法变量，不如把策略先存到一个Map里，即   [策略名]实现方法的映射，这样直接可以从map中取出方法进行调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> Strategy <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Strategy := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span>)</span></span><br><span class="line"><span class="function"><span class="title">Strategy</span>["<span class="title">update</span>"] = <span class="title">func</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"update table set ? = ?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Strategy[<span class="string">"insert"</span>] = <span class="function"><span class="keyword">func</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"insert into table values(?,?,?,?)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Strategy[<span class="string">"delete"</span>] = <span class="function"><span class="keyword">func</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"delete from table where ?=?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Strategy[<span class="string">"select"</span>] = <span class="function"><span class="keyword">func</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"select ? from table where ?=?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Strategy[<span class="string">"insert"</span>]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;传统策略模式&quot;&gt;&lt;a href=&quot;#传统策略模式&quot; class=&quot;headerlink&quot; title=&quot;传统策略模式&quot;&gt;&lt;/a&gt;传统策略模式&lt;/h1&gt;&lt;p&gt;传统(Java)策略模式依赖于继承，简单来说，各策略里面的实现封装一次，共同继承一个基类或者实现一个接口，然
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="go" scheme="http://yoursite.com/blog/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Delve开发机调试</title>
    <link href="http://yoursite.com/blog/2019/07/15/7-15%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/07/15/7-15技术笔记/</id>
    <published>2019-07-15T09:41:53.000Z</published>
    <updated>2019-07-15T09:53:28.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/derekparker/delve/cmd/dlv</span><br></pre></td></tr></table></figure><p>一键安装，可能由于网速等原因，需要等待很久。</p><p>输入dlv version验证安装成功</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>dlv debug delve-demo.go</p><p>dlv test – -test.run <test function> </test></p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>help输入帮助，b建立断点使用 <code>&lt;package&gt;.&lt;function&gt;</code>或是 <code>&lt;filename&gt;:&lt;line number&gt;</code>的格式。bp查看断点。</p><p>c开始运行程序。</p><p>單部執行： n<br>步入： s<br>步出：stepout  </p><p>看函数参数：args</p><p>看协程：goroutine</p><p>看变量：print</p><h1 id="然而"><a href="#然而" class="headerlink" title="然而"></a>然而</h1><p>1.如果写的是服务端程序，测试的时候是模拟rpc请求，这时自己的身份是rpc的消费者，生产者处打断点没用，生产者似乎无法在启动服务时打断点。</p><p>2.goland有个go remote,可以输入开发机主机，但没有输密码的地方，当然连接不上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/blog/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>kafka技术杂记</title>
    <link href="http://yoursite.com/blog/2019/07/11/7-11%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/07/11/7-11技术笔记/</id>
    <published>2019-07-11T08:59:15.000Z</published>
    <updated>2019-07-11T10:37:41.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h1><p>kafka有同步（sync）、异步（async）以及oneway这三种发送方式，某些概念上区分也可以分为同步和异步两种，同步和异步的发送方式通过“producer.type”参数指定，而oneway由“request.require.acks”参数指定。</p><ol><li><p>同步就是每次发一条，然后刷盘，确认后再发第二条。</p></li><li><p>异步是生产者先把消息缓存起来，指定缓存的时间条数等，然后批量一起发送。</p></li><li><p>oneway就是只管发，不需要收到broker的消息确认。</p></li></ol><h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><p>zookeeper主要用来管理broker，一个是broker的信息，另一方面是broker上下线的管理。因为zookeeper写性能不好，所以现在生产和消费者一般不连接zookeeper。生产者和消费者直接连接broker。</p><h1 id="推vs拉"><a href="#推vs拉" class="headerlink" title="推vs拉"></a>推vs拉</h1><p>生产者把消息推向broker，消费者从broker拉消息。</p><h1 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h1><p>生产者消息发送失败会重试，重试失败达到指定次数返回异常。</p><p>问题在于，重试会破坏顺序性，如果要求顺序性，可以参数指定，重试时相当于阻塞。max.in.flight.requests.per.connection=1</p><h1 id="消息分区"><a href="#消息分区" class="headerlink" title="消息分区"></a>消息分区</h1><p>如果不指定key，那么消息会随机分配到各个partition，相当于负载均衡。</p><p>然而可以指定 partitioner 分区器，这样消息和partition就关联。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;发送方式&quot;&gt;&lt;a href=&quot;#发送方式&quot; class=&quot;headerlink&quot; title=&quot;发送方式&quot;&gt;&lt;/a&gt;发送方式&lt;/h1&gt;&lt;p&gt;kafka有同步（sync）、异步（async）以及oneway这三种发送方式，某些概念上区分也可以分为同步和异步两种，同步
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>GO的MPG模型</title>
    <link href="http://yoursite.com/blog/2019/07/10/7-10%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/07/10/7-10技术笔记/</id>
    <published>2019-07-10T06:36:08.000Z</published>
    <updated>2019-07-10T12:03:39.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户态VS内核态"><a href="#用户态VS内核态" class="headerlink" title="用户态VS内核态"></a>用户态VS内核态</h1><p>内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p><ul><li>内核态：CPU可以访问内存所有数据,包括外围设备（硬盘、网卡），CPU也可以将自己从一个程序切换到另一个程序；</li><li>用户态：只能受限的访问内存，且不允许访问外围设备，占用CPU的能力被剥夺，CPU资源可以被其他程序获取</li></ul><p>用户态的应用程序可以通过三种方式来访问内核态的资源：</p><p>1）系统调用</p><p>2）库函数</p><p>3）Shell脚本</p><p>系统调用类似于操作系统的原子操作，而库函数就是对其封装，其实shell也是，不过shell可以交互。</p><p>由于资源有限，大部分进程都在用户态，只有需要访问资源，才进入内核态。进入内核态手段即是中断。具体来说，中断分软硬，有三种：</p><p>1）当然就是系统调用：即软中断</p><p>2）异常事件： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</p><p>3）外围设备的中断：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</p><h1 id="用户线程VS核心线程"><a href="#用户线程VS核心线程" class="headerlink" title="用户线程VS核心线程"></a>用户线程VS核心线程</h1><p>linux其实没有线程，是通过共享资源的单线程进程模拟了线程的概念。</p><p><strong>用户线程</strong>指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应 用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线 程阻塞将使得整个进程（包括它的所有线程）阻塞。单纯的用户线程是建立在用户空间，其对内核是透明的，因此其所属进程单独参与处理器的竞争，而进程的所有线程参与竞争该进程的资源。</p><p><strong>内核线程</strong>：由操作系统内核创建和撤销。内核维护进程及线程的上下文信息以及线程切换。一个内核线程由于I/O操作而阻塞，不会影响其它线程的运行。内核线程只运行在内核态，不受用户态上下文的拖累。</p><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>核心线程和用户线程显然有以下三种关系，一对一，一对多，多对多。</p><p>一对一而言，用户线程的操作，等价于对核心线程的操作，这种模型直接调用操作系统的内核线程，所有线程的创建、终止、切换、同步等操作，都由内核来完成。C++就是这种。</p><p>一对多而言，多个用户态的线程对应着一个内核线程，也对应同一个进程，程序线程的创建、终止、切换或者同步等线程工作必须自身来完成。一旦一个线程发生阻塞，整个进程下的其他线程也会被阻塞。不能利用多核系统的优势。</p><p>多对多是比较复杂的实现，  这种模型是介于用户级线程模型和内核级线程模型之间的一种线程模型。这种模型的实现非常复杂，和内核级线程模型类似，一个进程中可以对应多个内核级线程，但是进程中的线程不和内核线程一一对应；这种线程模型会先创建多个内核级线程，然后用自身的用户级线程去对应创建的多个内核级线程，自身的用户级线程需要本身程序去调度，内核级的线程交给操作系统内核去调度。</p><p>Go语言的线程模型就是一种特殊的两级线程模型。即“MPG”模型。</p><p># </p><h1 id="MPG"><a href="#MPG" class="headerlink" title="MPG"></a>MPG</h1><p><code>M</code>指的是<code>Machine</code>，一个<code>M</code>直接关联了一个内核线程。<br><code>P</code>指的是”processor”，代表了<code>M</code>所需的上下文环境，也是处理用户级代码逻辑的处理器。<br><code>G</code>指的是<code>Goroutine</code>，其实本质上也是一种轻量级的线程。</p><p><img src="https://i.loli.net/2019/07/10/5d25d292c0df547301.png" alt="5d25d292c0df547301"></p><p><img src="https://i.loli.net/2019/07/10/5d25d322985ce39721.png" alt="5d25d322985ce39721"></p><p>调度的本质是将G尽量均匀合理地安排给M来执行，其中P的作用就是来实现合理安排逻辑。</p><ul><li>P的数量通过  <code>GOMAXPROCS()</code>  来设置，一般等于CPU的核数，对于一次代码执行设置好一般不会变。</li><li>P维护了一个本地的G队列（runqueue），包括正在执行和待执行的G，尽量保证所有的P都匹配一个M同时在执行G。</li><li>当P本地goroutine队列消费完，会从全局的goroutine队列（global runqueue）中拿goroutine到本地队列。P也会定期检查全局的goroutine队列，避免存在全局的goroutine没有被执行而”饿死”的现象。</li><li>P和M是动态形式的一对一的关系，P和G是动态形式的一对多的关系。</li></ul><p>当goroutine发生阻塞的时候，可以通过P将剩余的G切换给新的M来执行，而不会导致剩余的G无法执行，如果没有M则创建M来匹配P。</p><p>当阻塞的goroutine返回后，进程会尝试获取一个上下文（Context）来执行这个goroutine。一般是先从其他进程中”偷取”一个Context，如果”偷取”不成功，则将goroutine放入全局的goroutine中。</p><p>P可以偷任务即goroutine，当某个P的本地G执行完，且全局没有G需要执行的时候，P可以去偷别的P还没有执行完的一半的G来给M执行，提高了G的执行效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用户态VS内核态&quot;&gt;&lt;a href=&quot;#用户态VS内核态&quot; class=&quot;headerlink&quot; title=&quot;用户态VS内核态&quot;&gt;&lt;/a&gt;用户态VS内核态&lt;/h1&gt;&lt;p&gt;内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/blog/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go编译原理简析</title>
    <link href="http://yoursite.com/blog/2019/07/09/7-9%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/07/09/7-9技术笔记/</id>
    <published>2019-07-09T06:09:42.000Z</published>
    <updated>2019-09-05T13:21:18.257Z</updated>
    
    <content type="html"><![CDATA[<p>go和c一脉相承，其实编译原理和c差不多。无非分为以下步骤。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>编译器将文本转化为汇编文件的过程。</p><h2 id="编译器前端"><a href="#编译器前端" class="headerlink" title="编译器前端"></a>编译器前端</h2><p>第一步是词法分析，因为go是支持 Unicode 编码的，所以应该是按字节读取，想象下词法分析器，其实很简单，无非就是类似于正则表达式匹配，用switch语句，把文本拆成关键字/运算符/变量名的过程。</p><p>第二步是语法分析，就是把这些单词变成语法树的过程。比如slice[i]=i*(2+6)，整个语句被看作是一个赋值表达式，左子树是一个数组表达式，右子树是一个乘法表达式；数组表达式由 2 个符号表达式组成；乘号表达式则是由一个符号表达式和一个加号表达式组成；加号表达式则是由两个数字组成。符号和数字是最小的表达式，它们不能再被分解，通常作为树的叶子节点。</p><p>第三步是语义分析，编译期所能检查的是静态语义，可以认为这是在“代码”阶段，包括变量类型的匹配、转换等。例如，将一个浮点值赋给一个指针变量的时候，明显的类型不匹配，就会报编译错误。而对于运行期间才会出现的错误：不小心除了一个 0 ，语义分析是没办法检测的。</p><p><strong>语义分析阶段完成之后，会在每个节点上标注上类型。</strong></p><h2 id="编译器后端"><a href="#编译器后端" class="headerlink" title="编译器后端"></a>编译器后端</h2><p>前端生成和平台无关的中间代码，后端会针对不同的平台，生成不同的机器码。</p><p>目标机器硬件底层不同，主要体现在cpu架构不同，所以机器字长、寄存器等等都不一样，意味着在不同机器上跑的机器码是不一样的。</p><p>当然生成机器码之前，需要先优化一下。</p><p>比如把乘法运算变成位移运算，中间变量先计算出来。</p><p>而之后中间代码的生成过程其实就是从 AST 抽象语法树到 SSA 中间代码的转换过程，在这期间会对语法树中的关键字在进行一次更新，更新后的语法树会经过多轮处理转变最后的 SSA 中间代码。</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>编译的过程是针对单文件的，但运行时需要互相引用。</p><p>链接过程就是要把编译器生成的一个个目标文件链接成可执行文件。最终得到的文件是分成各种段的，比如数据段、代码段、BSS段等等，运行时会被装载到内存中。各个段具有不同的读写、执行属性，保护了程序的安全运行。</p><h1 id="Go-程序启动"><a href="#Go-程序启动" class="headerlink" title="Go 程序启动"></a>Go 程序启动</h1><ol><li><p>检查运行平台的CPU，设置好程序运行需要相关标志。</p></li><li><p>TLS（线程局部数据）的初始化。</p></li><li><p>runtime.args（保存二进制文件的绝对路径）、runtime.osinit（获取cpu核）、runtime.schedinit（初始化程序运行的环境） 三个方法做好程序运行需要的各种变量与调度器。</p></li><li><p>runtime.newproc创建新的goroutine用于绑定用户写的main方法。</p></li><li><p>runtime.mstart开始goroutine的调度。</p></li></ol><p>main 函数里执行的一些重要的操作包括：新建一个线程执行 sysmon 函数，定期垃圾回收和调度抢占；启动 gc；执行所有的 init 函数等等。</p><h1 id="Go程序退出"><a href="#Go程序退出" class="headerlink" title="Go程序退出"></a>Go程序退出</h1><p>当 main 函数执行结束之后，会执行 exit(0) 来退出进程。若执行 exit(0) 后，进程没有退出，main 函数最后的代码会一直访问非法地址：正常情况下，一旦出现非法地址访问，系统会把进程杀死，用这样的方法确保进程退出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;go和c一脉相承，其实编译原理和c差不多。无非分为以下步骤。&lt;/p&gt;
&lt;h1 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h1&gt;&lt;p&gt;编译器将文本转化为汇编文件的过程。&lt;/p&gt;
&lt;h2 id=&quot;编译
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/blog/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>kafka入门</title>
    <link href="http://yoursite.com/blog/2019/06/30/6-30%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/06/30/6-30技术笔记/</id>
    <published>2019-06-30T06:31:51.000Z</published>
    <updated>2019-06-30T08:51:44.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vs-rocketMQ"><a href="#vs-rocketMQ" class="headerlink" title="vs rocketMQ"></a>vs rocketMQ</h1><p>之前用的rocketMq，所以对消息队列有了初步了解，这里简单比较下两者。</p><ol><li><p>rocketMQ有nameserver，Kafka没有，因为Kafka的broker管理相当于托管给了zookeeper，既然用了zookeeper，其broker就有了主从切换/选举等概念。</p></li><li><p>kafka在消息存储过程中会根据topic和partition的数量创建物理文件，也就是说我们创建一个topic并指定了3个partition，那么就会有3个物理文件目录，也就说说partition的数量和对应的物理文件是一一对应的。而rocketMQ用的是commitLog的方式，</p></li></ol><h1 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h1><p>partition其实相当于topic下的分区，一个topic 可以配置几个partition，而每个partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。produce发送的消息分发到不同的partition中，一方面随机发送可以实现负载均衡，另一方面发布订阅指定的partition某种程度实现了顺序消息。</p><h1 id="消息级别"><a href="#消息级别" class="headerlink" title="消息级别"></a>消息级别</h1><p>从消息传递的角度来看，消息级别有个有这三种：</p><p>（1）至多消费一次，生产者保证自己发出消息，就不管了。生产者只需要异步发送，在发送失败或者消费失败的时候不做任何处理即可。MQ 在消费者拉走消息后，就直接将消息标记为已经消费或者删除消息。在监控系统和日志系统中，丢失部分信息是可以接受的。</p><p>（2）至少消费一次，那就需要确认机制，生产者发消息到 MQ，MQ 收到消息后返回确认信息（ACK）给生产者，生产者收到确认信息后生产过程完成，如果在一定时间内，生产者没有收到确认信息，生产者重新发送消息。消费者同理。至少消费一次就副作用是重复消费，因为确认的消息可能没收到导致重复。解决消息重复的方法是消费者这边做幂等。</p><p>（3）正好消费一次，实现很复杂，一般运用于物联网。</p><p>ji qi</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vs-rocketMQ&quot;&gt;&lt;a href=&quot;#vs-rocketMQ&quot; class=&quot;headerlink&quot; title=&quot;vs rocketMQ&quot;&gt;&lt;/a&gt;vs rocketMQ&lt;/h1&gt;&lt;p&gt;之前用的rocketMq，所以对消息队列有了初步了解，这里简单比较下
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>for range和select</title>
    <link href="http://yoursite.com/blog/2019/06/27/6-27%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/06/27/6-27技术笔记/</id>
    <published>2019-06-27T02:29:54.000Z</published>
    <updated>2019-06-30T09:06:38.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h1><p>for range 对于channel是一个阻塞式的行为，如果拿不到数据，会被阻塞，直到通道关闭或者拿到数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeCakeAndSend</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>, count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= count; i++ &#123;</span><br><span class="line">        cakeName := <span class="string">"Strawberry Cake "</span> + strconv.Itoa(i)</span><br><span class="line">        cs &lt;- cakeName <span class="comment">//send a strawberry cake</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(cs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveCakeAndPack</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> s := <span class="keyword">range</span> cs &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Packing received cake: "</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> makeCakeAndSend(cs, <span class="number">5</span>)</span><br><span class="line">    receiveCakeAndPack(cs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蛋糕制作函数制作五个蛋糕，然后发给通道，最后关闭通道。</p><p>接受程序遍历通道，for s:=range cs ,就相当于从通道接受了数据s。</p><p>主函数里申请了一个无缓存的通道。</p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>select也是阻塞的，如果没有可用通道，则阻塞。</p><p>从通道接受数据可以是两个返回值，第二个即可用来判断通道是否已经关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeCakeAndSend</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>, flavor <span class="keyword">string</span>, count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= count; i++ &#123;</span><br><span class="line">        cakeName := flavor + <span class="string">" Cake "</span> + strconv.Itoa(i)</span><br><span class="line">        cs &lt;- cakeName <span class="comment">//send a strawberry cake</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(cs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveCakeAndPack</span><span class="params">(strbry_cs <span class="keyword">chan</span> <span class="keyword">string</span>, choco_cs <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    strbry_closed, choco_closed := <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//if both channels are closed then we can stop</span></span><br><span class="line">        <span class="keyword">if</span> strbry_closed &amp;&amp; choco_closed &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"Waiting for a new cake ..."</span>)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> cakeName, strbry_ok := &lt;-strbry_cs:</span><br><span class="line">            <span class="keyword">if</span> !strbry_ok &#123;</span><br><span class="line">                strbry_closed = <span class="literal">true</span></span><br><span class="line">                fmt.Println(<span class="string">" ... Strawberry channel closed!"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"Received from Strawberry channel.  Now packing"</span>, cakeName)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> cakeName, choco_ok := &lt;-choco_cs:</span><br><span class="line">            <span class="keyword">if</span> !choco_ok &#123;</span><br><span class="line">                choco_closed = <span class="literal">true</span></span><br><span class="line">                fmt.Println(<span class="string">" ... Chocolate channel closed!"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"Received from Chocolate channel.  Now packing"</span>, cakeName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    strbry_cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    choco_cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//two cake makers</span></span><br><span class="line">    <span class="keyword">go</span> makeCakeAndSend(choco_cs, <span class="string">"Chocolate"</span>, <span class="number">3</span>)   <span class="comment">//make 3 chocolate cakes and send</span></span><br><span class="line">    <span class="keyword">go</span> makeCakeAndSend(strbry_cs, <span class="string">"Strawberry"</span>, <span class="number">4</span>) <span class="comment">//make 3 strawberry cakes and send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//one cake receiver and packer</span></span><br><span class="line">    receiveCakeAndPack(strbry_cs, choco_cs) <span class="comment">//pack all cakes received on these cake channels</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有两种蛋糕，只有两个通道都关闭，包装的for select才会结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;for-range&quot;&gt;&lt;a href=&quot;#for-range&quot; class=&quot;headerlink&quot; title=&quot;for range&quot;&gt;&lt;/a&gt;for range&lt;/h1&gt;&lt;p&gt;for range 对于channel是一个阻塞式的行为，如果拿不到数据，会被阻塞，
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/blog/tags/Go/"/>
    
  </entry>
  
</feed>
