<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arvense</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/blog/"/>
  <updated>2020-02-04T09:49:35.887Z</updated>
  <id>http://yoursite.com/blog/</id>
  
  <author>
    <name>Arvense</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程调度算法</title>
    <link href="http://yoursite.com/blog/2020/02/04/2-4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/04/2-4技术笔记/</id>
    <published>2020-02-04T09:14:24.000Z</published>
    <updated>2020-02-04T09:49:35.887Z</updated>
    
    <content type="html"><![CDATA[<p>cpu调度算法有六种，我觉得可以分为两类，四种基础思路，两种复杂的真正使用的。</p><ol><li><p>先到先得，很简单，但不现实，长作业到了，一直持有cpu，其他的傻眼了。</p></li><li><p>按优先级，这个也可以细分为抢占式和非抢占式，就是说有更高优先级的来了，立刻执行还是等当先任务结束。</p></li><li><p>短作业优先，一直有短作业插入，长作业无限等。</p></li><li><p>时间片轮转，把所有就绪的进程按先进先出的原则排成队列，进程以时间片q位单位轮流使用CPU，进程循环轮转使用CPU。缺点在于时间片长短难以确定，如果q太大,则交互性差，设置退化位FCFS调度方法；如果q太小，进程切换频繁，系统开销增加。</p></li><li><p>响应比优先，这样兼顾了等得久的先执行，时间短的先执行。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。</p></li><li><p>多级反馈队列调度算法：将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cpu调度算法有六种，我觉得可以分为两类，四种基础思路，两种复杂的真正使用的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先到先得，很简单，但不现实，长作业到了，一直持有cpu，其他的傻眼了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按优先级，这个也可以细分为抢占式和非抢占式，就是说有更高
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信的方式</title>
    <link href="http://yoursite.com/blog/2020/02/03/2-3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/03/2-3技术笔记/</id>
    <published>2020-02-03T02:12:03.000Z</published>
    <updated>2020-02-03T08:47:22.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、管道"><a href="#一、管道" class="headerlink" title="一、管道"></a>一、管道</h1><p>管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。</p><h3 id="1、特点："><a href="#1、特点：" class="headerlink" title="1、特点："></a>1、特点：</h3><ol><li><p>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</p></li><li><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</p></li><li><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p></li></ol><h3 id="2、原型："><a href="#2、原型：" class="headerlink" title="2、原型："></a>2、原型：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>; <span class="comment">// 返回值：若成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。要关闭管道只需将这两个文件描述符关闭即可。</p><h3 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h3><p>单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。</p><p>下面代码pipe则创建了管道。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> pipe_default[<span class="number">2</span>];  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//申请管道</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_default) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to create pipe!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//申请子进程</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (pid = fork()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//操作管道读写端，子进程读数据</span></span><br><span class="line">        close(pipe_default[<span class="number">1</span>]);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span>(read(pipe_default[<span class="number">0</span>], buffer, <span class="number">32</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Receive data from server, %s!\n"</span>, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_default[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//操作管道读写端，父进程写数据</span></span><br><span class="line">        close(pipe_default[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> != write(pipe_default[<span class="number">1</span>], <span class="string">"hello"</span>, <span class="built_in">strlen</span>(<span class="string">"hello"</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Send data to client, hello!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_default[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//等待子进程</span></span><br><span class="line">        waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、FIFO"><a href="#二、FIFO" class="headerlink" title="二、FIFO"></a>二、FIFO</h2><p>FIFO，也称为命名管道，它是一种文件类型。</p><h3 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li><p>FIFO可以在无关的进程之间交换数据，与无名管道不同。</p></li><li><p>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p></li></ol><h3 id="2、原型"><a href="#2、原型" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>其中的 mode 参数与open函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。</p><p>当 open 一个FIFO时，是否设置非阻塞标志（O_NONBLOCK）的区别：</p><ul><li><p>若没有指定O_NONBLOCK（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。</p></li><li><p>若指定了O_NONBLOCK，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。</p></li></ul><h3 id="3、例子-1"><a href="#3、例子-1" class="headerlink" title="3、例子"></a>3、例子</h3><p>FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。</p><p>读写双端代码如下。</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;   // exit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;    // O_WRONLY</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;     // time</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">time_t</span> tp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am %d process.\n"</span>, getpid()); <span class="comment">// 说明进程ID</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_WRONLY)) &lt; <span class="number">0</span>) <span class="comment">// 以写打开一个FIFO </span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        time(&amp;tp);  <span class="comment">// 取系统当前时间</span></span><br><span class="line">        n=<span class="built_in">sprintf</span>(buf,<span class="string">"Process %d's time is %s"</span>,getpid(),ctime(&amp;tp));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Send message: %s"</span>, buf); <span class="comment">// 打印</span></span><br><span class="line">        <span class="keyword">if</span>(write(fd, buf, n+<span class="number">1</span>) &lt; <span class="number">0</span>)  <span class="comment">// 写入到FIFO中</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"Write FIFO Failed"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">// 休眠1秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> fd;</span><br><span class="line"> <span class="keyword">int</span> len;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> <span class="keyword">if</span>(mkfifo(<span class="string">"fifo1"</span>, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno!=EEXIST) <span class="comment">// 创建FIFO管道</span></span><br><span class="line"> perror(<span class="string">"Create FIFO Failed"</span>);</span><br><span class="line"> <span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_RDONLY)) &lt; <span class="number">0</span>) <span class="comment">// 以读打开FIFO</span></span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">while</span>((len = read(fd, buf, <span class="number">1024</span>)) &gt; <span class="number">0</span>) <span class="comment">// 读取FIFO管道</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Read message: %s"</span>, buf);</span><br><span class="line"> close(fd); <span class="comment">// 关闭FIFO文件</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子可以扩展成 客户进程—服务器进程 通信的实例，write_fifo的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，read_fifo类似于服务器，它适时监控着FIFO的读端，当有数据时，读出并进行处理，但是有一个关键的问题是，每一个客户端必须预先知道服务器提供的FIFO接口。</p><h2 id="三、消息队列"><a href="#三、消息队列" class="headerlink" title="三、消息队列"></a>三、消息队列</h2><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p><h3 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li><p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p></li><li><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p></li><li><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p></li></ol><h4 id="1-1-消息队列与命名管道的比较"><a href="#1-1-消息队列与命名管道的比较" class="headerlink" title="1.1 消息队列与命名管道的比较"></a>1.1 消息队列与命名管道的比较</h4><pre><code>消息队列跟命名管道有不少的相同之处，通过与命名管道一样，消息队列进行通信的进程可以是不相关的进程，同时它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据用write，接收数据用read，则在消息队列中，发送数据用msgsnd，接收数据用msgrcv。而且它们对每个数据都有一个最大长度的限制。与命名管道相比，消息队列的优势在于，1、消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。2、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。3、接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。</code></pre><h3 id="2、原型-1"><a href="#2、原型-1" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 添加消息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 读取消息：成功返回消息数据的长度，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">long</span> type,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 控制消息队列：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>在以下两种情况下，msgget将创建一个新的消息队列：</p><ul><li>如果没有与键值key相对应的消息队列，并且flag中包含了IPC_CREAT标志位。</li><li>key参数为IPC_PRIVATE。</li></ul><p>函数msgrcv在读取消息队列时，type参数有下面几种情况：</p><ul><li>type == 0，返回队列中的第一个消息；</li><li>type &gt; 0，返回队列中消息类型为 type 的第一个消息；</li><li>type &lt; 0，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。</li></ul><p>可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。</p><h3 id="3、例子-2"><a href="#3、例子-2" class="headerlink" title="3、例子"></a>3、例子</h3><p>下面写了一个简单的使用消息队列进行IPC的例子，服务端程序一直在等待特定类型的消息，当收到该类型的消息以后，发送另一种特定类型的消息作为反馈，客户端读取该反馈并打印出来。</p><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_FILE <span class="meta-string">"/etc/passwd"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(MSG_FILE,<span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印key值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message Queue - Server key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取消息</span></span><br><span class="line">    <span class="keyword">for</span>(;;) </span><br><span class="line">    &#123;</span><br><span class="line">        msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">888</span>, <span class="number">0</span>);<span class="comment">// 返回类型为888的第一个消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line"></span><br><span class="line">        msg.mtype = <span class="number">999</span>; <span class="comment">// 客户端接收的消息类型</span></span><br><span class="line">        <span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm server %d"</span>, getpid());</span><br><span class="line">        msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_FILE <span class="meta-string">"/etc/passwd"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(MSG_FILE, <span class="string">'z'</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印key值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message Queue - Client key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加消息，类型为888</span></span><br><span class="line">    msg.mtype = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm client %d"</span>, getpid());</span><br><span class="line">    msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取类型为777的消息</span></span><br><span class="line">    msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">999</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、信号量"><a href="#四、信号量" class="headerlink" title="四、信号量"></a>四、信号量</h2><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><h3 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li><p>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p></li><li><p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p></li><li><p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p></li><li><p>支持信号量组。</p></li></ol><h3 id="2、原型-2"><a href="#2、原型-2" class="headerlink" title="2、原型"></a>2、原型</h3><p>最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做二值信号量（Binary Semaphore）。而可以取多个正整数的信号量被称为通用信号量。</p><p>Linux 下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"><span class="comment">// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf semoparray[], <span class="keyword">size_t</span> numops)</span></span>;  </span><br><span class="line"><span class="comment">// 控制信号量的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>其实PV问题，就是：p操作（wait）：申请一个单位资源，进程进入；v操作（signal）：释放一个单位资源，进程出来。用于解决常见问题 生产者-消费者、读者写者，哲学家就餐等。</p><h2 id="3、例子-3"><a href="#3、例子-3" class="headerlink" title="3、例子"></a>3、例子</h2><p>解决生产者消费者问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[<span class="number">5</span>];<span class="comment">//定义一个数组用于队列</span></span><br><span class="line"><span class="keyword">sem_t</span> p,c;<span class="comment">//两个信号量，一个是头，一个是尾</span></span><br><span class="line"> <span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">product</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//检测是否可以生产</span></span><br><span class="line">        sem_wait(&amp;p);<span class="comment">//？？？？</span></span><br><span class="line">        <span class="built_in">queue</span>[rear] = rand() % <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p:%d\n"</span>,<span class="built_in">queue</span>[rear]);<span class="comment">//可消费数增加</span></span><br><span class="line">        sem_post(&amp;c);<span class="comment">//？？？？</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        sleep(rand()%<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consume</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>,tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//检测队列中是否有数据</span></span><br><span class="line">        <span class="comment">//没有数据就等待</span></span><br><span class="line">        sem_wait(&amp;c);<span class="comment">// 等待信号的到来，信号到来大于0执行下面并减1，等于0阻塞继续等待</span></span><br><span class="line">        tmp = <span class="built_in">queue</span>[front];</span><br><span class="line">        <span class="built_in">queue</span>[front] = <span class="number">-1</span>;</span><br><span class="line">        sem_post(&amp;p);<span class="comment">// 将信号的值加1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"c:%d\n"</span>, tmp);<span class="comment">//要消费的量一般先给中间变量</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        sleep(rand()%<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pid, cid;</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    sem_init(&amp;p,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">    sem_init(&amp;c,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    pthread_create(&amp;pid,<span class="literal">NULL</span>,product,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid,<span class="literal">NULL</span>,consume,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//等待两个线程的汇合</span></span><br><span class="line">    pthread_join(pid,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;p);</span><br><span class="line">    sem_destroy(&amp;c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、共享内存"><a href="#五、共享内存" class="headerlink" title="五、共享内存"></a>五、共享内存</h2><p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。</p><p>共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程<br>共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问，例如前面说到的信号量。</p><h3 id="1、特点-3"><a href="#1、特点-3" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li><p>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</p></li><li><p>因为多个进程可以同时操作，所以需要进行同步。</p></li><li><p>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</p></li></ol><h3 id="2、原型-3"><a href="#2、原型-3" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 断开与共享内存的连接：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>; </span><br><span class="line"><span class="comment">// 控制共享内存的相关信息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>当用shmget函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。</p><p>当一段共享内存被创建以后，它并不能被任何进程访问。必须使用shmat函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</p><p>shmdt函数是用来断开shmat建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</p><p>shmctl函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是IPC_RMID（从系统中删除该共享内存）。</p><h2 id="3、例子-4"><a href="#3、例子-4" class="headerlink" title="3、例子"></a>3、例子</h2><h4 id="写端"><a href="#写端" class="headerlink" title="写端"></a>写端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILENAME <span class="meta-string">"/dev/null"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s string\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">key_t</span> shm_key = ftok(FILENAME, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> shm_size = getpagesize();</span><br><span class="line">    <span class="keyword">int</span> shm_id = shmget(shm_key, shm_size, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shm_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *data = (<span class="keyword">char</span> *)shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(data == (<span class="keyword">void</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmat"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(data, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shmdt(data) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmdt"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读端"><a href="#读端" class="headerlink" title="读端"></a>读端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILENAME <span class="meta-string">"/dev/null"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> shm_key = ftok(FILENAME, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> shm_size = getpagesize();</span><br><span class="line">    <span class="keyword">int</span> shm_id = shmget(shm_key, shm_size, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shm_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *data = (<span class="keyword">char</span> *)shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(data == (<span class="keyword">void</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmat"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"data: %s\n"</span>, data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shmdt(data) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmdt"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、管道&quot;&gt;&lt;a href=&quot;#一、管道&quot; class=&quot;headerlink&quot; title=&quot;一、管道&quot;&gt;&lt;/a&gt;一、管道&lt;/h1&gt;&lt;p&gt;管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。&lt;/p&gt;
&lt;h3 id=&quot;1、特点：&quot;&gt;&lt;a href=&quot;#1、
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>分布式对时</title>
    <link href="http://yoursite.com/blog/2019/12/19/12-19%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/12/19/12-19技术笔记/</id>
    <published>2019-12-19T06:34:56.000Z</published>
    <updated>2019-12-26T03:09:37.685Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.qq.com/pdf/DT1VSaFBvSGx3RWxi" target="_blank" rel="noopener">https://docs.qq.com/pdf/DT1VSaFBvSGx3RWxi</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.qq.com/pdf/DT1VSaFBvSGx3RWxi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.qq.com/pdf/DT1VSaFBvSGx3RWxi&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mysql支持json</title>
    <link href="http://yoursite.com/blog/2019/12/11/12-11%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2019/12/11/12-11技术笔记-1/</id>
    <published>2019-12-11T06:16:54.000Z</published>
    <updated>2019-12-26T03:07:23.915Z</updated>
    
    <content type="html"><![CDATA[<p>mysql自5.7开始支持json。</p><h2 id="数据库建表"><a href="#数据库建表" class="headerlink" title="数据库建表"></a>数据库建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`json_test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID '</span>,</span><br><span class="line">  <span class="string">`attr`</span> <span class="keyword">json</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'属性类型'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><h2 id="数组中查询"><a href="#数组中查询" class="headerlink" title="数组中查询"></a>数组中查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`json_test`</span> (<span class="keyword">attr</span>) <span class="keyword">VALUES</span> (<span class="string">'[1, 2, 3]'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> json_test <span class="keyword">WHERE</span> JSON_CONTAINS(<span class="keyword">attr</span>, <span class="string">'2'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iduser_idattr    update_time        create_time</span><br><span class="line">11    [1, 2, 3]2019-12-11 11:45:062019-12-11 11:45:06</span><br></pre></td></tr></table></figure><h2 id="key-value查询"><a href="#key-value查询" class="headerlink" title="key-value查询"></a>key-value查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`json_test`</span> (<span class="keyword">attr</span>) <span class="keyword">VALUES</span> (<span class="string">'&#123;"color":"red","height":1.5&#125;'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> json_test <span class="keyword">WHERE</span> <span class="keyword">attr</span>-&gt;<span class="string">'$.color'</span> = <span class="string">'red'</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iduser_id attr                               update_time create_time</span><br><span class="line">21     &#123;"color": "red", "height": 1.5&#125;2019-12-11 11:54:442019-12-11 11:54:44</span><br></pre></td></tr></table></figure><p>也可以查key存在</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> json_test <span class="keyword">WHERE</span> JSON_CONTAINS_PATH(<span class="keyword">attr</span>,<span class="string">'all'</span>,<span class="string">'$.color'</span>)</span><br></pre></td></tr></table></figure><p>或者用 JSON_EXTRACT查value存在</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>全部更新和插入类似。</p><p>也可以指定key，更新value</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> json_test <span class="keyword">SET</span> <span class="keyword">attr</span> = JSON_SET(<span class="keyword">attr</span>, <span class="string">'$.color'</span>, <span class="string">'blue'</span>) <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql自5.7开始支持json。&lt;/p&gt;
&lt;h2 id=&quot;数据库建表&quot;&gt;&lt;a href=&quot;#数据库建表&quot; class=&quot;headerlink&quot; title=&quot;数据库建表&quot;&gt;&lt;/a&gt;数据库建表&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>NTP协议</title>
    <link href="http://yoursite.com/blog/2019/12/06/12-6%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2019/12/06/12-6技术笔记-1/</id>
    <published>2019-12-06T09:05:36.000Z</published>
    <updated>2019-12-08T14:15:59.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算rtt"><a href="#计算rtt" class="headerlink" title="计算rtt"></a>计算rtt</h1><p>即使两个服务器时间不一样，他们之间的rtt也是可以计算的，过程如下：</p><p>Device A发送一个NTP报文给Device B，该报文带有它离开Device A时的时间戳，该时间戳为10:00:00am（T1）。<br>当此NTP报文到达Device B时，Device B加上自己的时间戳，该时间戳为11:00:01am（T2）。<br>当此NTP报文离开Device B时，Device B再加上自己的时间戳，该时间戳为11:00:02am（T3）。<br>当Device A接收到该响应报文时，Device A的本地时间为10:00:03am（T4）。  </p><p>这样，Device A已经拥有足够的信息来计算两个重要的参数：  </p><p>NTP报文的往返时延Delay=（T4-T1）-（T3-T2）=2秒。<br>Device A相对Device B的时间差offset=（（T2-T1）+（T3-T4））/2=1小时。  </p><p>Device A就能够根据这些信息来设定自己的时钟，与Device B的时钟同步。</p><h1 id="时钟分层"><a href="#时钟分层" class="headerlink" title="时钟分层"></a>时钟分层</h1><p>NTP使用一个分层、半分层的时间源系统。该层次的每个级别被称为“stratum”，顶层分配为数字0。一个通过阶层n同步的服务器将运行在阶层n + 1。数字表示与参考时钟的距离，用于防止层次结构中的循环依赖性。阶层并不总是指示质量或可靠性；在阶层3的时间源得到比阶层2时间源更高的时间质量也很常见。电信系统对[时钟层]使用不同的定义。以下提供了阶层0、1、2、3的简要描述。</p><ol><li>阶层0（Stratum 0）</li></ol><p>这些是高精度计时设备，例如[原子钟]（如铯、铷）、[GPS时钟]或其他[无线电时钟]。它们生成非常精确的[脉冲秒]信号，触发所连接计算机上的[中断]和时间戳。阶层0设备也称为参考（基准）时钟。</p><ol start="2"><li>阶层1</li></ol><p>这些与阶层0设备相连、在几微秒误差内同步[系统时钟]的计算机。阶层1服务器可能与其他阶层1服务器对等相连，以进行完整性检查和备份。它们也被称为主要（primary）时间服务器</p><ol start="3"><li>阶层2</li></ol><p>这些计算机通过网络与阶层1服务器同步。提供阶层2的计算机将查询多个阶层1服务器。阶层2计算机也可能与其他阶层2计算机对等相连，为对等组中的所有设备提供更健全稳定的时间。</p><ol start="3"><li>阶层3</li></ol><p>这些计算机与阶层2的服务器同步。它们使用与阶层2相同的算法进行对等和数据采样，并可以自己作为服务器担任阶层4计算机，以此类推。</p><p>阶层的上限为15；阶层16被用于标识设备未同步。每台计算机上的NTP算法相互构造一个[贝尔曼-福特算法]最短路径[生成树]，以最小化所有客户端到阶层1服务器的累积往返延迟。</p><p>典型的NTP客户端将定期[轮询]不同网络上的三个或更多服务器。为同步其时钟</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算rtt&quot;&gt;&lt;a href=&quot;#计算rtt&quot; class=&quot;headerlink&quot; title=&quot;计算rtt&quot;&gt;&lt;/a&gt;计算rtt&lt;/h1&gt;&lt;p&gt;即使两个服务器时间不一样，他们之间的rtt也是可以计算的，过程如下：&lt;/p&gt;
&lt;p&gt;Device A发送一个NTP报
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>kafka-admin</title>
    <link href="http://yoursite.com/blog/2019/11/03/11-3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/11/03/11-3技术笔记/</id>
    <published>2019-11-03T10:11:45.000Z</published>
    <updated>2019-11-03T10:46:03.033Z</updated>
    
    <content type="html"><![CDATA[<p>常见的有kafka manager和 eagle</p><p>大致是kafka从0.11.0.0版本开始， 提供了一个工具类 org.apache.kafka.clients.admin.KafkaAdminClient，不仅可以用来管理 broker、配置和 ACL（Access Control List），还可以用来管理主题，KafkaAdminClient 继承了 org.apache.kafka.clients.admin.AdminClient 抽象类，并提供了多种方法。诸如，</p><ul><li>创建主题：CreateTopicsResult createTopics(Collection newTopics)。</li><li>删除主题：DeleteTopicsResult deleteTopics(Collection topics)。</li><li>列出所有可用的主题：ListTopicsResult listTopics()。</li><li>查看主题的信息：DescribeTopicsResult describeTopics(Collection topicNames)。</li><li>查询配置信息：DescribeConfigsResult describeConfigs(Collection resources)。</li><li>修改配置信息：AlterConfigsResult alterConfigs(Map&lt;ConfigResource, Config&gt; configs)。</li><li>增加分区：CreatePartitionsResult createPartitions(Map&lt;String, NewPartitions&gt; newPartitions)。</li></ul><p>把这个做成一个可视化的，即admin的基础。</p><p>edge功能如下</p><p><img src="https://i.loli.net/2019/11/03/mT6oKS9ZWdiUELJ.png" alt="mT6oKS9ZWdiUELJ"></p><p>甚至还可以看消息发送和消费情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常见的有kafka manager和 eagle&lt;/p&gt;
&lt;p&gt;大致是kafka从0.11.0.0版本开始， 提供了一个工具类 org.apache.kafka.clients.admin.KafkaAdminClient，不仅可以用来管理 broker、配置和 ACL（A
      
    
    </summary>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kafka可靠性</title>
    <link href="http://yoursite.com/blog/2019/10/31/10-30%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2019/10/31/10-30技术笔记-1/</id>
    <published>2019-10-31T12:40:28.000Z</published>
    <updated>2019-11-03T13:30:09.681Z</updated>
    
    <content type="html"><![CDATA[<p>在 Kafka 中动态维护着一个 ISR 集合，处于 ISR 集合内的节点保持与 leader 相同的高水位（HW），只有位列其中的副本（unclean.leader.election.enable 配置为 false）才有资格被选为新的 leader。写入消息时只有等到所有ISR集合中的副本都确认收到之后才能被认为已经提交。位于 ISR 中的任何副本节点都有资格成为 leader，选举过程简单、开销低，这也是 Kafka 选用此模型的重要因素。</p><h2 id="副本数"><a href="#副本数" class="headerlink" title="副本数"></a>副本数</h2><p>显然，副本越多可靠性越高，但性能越差。权衡的结果是，一般都是3副本，极少数高可靠性要求，比如银行，可以采用5副本。</p><h2 id="acks"><a href="#acks" class="headerlink" title="acks"></a>acks</h2><p>acks有三个级别，0，1，-1。-1其实是正无穷的意思。</p><p>即，需要多少成功写入本地日志之后会告知生产者已经成功提交。</p><p>0，就是不需要写入本地日志，生产者只管发。</p><p>1，就是只有leader写入本地日志，就成功提交。可靠性问题就是，leader写入-&gt;告知成功提交-&gt;leader挂了-&gt;follower还没来得及同步-&gt;消息丢了。</p><p>-1，等待 ISR 中的 follower 副本全部同步完成才能够告知生产者已经成功提交，即使此时 leader 副本宕机，消息也不会丢失。如果ISR 中的所有副本同步之前 leader 副本宕机了，那么生产者会收到异常以此告知此次发送失败。</p><h2 id="消息发送模式"><a href="#消息发送模式" class="headerlink" title="消息发送模式"></a>消息发送模式</h2><p>发后即忘的模式，不管消息有没有被成功写入，生产者都不会收到通知，那么即使消息写入失败也无从得知。</p><p>同步和异步在可靠性上没区别，他们的区别在于顺序，同步需要等待消息返回，才会继续。异步是回调，意味着，同步可以保证顺序。</p><h2 id="ISR-集合中最小的副本数"><a href="#ISR-集合中最小的副本数" class="headerlink" title="ISR 集合中最小的副本数"></a>ISR 集合中最小的副本数</h2><p>因为ISR里的副本，一旦跟不上，就会被踢，如果leader 副本的消息流入速度很快，而 follower 副本的同步速度很慢，在某个临界点时所有的 follower 副本都被剔除出了 ISR 集合，那么 ISR 中只有一个 leader 副本，最终 acks = -1 演变为 acks = 1 的情形。</p><p>为了避免这个情况，有min.insync.replicas 参数（默认值为1）来作为辅助配合 acks = -1 来使用，个典型的配置方案为：副本数配置为3，min.insync.replicas 参数值配置为2。</p><p>很显然，这个配置很影响可用性。</p><h2 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h2><p>enable.auto.commit 参数的默认值为 true，即开启自动位移提交的功能，如果消费者没能消费成功或者挂了，消息同样也丢失了，所以可以设置手动位移提交。</p><p>但是会带来重复消费的问题，试想，消费者成功消费了，还没来得及手动位移提交，消费者挂了。消费者恢复，此时会重复消费这条消息。所以需要消费者这边做幂等处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Kafka 中动态维护着一个 ISR 集合，处于 ISR 集合内的节点保持与 leader 相同的高水位（HW），只有位列其中的副本（unclean.leader.election.enable 配置为 false）才有资格被选为新的 leader。写入消息时只有等到所
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kafka时间轮</title>
    <link href="http://yoursite.com/blog/2019/10/28/10-28%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/10/28/10-28技术笔记/</id>
    <published>2019-10-28T02:11:56.000Z</published>
    <updated>2019-10-31T12:40:38.371Z</updated>
    
    <content type="html"><![CDATA[<p>定时任务常规实现方法是延时队列DelayQueue，它的时间复杂度nlgn，不适合太多的延时任务，而时间轮时间复杂度1。</p><p><img src="https://i.loli.net/2019/10/28/Fwm5HZi2BSRQgVr.png" alt="Fwm5HZi2BSRQgVr"></p><p>Kafka 中的时间轮（TimingWheel）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。TimerTaskList 是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务（TimerTask）。</p><p>时间轮由多个时间格组成，每个时间格代表当前时间轮的基本时间跨度（tickMs）。时间轮的时间格个数是固定的，可用 wheelSize 来表示，那么整个时间轮的总体时间跨度（interval）可以通过公式 tickMs×wheelSize 计算得出。</p><p>时间轮还有一个表盘指针（currentTime），用来表示时间轮当前所处的时间，currentTime 是 tickMs 的整数倍。currentTime 可以将整个时间轮划分为到期部分和未到期部分，currentTime 当前指向的时间格也属于到期部分，表示刚好到期，需要处理此时间格所对应的 TimerTaskList 中的所有任务。</p><p>我们常见的钟表就是一种具有三层结构的时间轮，第一层时间轮 tickMs=1s、wheelSize=60、interval=1min，此为秒钟；第二层 tickMs=1min、wheelSize=60、interval=1hour，此为分钟；第三层 tickMs=1hour、wheelSize=12、interval=12hours，此为时钟。</p><p>Kafka 中会有一个线程来获取 DelayQueue 中到期的任务列表，有意思的是这个线程所对应的名称叫作“ExpiredOperationReaper”，可以直译为“过期操作收割机”，和第4节的“SkimpyOffsetMap”的取名有异曲同工之妙。当“收割机”线程获取 DelayQueue 中超时的任务列表 TimerTaskList 之后，既可以根据 TimerTaskList 的 expiration 来推进时间轮的时间，也可以就获取的 TimerTaskList 执行相应的操作，对里面的 TimerTaskEntry 该执行过期操作的就执行过期操作，该降级时间轮的就降级时间轮。</p><p>问题在于，时间是怎么推进的，方法是延时队列DelayQueue，那么为什么又绕了回来，区别在于延时队列DelayQueue里放的不再是具体的任务TimerTaskEntry，而是真正有任务的TimerTaskList，而对于时间轮来说，它只需要往delayQueue里面扔各种槽即可，这样的话，比如我们的定时任务长短不一，最长的跨度到了24年，这个delayQueue也仅仅只有300个元素。</p><p>而这个槽到期后，也就是被我们从delayQueue中poll出来后，我们只需要将槽中的所有任务循环一次，重新加到新的槽中（添加失败则直接执行）即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定时任务常规实现方法是延时队列DelayQueue，它的时间复杂度nlgn，不适合太多的延时任务，而时间轮时间复杂度1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/28/Fwm5HZi2BSRQgVr.png&quot; alt=&quot;Fwm
      
    
    </summary>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kafka协议设计</title>
    <link href="http://yoursite.com/blog/2019/10/25/10-25%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2019/10/25/10-25技术笔记-1/</id>
    <published>2019-10-25T02:16:09.000Z</published>
    <updated>2019-10-28T02:11:17.683Z</updated>
    
    <content type="html"><![CDATA[<p>kafka有很多种协议类型，但遵循同一种协议模式，在该协议模式下，不同协议类型的请求，请求体可以不同，但请求头是一致的。</p><p><strong>request的请求头由以下四部分组成。</strong></p><p>api_key：即请求类型，PRODUCE、FETCH标示发消息，拉消息等。</p><p>api_version：API版本号。</p><p>correlation_id：本次请求的id，由客户端指定的一个数字来唯一地标识这次请求的id，服务端在处理完请求后也会把同样的coorelation_id写到Response中，这样客户端就能把某个请求和响应对应起来了。</p><p>client_id：客户端id。</p><p><strong>response的请求头只有correlation_id。</strong></p><p>实际上，每次请求除了数据，还有一些其他属性数据，比如客户端acks，请求超时时间，分区编号，事务id等，这些内容是放在请求体中的，<img src="https://i.loli.net/2019/10/25/VkPvDW6XoOwTM4m.png" alt="VkPvDW6XoOwTM4m"></p><p>常见的协议还有response的，拉取消息的，相对没这么常见的还有几十种，其实大体类似，指定一些参数，以及指定topic\:partition\:offset，就可以指定到具体想要的一条消息</p><p>saQ`    11</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;kafka有很多种协议类型，但遵循同一种协议模式，在该协议模式下，不同协议类型的请求，请求体可以不同，但请求头是一致的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;request的请求头由以下四部分组成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;api_key：即请求类型，PRODUCE、FE
      
    
    </summary>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kafka磁盘存储</title>
    <link href="http://yoursite.com/blog/2019/10/12/10-12%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/10/12/10-12技术笔记/</id>
    <published>2019-10-12T10:21:46.000Z</published>
    <updated>2019-10-12T12:07:19.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序写"><a href="#顺序写" class="headerlink" title="顺序写"></a>顺序写</h1><p>一个由6块 7200r/min 的 RAID-5 阵列组成的磁盘簇的线性（顺序）写入速度可以达到 600MB/s，而随机写入速度只有 100KB/s，两者性能相差6000倍。操作系统可以针对线性读写做深层次的优化，比如预读（read-ahead，提前将一个比较大的磁盘块读入内存）和后写（write-behind，将很多小的逻辑写操作合并起来组成一个大的物理写操作）技术。</p><p><strong>顺序写盘的速度不仅比随机写盘的速度快，而且也比随机写内存的速度快</strong></p><p>kafka只在文件末尾追加数据，并且不能修改之前的数据，所以是顺序写盘，速度很快。</p><h1 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h1><p>页缓存技术基于局部性，相当于内存是磁盘热点数据的备份，要读写时先读写内存。</p><p>linux系统可以设置，当内存脏页比例达到多少时，写回磁盘。</p><p>Kafka 中大量使用了页缓存，这是 Kafka 实现高吞吐的重要因素之一。虽然消息都是先被写入页缓存，然后由操作系统负责具体的刷盘任务的，但在 Kafka 中同样提供了同步刷盘及间断性强制刷盘（fsync）的功能，这些功能可以通过参数来控制。</p><p>显然这是个代价问题，同步刷盘可以提高消息的可靠性，防止由于机器掉电等异常造成处于页缓存而没有及时写入磁盘的消息丢失，但是性能会变低，取决于业务来取舍。</p><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>考虑这样一种常用的情形：你需要将静态内容（类似图片、文件）展示给用户。这个情形就意味着需要先将静态内容从磁盘中复制出来放到一个内存 buf 中，然后将这个 buf 通过套接字（Socket）传输给用户，进而用户获得静态内容。</p><p>在这个过程中，文件 A 经历了4次复制的过程：</p><ol><li>调用 read() 时，文件 A 中的内容被复制到了内核模式下的 Read Buffer 中。</li><li>CPU 控制将内核模式数据复制到用户模式下。</li><li>调用 write() 时，将用户模式下的内容复制到内核模式下的 Socket Buffer 中。</li><li>将内核模式下的 Socket Buffer 的数据复制到网卡设备中传送</li></ol><p>如果采用了零拷贝技术，那么应用程序可以直接请求内核把磁盘中的数据传输给 Socket。</p><p>零拷贝技术通过 DMA（Direct Memory Access）技术将文件内容复制到内核模式下的 Read Buffer 中。不过没有数据被复制到 Socket Buffer，相反只有包含数据的位置和长度的信息的文件描述符被加到 Socket Buffer 中。DMA 引擎直接将数据从内核模式中传递到网卡设备（协议引擎）。这里数据只经历了2次复制就从磁盘中传送出去了，并且上下文切换也变成了2次。零拷贝是针对内核模式而言的，数据在内核模式下实现了零拷贝。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;顺序写&quot;&gt;&lt;a href=&quot;#顺序写&quot; class=&quot;headerlink&quot; title=&quot;顺序写&quot;&gt;&lt;/a&gt;顺序写&lt;/h1&gt;&lt;p&gt;一个由6块 7200r/min 的 RAID-5 阵列组成的磁盘簇的线性（顺序）写入速度可以达到 600MB/s，而随机写入速度只有
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kafka日志格式与索引</title>
    <link href="http://yoursite.com/blog/2019/10/10/10-10%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/10/10/10-10技术笔记/</id>
    <published>2019-10-10T02:34:23.000Z</published>
    <updated>2019-10-12T10:20:39.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h1><p>Log 和 LogSegment 也不是纯粹物理意义上的概念，Log 在物理上只以文件夹的形式存储，而每个 LogSegment 对应于磁盘上的一个日志文件和两个索引文件，以及可能的其他文件（比如以“.txnindex”为后缀的事务索引文件）。</p><p>为了便于消息的检索，每个 LogSegment 中的日志文件（以“.log”为文件后缀）都有对应的两个索引文件：偏移量索引文件（以“.index”为文件后缀）和时间戳索引文件（以“.timeindex”为文件后缀）。每个 LogSegment 都有一个基准偏移量 baseOffset，用来表示当前 LogSegment 中第一条消息的 offset。偏移量是一个64位的长整型数，日志文件和两个索引文件都是根据基准偏移量（baseOffset）命名的，名称固定为20位数字，没有达到的位数则用0填充。</p><p>消费者提交的位移是保存在 Kafka 内部的主题__consumer_offsets中的，初始情况下这个主题并不存在，当第一次有消费者消费消息时会自动创建这个主题。</p><p><img src="https://i.loli.net/2019/10/10/N7OlAxwmCsgvbMB.png" alt="N7OlAxwmCsgvbMB"></p><ul><li>crc32（4B）：crc32 校验值。校验范围为 magic 至 value 之间。</li><li>magic（1B）：消息格式版本号，此版本的 magic 值为0。</li><li>attributes（1B）：消息的属性。总共占1个字节，低3位表示压缩类型：0表示 NONE、1表示 GZIP、2表示 SNAPPY、3表示 LZ4（LZ4 自 Kafka 0.9.x引入），其余位保留。</li><li>key length（4B）：表示消息的 key 的长度。如果为-1，则表示没有设置 key，即 key = null。</li><li>key：可选，如果没有 key 则无此字段。</li><li>value length（4B）：实际消息体的长度。如果为-1，则表示消息为空。</li><li>value：消息体。可以为空，比如墓碑（tombstone）消息。</li></ul><h1 id="日志索引"><a href="#日志索引" class="headerlink" title="日志索引"></a>日志索引</h1><p>每个日志分段文件对应了两个索引文件，主要用来提高查找消息的效率。偏移量索引文件用来建立消息偏移量（offset）到物理地址之间的映射关系，方便快速定位消息所在的物理文件位置；时间戳索引文件则根据指定的时间戳（timestamp）来查找对应的偏移量信息。</p><p>Kafka 中的索引文件以稀疏索引（sparse index）的方式构造消息的索引，它并不保证每个消息在索引文件中都有对应的索引项。每当写入一定量（由 broker 端参数 log.index.interval.bytes 指定，默认值为4096，即 4KB）的消息时，偏移量索引文件和时间戳索引文件分别增加一个偏移量索引项和时间戳索引项，增大或减小 log.index.interval.bytes 的值，对应地可以增加或缩小索引项的密度。</p><p>稀疏索引通过 MappedByteBuffer 将索引文件映射到内存中，以加快索引的查询速度。偏移量索引文件中的偏移量是单调递增的，查询指定偏移量时，使用二分查找法来快速定位偏移量的位置，如果指定的偏移量不在索引文件中，则会返回小于指定偏移量的最大偏移量。</p><p>时间戳索引类似。</p><p>索引会切分，规则较多，日志大小，偏移量，时间等，容易理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日志格式&quot;&gt;&lt;a href=&quot;#日志格式&quot; class=&quot;headerlink&quot; title=&quot;日志格式&quot;&gt;&lt;/a&gt;日志格式&lt;/h1&gt;&lt;p&gt;Log 和 LogSegment 也不是纯粹物理意义上的概念，Log 在物理上只以文件夹的形式存储，而每个 LogSegme
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kafka序列化、分区器、拦截器</title>
    <link href="http://yoursite.com/blog/2019/09/27/9-27%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-2/"/>
    <id>http://yoursite.com/blog/2019/09/27/9-27技术笔记-2/</id>
    <published>2019-09-27T10:24:57.000Z</published>
    <updated>2019-09-27T12:15:56.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>生产者需要用序列化器（Serializer）把对象转换成字节数组才能通过网络发送给 Kafka。而在对侧，消费者需要用反序列化器（Deserializer）把从 Kafka 中收到的字节数组转换成相应的对象。</p><p><strong>待学习</strong>：公司kafka封装的sarama，是怎么序列化的。</p><h1 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h1><p>如果消息 ProducerRecord 中指定了 partition 字段，那么就不需要分区器的作用，因为 partition 代表的就是所要发往的分区号。如果消息 ProducerRecord 中没有指定 partition 字段，那么就需要依赖分区器，根据 key 这个字段来计算 partition 的值。分区器的作用就是为消息分配分区。</p><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>Kafka 一共有两种拦截器：生产者拦截器和消费者拦截器。</p><p>生产者拦截器既可以用来在消息发送前做一些准备工作，比如按照某个规则过滤不符合要求的消息、修改消息的内容等，也可以用来在发送回调逻辑前做一些定制化的需求，比如统计类工作。</p><h1 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h1><p>1.发送并忘记 2.同步发送 3.异步发送+回调函数。</p><p>效率大概1:10:15</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化&quot;&gt;&lt;/a&gt;序列化&lt;/h1&gt;&lt;p&gt;生产者需要用序列化器（Serializer）把对象转换成字节数组才能通过网络发送给 Kafka。而在对侧，消费者需要用反序列化器（D
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kafka多副本同步机制</title>
    <link href="http://yoursite.com/blog/2019/09/24/9-24%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/09/24/9-24技术笔记/</id>
    <published>2019-09-24T02:36:35.000Z</published>
    <updated>2019-09-27T03:42:28.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主题和分区"><a href="#主题和分区" class="headerlink" title="主题和分区"></a>主题和分区</h1><p>kafka发消息是需要指定主题的，也可以手动指定分区，不指定的话，可以指定或许自制分区选择策略，也可以用默认的，即有key则hash，没有key则随机。</p><p>只要如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡和水平扩展。另外，多个订阅者可以从一个或者多个分区中同时消费数据，以支撑海量数据处理能力。</p><h1 id="分区和副本"><a href="#分区和副本" class="headerlink" title="分区和副本"></a>分区和副本</h1><p>为了提高可靠性，分区引入了多副本（Replica）机制，通过增加副本数量可以提升容灾能力。但是副本并不提供读写功能，只有备份能力。副本处于不同的 broker 中，当 leader 副本出现故障时，从 follower 副本中重新选举新的 leader 副本对外提供服务。</p><p><img src="https://i.loli.net/2019/09/24/oAb9LGOnCaVFkec.png" alt="oAb9LGOnCaVFkec"></p><p>如图，一个三个分区，每个分区有三个副本，分布在4个broker中。</p><h1 id="消费容灾"><a href="#消费容灾" class="headerlink" title="消费容灾"></a>消费容灾</h1><p>offset 是消息在分区中的唯一标识，Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说，Kafka 保证的是分区有序而不是主题有序。Consumer 使用拉（Pull）模式从服务端拉取消息，并且保存消费的具体位置，当消费者宕机后恢复上线时可以根据之前保存的消费位置重新拉取需要的消息进行消费，这样就不会造成消息丢失。</p><h1 id="ISR与高水位"><a href="#ISR与高水位" class="headerlink" title="ISR与高水位"></a>ISR与高水位</h1><p>分区中的所有副本统称为 AR（Assigned Replicas）。所有与 leader 副本保持一定程度同步的副本（包括 leader 副本在内）组成ISR（In-Sync Replicas），ISR 集合是 AR 集合中的一个子集。消息会先发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步，同步期间内 follower 副本相对于 leader 副本而言会有一定程度的滞后。</p><p>高水位，HW，即ISR中同步最慢的那个，所同步到的位置。</p><p><img src="https://i.loli.net/2019/09/24/inU1oKQAL6WtNv2.png" alt="inU1oKQAL6WtNv2"></p><p>如图，该分区有两个副本，同步进度不同，都在ISR中，则可读到的消息，是0123，因为4还没完全同步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主题和分区&quot;&gt;&lt;a href=&quot;#主题和分区&quot; class=&quot;headerlink&quot; title=&quot;主题和分区&quot;&gt;&lt;/a&gt;主题和分区&lt;/h1&gt;&lt;p&gt;kafka发消息是需要指定主题的，也可以手动指定分区，不指定的话，可以指定或许自制分区选择策略，也可以用默认的，即有
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>linux性能分析工具</title>
    <link href="http://yoursite.com/blog/2019/09/22/9-22%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/09/22/9-22技术笔记/</id>
    <published>2019-09-22T11:31:32.000Z</published>
    <updated>2019-09-22T12:00:32.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vmsta"><a href="#vmsta" class="headerlink" title="vmsta"></a>vmsta</h1><p>可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视。</p><p>一般有两个参数，第一个是采样间隔，第二个是采样次数，可省略第二个参数，会一直执行下去直到手动停止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 0  0      0 257172 327980 5486280    0    0     1    13    0    0  1  1 97  1  0</span><br><span class="line"> 0  0      0 278168 327980 5486332    0    0     0    37 1583 3408  1  0 97  2  0</span><br><span class="line"> 0  0      0 266540 327980 5486348    0    0     0    26 1803 3684  1  0 98  0  0</span><br><span class="line"> 0  1      0 266964 327980 5484616    0    0     0    78 1647 4011  1  1 95  3  0</span><br></pre></td></tr></table></figure><p>第一行显示了系统自启动以来的平均值，第二行开始显示现在正在发生的情况，接下来的行会显示每5秒间隔发生了什么，每一列的含义在头部，如下所示：</p><p>▪ procs：r这一列显示了多少进程在等待cpu，b列显示多少进程正在不可中断的休眠（等待IO）。</p><p>▪ memory：swapd列显示了多少块被换出了磁盘（页面交换），剩下的列显示了多少块是空闲的（未被使用），多少块正在被用作缓冲区，以及多少正在被用作操作系统的缓存。</p><p>▪ swap：显示交换活动：每秒有多少块正在被换入（从磁盘）和换出（到磁盘）。</p><p>▪ io：显示了多少块从块设备读取（bi）和写出（bo）,通常反映了硬盘I/O。</p><p>▪ system：显示每秒中断(in)和上下文切换（cs）的数量。</p><p>▪ cpu：显示所有的cpu时间花费在各类操作的百分比，包括执行用户代码（非内核），执行系统代码（内核），空闲以及等待IO。</p><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p> Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p><p>主要参数-aux 显示所有包含其他使用者的行程</p><h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><p>netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p><p>常用参数：</p><p>-a或–all 显示所有连线中的Socket。</p><p>-n或–numeric 直接使用IP地址，而不通过域名服务器。</p><p>-p或–programs 显示正在使用Socket的程序识别码和程序名称。</p><p>-t或–tcp 显示TCP传输协议的连线状况。</p><p><strong>然而Debian没有预装netstat</strong></p><h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">top - 19:57:18 up  2:07,  0 users,  load average: 8.88, 6.55, 6.53</span><br><span class="line">Tasks:   9 total,   1 running,   8 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  5.7 us,  0.0 sy,  0.0 ni, 94.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem:   4194304 total,    38392 used,  4155912 free,        0 buffers</span><br><span class="line">KiB Swap:        0 total,        0 used,        0 free.     9920 cached Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                                      </span><br><span class="line">     57 root      20   0  893576  32220  16872 S   3.0  0.8   3:21.04 toutiao.ev.wall                                                                                                                              </span><br><span class="line">      1 root      20   0   52868   6928   5432 S   0.0  0.2   0:01.61 systemd                                                                                                                                      </span><br><span class="line">     23 daemon    20   0   19028   1736   1568 S   0.0  0.0   0:00.00 atd                                                                                                                                          </span><br><span class="line">     26 root      20   0   29156   2800   2556 S   0.0  0.1   0:00.01 cron                                                                                                                                         </span><br><span class="line">     29 unscd     20   0   14776   1748   1608 S   0.0  0.0   0:00.26 nscd                                                                                                                                         </span><br><span class="line">     33 root      20   0  172092   2888   2472 S   0.0  0.1   0:00.01 rsyslogd                                                                                                                                     </span><br><span class="line">     50 root      20   0   43796   7552   7108 S   0.0  0.2   0:00.02 systemd-journal                                                                                                                              </span><br><span class="line">  13489 root      20   0   15184   3600   3084 S   0.0  0.1   0:00.04 bash                                                                                                                                         </span><br><span class="line">  19242 root      20   0   16808   2580   2228 R   0.0  0.1   0:00.01 top</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vmsta&quot;&gt;&lt;a href=&quot;#vmsta&quot; class=&quot;headerlink&quot; title=&quot;vmsta&quot;&gt;&lt;/a&gt;vmsta&lt;/h1&gt;&lt;p&gt;可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视。&lt;/p&gt;
&lt;p&gt;一般有两个参数，第一个是采样间隔，第二个是
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>shellscript数组与函数</title>
    <link href="http://yoursite.com/blog/2019/09/17/9-17%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2019/09/17/9-17技术笔记-1/</id>
    <published>2019-09-17T03:32:57.000Z</published>
    <updated>2019-09-17T08:47:26.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小，并且从0开始。</p><p>Shell 数组用括号来表示，元素用”空格”符号分割开。即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure><p>也可以用下标来定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure><p>和其他类似，@和*表示所有，#表示长度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">marray[0]=A</span><br><span class="line">marray[1]=B</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"content: <span class="variable">$&#123;marray[@]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"lenth: <span class="variable">$&#123;#marray[*]&#125;</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ ./array.sh</span><br><span class="line">content: A B</span><br><span class="line">lenth: 2</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数严格定义，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而function关键字可以省略，返回值也可以省略，将以最后一条命令运行结果，作为返回值。而函数不用写形式参数，传入参数后，就像bash，直接用@123取参数，就像bash，#*等的意义</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>参数个数</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">        sum=0</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> $*</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                sum=`expr <span class="variable">$sum</span> + <span class="variable">$num</span>`</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"sum=<span class="variable">$sum</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func 1 2 3 4 5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ ./func.sh</span><br><span class="line">sum=15</span><br></pre></td></tr></table></figure><p>如上，expr是运算符，表数字运算.</p><p>直接用加法就是字符串拼接，结果会是”sum=0+1+2+3+4+5”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小，并且从0开始。&lt;/p&gt;
&lt;p&gt;Shell 数组用括号来表
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>shellscript选择与循环</title>
    <link href="http://yoursite.com/blog/2019/09/10/9-10%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/09/10/9-10技术笔记/</id>
    <published>2019-09-10T07:30:22.000Z</published>
    <updated>2019-09-10T10:42:26.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件命令"><a href="#条件命令" class="headerlink" title="条件命令"></a>条件命令</h2><p>在bash脚本编程中，我们经常做一些条件判断， 我们主要用到了三种，test，单中括号，双中括号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ $? –eq 0 ]</span><br><span class="line"></span><br><span class="line">[[ $myvar == “mysql” ]]</span><br><span class="line"></span><br><span class="line">test 1 -eq 0</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>test是bash内建命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ <span class="built_in">test</span> 1 -ne 0 &amp;&amp;<span class="built_in">echo</span> ok</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>ne是不等于的意思，即1不等于0，就输出ok.</p><p>man test可以看见所有参数用法，摘录一点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">( EXPRESSION )</span><br><span class="line">       EXPRESSION is true</span><br><span class="line"></span><br><span class="line">! EXPRESSION</span><br><span class="line">       EXPRESSION is false</span><br><span class="line"></span><br><span class="line">EXPRESSION1 -a EXPRESSION2</span><br><span class="line">       both EXPRESSION1 and EXPRESSION2 are true</span><br><span class="line"></span><br><span class="line">EXPRESSION1 -o EXPRESSION2</span><br><span class="line">       either EXPRESSION1 or EXPRESSION2 is true</span><br><span class="line">       </span><br><span class="line">       STRING1 = STRING2</span><br><span class="line">       the strings are equal</span><br><span class="line"></span><br><span class="line">STRING1 != STRING2</span><br><span class="line">       the strings are not equal</span><br><span class="line"></span><br><span class="line">INTEGER1 -eq INTEGER2</span><br><span class="line">       INTEGER1 is equal to INTEGER2</span><br><span class="line"></span><br><span class="line">INTEGER1 -ge INTEGER2</span><br><span class="line">       INTEGER1 is greater than or equal to INTEGER2</span><br><span class="line"></span><br><span class="line">INTEGER1 -gt INTEGER2</span><br><span class="line">       INTEGER1 is greater than INTEGER2</span><br></pre></td></tr></table></figure><h3 id="单中括号"><a href="#单中括号" class="headerlink" title="单中括号"></a>单中括号</h3><p>实际上[ 这个是个内建命令，可以执行which [查看。</p><p>这样就可以理解奇怪的规定。即然是命令，那么命令与后面的参数就得用空格隔开，使用[时后面需要有一个空格的原因。所以[1=2]这样的写法将会报错。单中括号与test命令是等价的。</p><p>这里有一个陷阱，既然 <code>都是以参数的形式传递给</code>test` 命令的， 那么如果参数解析的结果是空或者带空格，那么就会因为缺少参数或者参数数量不丢而崩掉。</p><p>所以最好参数用双引号包起来。</p><h3 id="双中括号"><a href="#双中括号" class="headerlink" title="双中括号"></a>双中括号</h3><p>双中括号不是命令，而是shell关键字。因为不是命令，因此不受制与 Shell 的 <strong>参数展开</strong>，比如 不需要用引号包裹所有变量，也支持类似 <code>&amp;&amp;</code>，<code>||</code> 这样的逻辑操作而不需要用类似 <code>-a</code>，<code>-o</code> 这样的参数。</p><h3 id="双小括号"><a href="#双小括号" class="headerlink" title="双小括号"></a>双小括号</h3><p>算术展开的语法是  <code>$((expression))</code>，这是从其他编程语言来的人最顺手的算术操作方式。与  <code>test</code>  命令相比，</p><ul><li>C 风格的算术操作语法</li><li>Shell 会把  <code>expression</code>  内容的每一项都当做就像被引号包裹了一样。</li><li>会依次进行<strong>参数展开</strong>、<strong>命令替换</strong>，和  <strong>引号移除</strong>。</li></ul><p>因此可以不需要像  <code>test</code>  命令那样用引号包裹所有变量，也不需要注意空格，也可以写 C 风格的操作。</p><p>然后，对于C，1是ture，0是false。bah相反。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>因为test和[]是命令，所以逻辑运算符是以参数的形式体现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ [ 1 -ne 0 ]&amp;&amp;<span class="built_in">echo</span> ok</span><br><span class="line">ok</span><br><span class="line">yangzhuo@n224-019-077:~/file$ [ 1 -ne 0 || 1 -gt 0 ]&amp;&amp;<span class="built_in">echo</span> ok</span><br><span class="line">-bash: [: missing `]<span class="string">'</span></span><br><span class="line"><span class="string">-bash: 1: command not found</span></span><br></pre></td></tr></table></figure><p>只能这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ [ 1 -ne 0 ] || [ 1 -gt 0 ]&amp;&amp;<span class="built_in">echo</span> ok</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>当然[[]]就不受限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ [[ 1 -ne 0  ||  1 -gt 0 ]]&amp;&amp;echo ok</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>甚至</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ [[ 1 != 0  ||  1 &gt; 0 ]]&amp;&amp;<span class="built_in">echo</span> ok</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">"num?"</span> num</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;num&#125;</span> -gt 10 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"big"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$&#123;num&#125;</span> - eq 10]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"equal"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"small"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$&#123;yn&#125;</span>"</span> != <span class="string">"yes"</span> -a <span class="string">"<span class="variable">$&#123;yn&#125;</span>"</span> != <span class="string">"YES"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Please input yes/YES to stop this program: "</span> yn </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"OK! you input the correct answer."</span></span><br></pre></td></tr></table></figure><p>while do done结构，也有until do done，直到。。。其实没啥用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s=0 <span class="comment"># 这是加总的数值变量</span></span><br><span class="line">i=0 <span class="comment"># 这是累计的数值，亦即是 1, 2, 3....</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$&#123;i&#125;</span>"</span> != <span class="string">"100"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">i=$（（<span class="variable">$i</span>+1）） <span class="comment"># 每次 i 都会增加 1</span></span><br><span class="line">s=$（（<span class="variable">$s</span>+<span class="variable">$i</span>）） <span class="comment"># 每次都会加总一次！</span></span><br><span class="line"><span class="keyword">done</span> <span class="built_in">echo</span> <span class="string">"The result of '1+2+3+...+100' is ==&gt; <span class="variable">$s</span>"</span></span><br></pre></td></tr></table></figure><p>这是while的一般用法。</p><p>for循环支持for in 和三段式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">"Please input a number, I will count for 1+2+...+your_input: "</span> nu</span><br><span class="line">s=0</span><br><span class="line"><span class="keyword">for</span> （（ i=1; i&lt;=<span class="variable">$&#123;nu&#125;</span>; i=i+1 ））</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">s=$（（<span class="variable">$&#123;s&#125;</span>+<span class="variable">$&#123;i&#125;</span>））</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result of '1+2+3+...+<span class="variable">$&#123;nu&#125;</span>' is ==&gt; <span class="variable">$&#123;s&#125;</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"There are <span class="variable">$&#123;animal&#125;</span>s.... "</span> <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>即in后面接空格隔开的，或者seq联系数字.</p><p>也可以直接使用 bash 的内置机制来处理！可以使用 {1..100} 来取代 $（seq 1 100） 。 大括号内的前面/后面用两个字符，中间以两个小数点来代表连续出现的意思。例如要持续输出 a, b, c…g 的话， 就可以使用“ echo {a..g} ”这样的表 示方式！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sitenu <span class="keyword">in</span> $（seq 1 100） <span class="comment"># seq 为 sequence（连续） 的缩写之意</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment"># 下面的程序在取得 ping 的回传值是正确的还是失败的！</span></span><br><span class="line">ping -c 1 -w 1 <span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> &amp;&gt; /dev/null &amp;&amp; result=0 || result=1</span><br><span class="line"><span class="comment"># 开始显示结果是正确的启动 （UP） 还是错误的没有连通 （DOWN）</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;result&#125;</span>"</span> == 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Server <span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> is UP."</span> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Server <span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> is DOWN."</span> </span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;条件命令&quot;&gt;&lt;a href=&quot;#条件命令&quot; class=&quot;headerlink&quot; title=&quot;条件命令&quot;&gt;&lt;/a&gt;条件命令&lt;/h2&gt;&lt;p&gt;在bash脚本编程中，我们经常做一些条件判断， 我们主要用到了三种，test，单中括号，双中括号。&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>shellScript入门</title>
    <link href="http://yoursite.com/blog/2019/09/08/9-8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/09/08/9-8技术笔记/</id>
    <published>2019-09-08T06:56:26.000Z</published>
    <updated>2019-09-08T12:46:06.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用者输入变量内容"><a href="#使用者输入变量内容" class="headerlink" title="使用者输入变量内容"></a>使用者输入变量内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"enter cnt"</span> cnt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"will go <span class="variable">$cnt</span> num"</span></span><br><span class="line"></span><br><span class="line">yangzhuo@n224-019-077:~/file$ vim test.sh</span><br><span class="line">yangzhuo@n224-019-077:~/file$ sh test.sh</span><br><span class="line">enter cnt7</span><br><span class="line">will go 7 num</span><br></pre></td></tr></table></figure><p>read让用户输入参数</p><h2 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yesterday=`date -d last-day +%Y-%m-%d`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$yesterday</span></span><br><span class="line"></span><br><span class="line">curday=`date +%Y-%m-%d`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$curday</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"现在时间：`date '+%Y%m%d %T'`"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"现在时间：`date '+%Y%m%d %H%M%S'`"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> `date <span class="string">'+%Y%m%d-%H%M%S'</span>`</span><br><span class="line"></span><br><span class="line">send=`date --date=<span class="string">'3 hours ago'</span> <span class="string">'+%Y-%m-%d %H:%M:%S'</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$send</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-09-07</span><br><span class="line">2019-09-08</span><br><span class="line">现在时间：20190908 15:14:56</span><br><span class="line">现在时间：20190908 151456</span><br><span class="line">20190908-151456</span><br><span class="line">2019-09-08 12:14:56</span><br></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p><strong><em>= 变量为null时, 同时改变变量值</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxidc /]# unset name</span><br><span class="line">[root@linuxidc /]# echo $&#123;name=linuxmi&#125;</span><br><span class="line">linuxmi</span><br><span class="line">[root@linuxidc /]# echo $name</span><br><span class="line">linuxmi</span><br><span class="line">[root@linuxidc /]# name=&quot;&quot;</span><br><span class="line">[root@linuxidc /]# echo $&#123;name=linuxmi&#125;</span><br><span class="line"></span><br><span class="line">[root@linuxidc /]#</span><br></pre></td></tr></table></figure><p><strong><em>-  变量为null时, 取默认值</em></strong></p><p><strong><em>:- 变量为null或空字符时, 取默认值</em></strong></p><p><strong><em>:= 变量为null时, 同时改变变量值</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用者输入变量内容&quot;&gt;&lt;a href=&quot;#使用者输入变量内容&quot; class=&quot;headerlink&quot; title=&quot;使用者输入变量内容&quot;&gt;&lt;/a&gt;使用者输入变量内容&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>awk</title>
    <link href="http://yoursite.com/blog/2019/09/04/9-4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/09/04/9-4技术笔记/</id>
    <published>2019-09-04T06:08:02.000Z</published>
    <updated>2019-09-05T13:20:07.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="print"><a href="#print" class="headerlink" title="print"></a>print</h1><p>print其实和C差不多.</p><p>比如先来个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat print.txt</span><br><span class="line">Name Chinese English Math Average</span><br><span class="line">DmTsai 80 60 92 77.33</span><br><span class="line">VBird 75 55 80 70.00</span><br><span class="line">Ken 60 90 70 73.33</span><br></pre></td></tr></table></figure><p>%s,\t之类的，可以格式化输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ <span class="built_in">printf</span> <span class="string">'%s\t %s\t %s\t %s\t %s\t \n'</span> $(cat print.txt)</span><br><span class="line">Name     Chinese     English     Math     Average</span><br><span class="line">DmTsai     80     60     92     77.33</span><br><span class="line">VBird     75     55     80     70.00</span><br><span class="line">Ken     60     90     70     73.33</span><br></pre></td></tr></table></figure><p>还可以指定位数和内容，方法和C类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ <span class="built_in">printf</span> <span class="string">'%10s %5i %5i %5i %8.2f \n'</span> $(cat print.txt | grep -v Name)</span><br><span class="line">    DmTsai    80    60    92    77.33</span><br><span class="line">     VBird    75    55    80    70.00</span><br><span class="line">       Ken    60    90    70    73.33</span><br></pre></td></tr></table></figure><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><h2 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a>小栗子</h2><p>awk 主要是处理“每一行的字段内的数据”，而默认的“字段的分隔符号为 “空白键” 或 “[tab]键” ”。</p><p>比如刚才的数据，一共一行，每行有5列，这种表格状的数据，适合awk处理。</p><p>awk使用方式是<code></code>中放指令。</p><p>awk ‘条件类型1{动作1} 条件类型2{动作2} …’ filename</p><p>比如刚才的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat print.txt |awk <span class="string">'&#123;print $1 "\t" $3&#125;'</span></span><br><span class="line">Name    English</span><br><span class="line">DmTsai    60</span><br><span class="line">VBird    55</span><br><span class="line">Ken        90</span><br></pre></td></tr></table></figure><p>上表即是 awk 最常使用的动作，通过 print 的功能将字段数据列出来。字段的分隔则以空白键或 [tab] 按键来隔开。 因为不论哪一行都要处理，因此，就不需要有 “条件类型” 的限制！我所想要的是第一栏以及第三栏，每一行的每个字段都是有变量名称的，那就是 \$1, $2… 等变量名称。所以Name是第一个变量，English是第三个变量。</p><p>而\$0代表该行所有数据。</p><p>而非指令，即字符串，需要用“”包起来</p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>awk 的处理流程是：</p><ol><li><p>读入第一行，并将第一行的数据填入 $0, $1, $2…. 等变量当中； </p></li><li><p>依据 “条件类型” 的限制，判断是否需要进行后面的 “动作”； </p></li><li><p>做完所有的动作与条件类型； </p></li><li><p>若还有后续的“行”的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。</p></li></ol><p>awk 是“以行为一次处理的单位”， 而“以字段为最小的处理单位”。，那么 awk 需要知道有多少行</p><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>NF</td><td>每行字段数（总列数）</td></tr><tr><td>NR</td><td>当前在第几行</td></tr><tr><td>FS</td><td>分割字符（默认空格）</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat print.txt |awk <span class="string">'&#123;print "line @   "NR "content"$1&#125;'</span></span><br><span class="line">line @   1contentName</span><br><span class="line">line @   2contentDmTsai</span><br><span class="line">line @   3contentVBird</span><br><span class="line">line @   4contentKen</span><br></pre></td></tr></table></figure><p>awk还可以逻辑判断，比如输出英语成绩大于85的学生</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat print.txt |awk <span class="string">'$3&gt;85&#123;print $0&#125;'</span></span><br><span class="line">Name Chinese English Math Average</span><br><span class="line">Ken 60 90 70 73.33</span><br></pre></td></tr></table></figure><p>这种写法就是’条件类型1{动作1}’，第三个变量大于85是条件，输出整行是动作。至于为什么第一行可以展示，估计是asclii之类的。</p><h2 id="变量和统计"><a href="#变量和统计" class="headerlink" title="变量和统计"></a>变量和统计</h2><p>BEGIN和END表示最前和最后做某事，比如BEGIN {FS=”:”} ，意思是把分隔符变成：，不然第二行才会开始生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat print.txt |awk <span class="string">'NR==1&#123;printf "%10s %10s %10s %10s %10s %10s\n",$1,$2,$3,$4,$5,"total"&#125;</span></span><br><span class="line"><span class="string">NR&gt;=2&#123;total = $2 + $3 + $4</span></span><br><span class="line"><span class="string">printf "%10s %10d %10d %10d %10.2f %10d\n", $1, $2, $3, $4,$5, total&#125;'</span></span><br><span class="line">      Name    Chinese    English       Math    Average      total</span><br><span class="line">    DmTsai         80         60         92      77.33        232</span><br><span class="line">     VBird         75         55         80      70.00        210</span><br><span class="line">       Ken         60         90         70      73.33        220</span><br></pre></td></tr></table></figure><p>从这个例子可以看出，有这么几点</p><ol><li><p>printf格式化输出，用法和c类似</p></li><li><p>变量直接用名字和用即可，因为非变量用双引号括起来了</p></li><li><p>只要‘’的后单引号没结束，可以回车换行接着输入指令。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;print&quot;&gt;&lt;a href=&quot;#print&quot; class=&quot;headerlink&quot; title=&quot;print&quot;&gt;&lt;/a&gt;print&lt;/h1&gt;&lt;p&gt;print其实和C差不多.&lt;/p&gt;
&lt;p&gt;比如先来个文件&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>grep与正则表达式</title>
    <link href="http://yoursite.com/blog/2019/08/30/8-30%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/08/30/8-30技术笔记/</id>
    <published>2019-08-30T07:19:09.000Z</published>
    <updated>2019-08-30T08:20:53.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加单引号、双引号和不加引号"><a href="#加单引号、双引号和不加引号" class="headerlink" title="加单引号、双引号和不加引号"></a>加单引号、双引号和不加引号</h2><p><strong>单引号：</strong></p><p>可以说是所见即所得：即将单引号内的内容原样输出，或者描述为单引号里面看到的是什么就会输出什么。单引号’’是全引用，被单引号括起的内容不管是常量还是变量者不会发生替换。</p><p><strong>双引号：</strong></p><p>把双引号内的内容输出出来；如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容来。双引号””是部分引用，被双引号括起的内容常量还是常量，变量则会发生替换，替换成变量内容。</p><p><strong>不加引号：</strong></p><p>不会将含有空格的字符串视为一个整体输出, 如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容来，如果字符串中带有空格等特殊字符，则不能完整的输出，需要改加双引号，一般连续的字符串，数字，路径等可以用。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>grep搜索的内容，可以输入正则表达式，如果不想输入正则表达式，即不想被解析，可以使用fgerp。</p><p>比如，有文件a，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat a</span><br><span class="line">s</span><br><span class="line">dsa</span><br><span class="line">fasf</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fsaf</span><br><span class="line">fasdasdw</span><br><span class="line">da</span><br></pre></td></tr></table></figure><p>可以用[]来搜索集合字符，其中^表示不</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ grep l[sd] a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">yangzhuo@n224-019-077:~/file$ grep l[^<span class="built_in">cd</span>] a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br></pre></td></tr></table></figure><p>grep l[sd] a表示在a中搜索ls或者ld。</p><p>grep l[^cd] a表示a中搜索除了lc和ld其他。</p><p>正如正则表达式，[1-9][a-z][^A-Z]这些表达也是可以的。</p><h2 id="行首与行尾字符"><a href="#行首与行尾字符" class="headerlink" title="行首与行尾字符 ^ $"></a>行首与行尾字符 ^ $</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ grep ^f a</span><br><span class="line">fasf</span><br><span class="line">fsaf</span><br><span class="line">fasdasdw</span><br><span class="line">yangzhuo@n224-019-077:~/file$ grep w$ a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fasdasdw</span><br><span class="line">yangzhuo@n224-019-077:~/file$</span><br></pre></td></tr></table></figure><p>如上，^表示句首，$表示句尾。同时可以使用正则表达式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ grep ^[^sd] a</span><br><span class="line">fasf</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fsaf</span><br><span class="line">fasdasdw</span><br><span class="line">yangzhuo@n224-019-077:~/file$</span><br></pre></td></tr></table></figure><p>表示不以s或者d开头的</p><h2 id="转义与egrep"><a href="#转义与egrep" class="headerlink" title="转义与egrep"></a>转义与egrep</h2><p>正则表达式中，.表示任意字符，*表示重复前面字符0到无穷次，{a,b}表示重复前面字符a到b次，但是在grep中，输入这种特殊符号需要转义.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ grep w\* a</span><br><span class="line">s</span><br><span class="line">dsa</span><br><span class="line">fasf</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fsaf</span><br><span class="line">fasdasdw</span><br><span class="line">da</span><br></pre></td></tr></table></figure><p>再比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ grep <span class="string">'w\+'</span> a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fasdasdw</span><br><span class="line">yangzhuo@n224-019-077:~/file$ grep <span class="string">'w\&#123;2,\&#125;'</span> a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br></pre></td></tr></table></figure><p>没输一个字符都要转义，未免太麻烦了吧，可以使用egrep。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ egrep <span class="string">'w+'</span> a</span><br><span class="line">wwwwwwwlswwwwwwwwwwww</span><br><span class="line">fasdasdw</span><br></pre></td></tr></table></figure><p>esay~~</p><p>还有fgrep，就是怎么输都是纯文本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;加单引号、双引号和不加引号&quot;&gt;&lt;a href=&quot;#加单引号、双引号和不加引号&quot; class=&quot;headerlink&quot; title=&quot;加单引号、双引号和不加引号&quot;&gt;&lt;/a&gt;加单引号、双引号和不加引号&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单引号：&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>重定向与文件描述符</title>
    <link href="http://yoursite.com/blog/2019/08/26/8-26%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/08/26/8-26技术笔记/</id>
    <published>2019-08-26T02:31:51.000Z</published>
    <updated>2019-08-29T10:29:08.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>标准输出是键盘，标准输出是屏幕，标准错误输出是屏幕。</p><p>但是可以重定向，改变输入和输出的位置。</p><h2 id="简单重定向"><a href="#简单重定向" class="headerlink" title="简单重定向"></a>简单重定向</h2><ul><li>cmd &gt; file</li></ul><p>把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的<a href="http://linux-wiki.cn/index.php?title=Noclobber&amp;action=edit&amp;redlink=1" title="Noclobber（尚未撰写）" target="_blank" rel="noopener">noclobber</a>选项可以防止覆盖原有文件。</p><ul><li>cmd &gt;&gt; file</li></ul><p>把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件后面。</p><ul><li>cmd &lt; file</li></ul><p>使cmd命令从file读入</p><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>Shell 中对文件描述符的操作由三部分组成:  <code>(Left, Operation, Right)</code>:</p><ul><li>Left 可以是 0-9 的数字, 代表第 n 号文件描述符;<ul><li>Left 还可以为  <code>&amp;</code>, 表示同时操作  <code>stdout</code>  和  <code>stderr</code></li></ul></li><li>Right 可以是文件名或 0-9 的数字, 当 Right 是数字时必须要加上  <code>&amp;</code>  符号, 表示引用第 n 号文件描述符;<ul><li>Right 还可以为  <code>&amp;-</code>, 此时表示关闭 Left 描述符, 例如  <code>2&lt;&amp;-</code>  表示关闭 stderr;</li></ul></li><li>Operation 可以为  <code>&lt;</code>  或  <code>&gt;</code>;<ul><li>为  <code>&lt;</code>  时表示以读模式复制 Right 到 Left, 此时如果没有指定 Left 的话, 则为默认值 0;</li><li>当为  <code>&gt;</code>  表示以写模式复制 Right 到 Left, 此时如果没有指定 Left 的话, 则为默认值 1;</li><li>Operation 和 Left 之间不能有空格;</li><li>当 Right 为文件名时, Operation 和 Right 可以有空格, 否则也不能有空格;</li></ul></li></ul><pre><code>可以使用exec命令创建自定义的描述符。</code></pre><p>   创建一个文件a，其内容是hello。实验如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ cat 0&lt;a</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ ls &amp;&gt;a</span><br><span class="line">yangzhuo@n224-019-077:~/file$ cat a</span><br><span class="line">0703老清北线下发货明细 - 填写模板.csv</span><br><span class="line">7-8赠课.csv</span><br><span class="line">a</span><br><span class="line">buyGift.csv</span><br><span class="line">giftSheet.csv</span><br><span class="line">userInfo.csv</span><br><span class="line">换新单号表格.csv</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ ls noexist &amp;&gt;a</span><br><span class="line">yangzhuo@n224-019-077:~/file$ cat a</span><br><span class="line">ls: cannot access <span class="string">'noexist'</span>: No such file or directory</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n224-019-077:~/file$ <span class="built_in">exec</span> 3&lt; a</span><br><span class="line">yangzhuo@n224-019-077:~/file$ cat &lt;&amp;3</span><br><span class="line">ls: cannot access <span class="string">'noexist'</span>: No such file or directory</span><br></pre></td></tr></table></figure><p>如果要再次读取，我们就不能再继续使用文件描述符3了，而是需要用exec重新分配文件描述符3以便用于读取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重定向&quot;&gt;&lt;a href=&quot;#重定向&quot; class=&quot;headerlink&quot; title=&quot;重定向&quot;&gt;&lt;/a&gt;重定向&lt;/h1&gt;&lt;p&gt;标准输出是键盘，标准输出是屏幕，标准错误输出是屏幕。&lt;/p&gt;
&lt;p&gt;但是可以重定向，改变输入和输出的位置。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
</feed>
