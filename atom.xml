<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arvense</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/blog/"/>
  <updated>2020-02-21T08:55:36.354Z</updated>
  <id>http://yoursite.com/blog/</id>
  
  <author>
    <name>Arvense</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>子网掩码作用</title>
    <link href="http://yoursite.com/blog/2020/02/21/2-21%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/21/2-21技术笔记/</id>
    <published>2020-02-21T08:36:26.000Z</published>
    <updated>2020-02-21T08:55:36.354Z</updated>
    
    <content type="html"><![CDATA[<p>1.子网掩码是用来区分广播域的，同一个广播域可以直接互相通信，不需要路由转发。</p><p>2。发送数据报时，知道ip地址是不够的，还需要知道MAC地址，而数据链路层又没有ip地址。这时需要arp协议。</p><p>3.如果在同一个网络内，arp可以直接查到ip地址。如果不在，就必须得arp广播，查询申请。</p><p>所以子网掩码就是用来确定是否在同一个网络（广播域）内，3做策略选择的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.子网掩码是用来区分广播域的，同一个广播域可以直接互相通信，不需要路由转发。&lt;/p&gt;
&lt;p&gt;2。发送数据报时，知道ip地址是不够的，还需要知道MAC地址，而数据链路层又没有ip地址。这时需要arp协议。&lt;/p&gt;
&lt;p&gt;3.如果在同一个网络内，arp可以直接查到ip地址。如
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP粘包/拆包</title>
    <link href="http://yoursite.com/blog/2020/02/20/2-20%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2020/02/20/2-20技术笔记-1/</id>
    <published>2020-02-20T06:27:37.000Z</published>
    <updated>2020-02-20T06:47:35.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="伪概念"><a href="#伪概念" class="headerlink" title="伪概念"></a>伪概念</h1><p>TCP是基于流的协议，所谓流，就是没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。<br>即应用层的请求和传输层是不对应的。</p><p>假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取的字节数是不定的，故可能存在以下四种情况。<br>(1) 服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；<br>(2) 服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；<br>(3) 服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；<br>(4) 服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。</p><h1 id="传输层解决是耍流氓"><a href="#传输层解决是耍流氓" class="headerlink" title="传输层解决是耍流氓"></a>传输层解决是耍流氓</h1><p>比如关闭Nagle算法，接受方立刻从缓冲池里拿数据，都是基于传输层的，是没有意义的。</p><p>因为tcp是基于流的，传输层没有包，包是应用层自己规定的，那么自然应该在应用层再解析出包来。</p><h1 id="应用层分割"><a href="#应用层分割" class="headerlink" title="应用层分割"></a>应用层分割</h1><p>以netty为例，有4种粘包处理器，分别是基于回车，基于指定分割符，定长，基于协议。</p><p>其实也就是发送接收双方约定好应用层“包”的接口，接收方在应用层把流解析成包即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;伪概念&quot;&gt;&lt;a href=&quot;#伪概念&quot; class=&quot;headerlink&quot; title=&quot;伪概念&quot;&gt;&lt;/a&gt;伪概念&lt;/h1&gt;&lt;p&gt;TCP是基于流的协议，所谓流，就是没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>rudp协议</title>
    <link href="http://yoursite.com/blog/2020/02/18/2-18%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2020/02/18/2-18技术笔记-1/</id>
    <published>2020-02-18T08:47:53.000Z</published>
    <updated>2020-02-18T09:21:59.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RUDP保证可靠性的机制"><a href="#RUDP保证可靠性的机制" class="headerlink" title="RUDP保证可靠性的机制"></a>RUDP保证可靠性的机制</h1><p>重传：RUDP的重传方式有三类：<strong>定时重传</strong>、<strong>请求重传</strong>和<strong>FEC选择重传</strong></p><h2 id="定时重传"><a href="#定时重传" class="headerlink" title="定时重传"></a>定时重传</h2><p>发送端如果在发出数据包（T1）时刻一个RTO之后还没有收到这个数据包的ACK消息，那么就会重发该数据包。</p><p>有如下两个问题，一是ack包丢失，二是ack包延迟超过1RTO。</p><p>如果场景是一个对<strong>延迟敏感但对流量成本要求不高</strong>的场景，就可以将<strong>RTO的计算设计比较小</strong>，这样能尽最大可能呢保证你的延迟足够小。如：<strong>实时操作类网游</strong>、<strong>教育领域的书写同步</strong>。如果是<strong>大带宽实时传输</strong>，定时重传对带宽的消耗是很大的，极端情况会用20%的重复重传率，所以在大带宽模式下一般采用<strong>请求重传模式</strong>。</p><h2 id="请求重传"><a href="#请求重传" class="headerlink" title="请求重传"></a>请求重传</h2><p>请求重传就是接收端在发送ACK的时候携带自己丢失报文的信息反馈，发送端接收到ACK信息时根据丢包反馈进行报文重传。</p><p>问题在于如何在网络抖动的乱序下评估丢包：当发现丢包的时候记录一个时刻t1,当t1 + rtt_var（RTT方差值） &lt; curr_t(当前时刻)，我们就认为它丢失了，，这个时候后续的ACK就需要携带这个丢包信息并更新丢包时刻t2,后续持续扫描丢包队列，如果他t2 + RTO &lt;curr_t，再次在ACK携带这个丢包信息，以此类推，直到收到报文为止。</p><p>这种方式是由<strong>丢包请求</strong>引起的重发，如果<strong>网络很不好，</strong>接收端会不断发起重传请求，造成发送端不停的重传，引起<strong>网络风暴</strong>，<strong>通信质量会下降</strong>，所以我们再发送端设置一个拥塞控制模块来限流。</p><p><strong>请求重传</strong>这种方式比<strong>定时重传</strong>方式的延迟会大，一般适合于<strong>带宽较大</strong>的传输场景，如：<strong>视频</strong>、<strong>文件传输</strong>和<strong>数据同步</strong>等。</p><h3 id="FEC选择重传"><a href="#FEC选择重传" class="headerlink" title="FEC选择重传"></a>FEC选择重传</h3><p>除了定时重传和请求重传模式外，还有一种方式就是以<strong>FEC分组</strong>方式<strong>选择重传</strong>，<strong><code>FEC</code></strong>（Forward Error Correction）是一种<strong>前向纠错技术</strong>，一般是通过<strong><code>XOR</code></strong>类似的算法实现，也有<strong>多层的EC算法和raptor涌泉码技术</strong>，其实就是一个<strong>解方程</strong>的过程。</p><p>在<strong>发送方</strong>发送报文时，会根据<strong>FEC方式</strong>把几个<strong>报文</strong>进行<strong>FEC分组</strong>，通过<strong>XOR</strong>的方式得到<strong>若干个冗余包</strong>，然后一起发往接收端，如果<strong>接收端</strong>发现丢包但能通过<strong>FEC分组</strong>算法<strong>还原</strong>，就不向发送端请求重发，如果分组内包是不能进行FEC恢复，则请求发送端发送原始的数据包。</p><p><strong>FEC分组方式</strong>适合要求<strong>延迟敏感</strong>且<strong>随机丢包</strong>的<strong>传输场景</strong>，在一个<strong>带宽不是很充裕</strong>的条件下，FEC会<strong>增加多余的冗余包</strong>，可能会使得<strong>网络更加不好</strong>。FECC方式不仅可以配合请求重传模式，也可以配合定时重传模式。</p><h1 id="窗口与拥塞控制"><a href="#窗口与拥塞控制" class="headerlink" title="窗口与拥塞控制"></a>窗口与拥塞控制</h1><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p>RUDP需要一个收发的滑动窗口系统来配合对应的拥塞算法来做流量控制，有些RUDP需要严格的发送端和接收端的窗口对应，有些RUDP是不要收发窗口严格对应。</p><p>如果涉及到<strong>可靠有序</strong>的RUDP，<strong>接收端</strong>要做<strong>窗口</strong>就要做<strong>排序和缓冲</strong>，如果是<strong>无序可靠</strong>或者<strong>尽力可靠</strong>的场景，<strong>接收端</strong>一般就<strong>不作窗口缓冲</strong>，<strong>只做位置滑动</strong>。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="模仿tcp"><a href="#模仿tcp" class="headerlink" title="模仿tcp"></a>模仿tcp</h3><p><strong>TCP</strong>经典拥塞算法分为四部分：<strong>慢启动</strong>、<strong>拥塞避免</strong>、<strong>拥塞处理</strong>和<strong>快速恢复</strong></p><p>若<strong>RUDP</strong>采用这个算法来做拥塞控制，一般的<strong>场景</strong>是为了保证<strong>有序可靠传输</strong>的同时又兼顾<strong>网络传输的公平性原则</strong>。</p><h3 id="BRR拥塞算法"><a href="#BRR拥塞算法" class="headerlink" title="BRR拥塞算法"></a>BRR拥塞算法</h3><p>对于经典拥塞算法的延迟和带宽压榨问题，google设计了基于发送端延迟和带宽评估的BBR拥塞控制算法。</p><p>这种拥塞算法致力于解决<strong>两个问题</strong>：</p><p>（1）<strong>在一定丢包率网络传输链路上充分利用带宽</strong></p><p>（2）<strong>降低网络传输中的buffer延迟</strong></p><p>BBR的主要策略就是周期性通过ACK和NACK返回来评估链路的min_rtt和max_bandwidth。最大吞吐量（cwnd）的大小是：</p><p><code>cwnd = max_bandwidth / min_rtt</code></p><h2 id="webRTC-gcc"><a href="#webRTC-gcc" class="headerlink" title="webRTC gcc"></a>webRTC gcc</h2><p>音视频传输就必然会想到webRTC系统，在webRTC总对于视频传输也实现了一个拥塞控制算法（gcc），webRTC的gcc是一个基于<strong>发送端丢包率</strong>和<strong>接收端延迟带宽</strong>统计的拥塞控制，而且是一个<strong>尽力可靠</strong>的传输算法。</p><h3 id="弱窗口拥塞控制"><a href="#弱窗口拥塞控制" class="headerlink" title="弱窗口拥塞控制"></a>弱窗口拥塞控制</h3><p>其实在很多场景是<strong>不用拥塞控制</strong>或者只要<strong>很弱的拥塞控制</strong>即可，如：<strong>师生双方书写同步</strong>、<strong>实时游戏</strong>，因为本身的<strong>传输的数据量不大</strong>，只要确保<code>足够小的延迟和可靠性</code><strong>即可，一般是采用</strong>固定窗口大小<strong>来进行流控，我们在系统中一般采用一个</strong><code>cwnd = 32</code><strong>这样的窗口来流控，ACK确认也是通过整个接收窗口反馈给发送方，</strong>简单直接<strong>、也</strong>很容易适应弱网环境。</p><h1 id="传输路径"><a href="#传输路径" class="headerlink" title="传输路径"></a>传输路径</h1><p>RUDP除了优化连接、压榨带宽、适合弱网环境等外，它还继承了UDP天然的动态性，可以在中间应用层链路上做传输优化，一般分为多点串联优化和多点并联优化</p><h2 id="多点串联relay"><a href="#多点串联relay" class="headerlink" title="多点串联relay"></a>多点串联relay</h2><p>在实时通信中一些对业务场景对延迟非常敏感，例如：实时语音、同步书写、实时互动、直播连麦等，如果单纯的服务中转或者P2P通信，很难无法满足其需求，尤其是在物理距离很大的情况下。在解决这个问题上SKYPE率先提出全球RTN（实时多点传输网络），其实就是在通信双方之间通过几个relay节点来动态智能选路，这种传输方式很适合RUDP，我们只要在通信双方构建一个RUDP通道，中间链路只是一个无状态的relay cache集合，relay与relay之间进行路由探测和选路，以此来做到链路的高可用和实时性</p><h2 id="多点并联relay"><a href="#多点并联relay" class="headerlink" title="多点并联relay"></a>多点并联relay</h2><p>在服务与服务进行媒体数据传输或者分发过程中，需要保证传输路径高可用和提高带宽并发，这类使用场景也会使用传输双方构建一个RUDP通道，中间通过多relay节点的并联来解决，这种模型需要在发送端设计一个多点路由表探测机制，以此来判断各个路径同时发送数据的比例和可以用性，这个模型除了链路备份和增大传输并发带宽外，还有个辅助的功能，如果是流媒体分发系统，我们一般会用BGP来做中转，如果节点与节点之间可以直连，这样还可以减少对BGP带宽的占用，以此来减少成本问题。</p><h1 id="RUDP优势"><a href="#RUDP优势" class="headerlink" title="RUDP优势"></a>RUDP优势</h1><h2 id="弱网环境传输问题"><a href="#弱网环境传输问题" class="headerlink" title="弱网环境传输问题"></a>弱网环境传输问题</h2><p>弱网环境如果用TCP通信延迟可能会非常大，这会影响用户体验。</p><p>场景有：<strong>实时的操作类网游通信</strong>、<strong>语音对话</strong>、<strong>多方白板书写</strong>等。</p><h2 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h2><p><strong>避免TCP</strong>的<strong>三次握手和四次挥手</strong>的过程，会采用RUDP来<strong>优化资源</strong>的<strong>占用率</strong>和<strong>响应时间</strong>，提高系统的<strong>并发能力</strong>，如：QUIC。</p><h2 id="端对端连通性问题"><a href="#端对端连通性问题" class="headerlink" title="端对端连通性问题"></a>端对端连通性问题</h2><p>一般终端直接和终端通信都涉及NAT穿越，TCP在<code>NAT</code>穿越实现非常困难，相对来说UDP穿越NAT却简单很多，如果是<strong>端到端的可靠通信</strong>一般用<strong><code>RUDP</code></strong>方式解决。</p><p>场景有：<strong>端到端的文件传输</strong>、<strong>音视频传输</strong>、<strong>交互指令传输</strong>等等。</p><h2 id="传输路径优化问题"><a href="#传输路径优化问题" class="headerlink" title="传输路径优化问题"></a>传输路径优化问题</h2><p>在一些对<strong>延时要求很高</strong>的场景下，会用<strong>应用层</strong><code>relay</code>的方式来做<strong>传输路由优化</strong>，也就是动态智能选路，这时双方采用RUDP方式来传输，中间的延迟进行relay选路优化延时。还有一类基于<strong>传输吞吐量</strong>的场景，例如：<strong>服务与服务之间数据分发</strong>、<strong>数据备份</strong>等，这类场景一般会采用<strong><code>多点并联relay</code></strong>来<strong>提高传输的速度</strong>，也是要建立在RUDP上的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RUDP保证可靠性的机制&quot;&gt;&lt;a href=&quot;#RUDP保证可靠性的机制&quot; class=&quot;headerlink&quot; title=&quot;RUDP保证可靠性的机制&quot;&gt;&lt;/a&gt;RUDP保证可靠性的机制&lt;/h1&gt;&lt;p&gt;重传：RUDP的重传方式有三类：&lt;strong&gt;定时重传&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>同步I/O</title>
    <link href="http://yoursite.com/blog/2020/02/16/2-16%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/16/2-16技术笔记/</id>
    <published>2020-02-16T09:19:52.000Z</published>
    <updated>2020-02-19T08:20:40.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>在调用函数write()时，似乎该函数一旦返回，数据便已经写到了文件中.</p><p>但显然，写磁盘速度很慢，如果加个内存缓冲区，只写入缓冲区，后续再把缓冲区写入磁盘，可以低速的输入输出设备长时间占用CPU，提高效率。</p><h2 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h2><p>当调用write()函数写出数据时，数据一旦写到该缓冲区（关键：只是写到缓冲区），函数便立即返回.此时写出的数据可以用read()读回，也可以被其他进程读到，但是并不意味着它们已经被写到了外部永久存储介质上，即使调用close()关闭文件后也可能如此. 因为缓冲区的数据可能还在等待输出.<br>因此，从数据被实际写到磁盘的角度来看，用write()写出的文件数据与外部存储设备并不是完全同步的.不同步的时间间隔非常短，一般只有几秒或十几秒，具体取决于写出的数据量和I/O数据缓冲区的状态.尽管不同步的时间间隔很短，但是如果在此期间发生掉电或者系统崩溃，则会导致所写数据来不及写至磁盘而丢失的情况.</p><h2 id="sync函数"><a href="#sync函数" class="headerlink" title="sync函数"></a>sync函数</h2><p>sync负责将系统缓冲区的数据“写入”磁盘，以确保数据的一致性和同步性.注意：sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，他并不等待实际I/O操作结束.所以不要认为调用了sync函数，就觉得数据已安全的送到磁盘文件上，有可能会出现问题，但是sync函数是无法得知的.<br>系统守候进程一般每隔一段时间调用一次sync函数，确保定期刷新内核的块缓存.UNIX系统中，系统守候进程update会周期性地（一般每个30秒）调用sync函数.命令sync(1)也调用sync函数.</p><h2 id="fsync函数"><a href="#fsync函数" class="headerlink" title="fsync函数"></a>fsync函数</h2><p>与sync函数不同，fsync函数只对由文件描符filedes指定的单一文件起作用，强制与描述字fildes相连文件的所有修改过的数据（包括核内I/O缓冲区中的数据）传送到外部永久介质，即刷新fildes给出的文件的所有信息，并且等待写磁盘操作结束，然后返回.调用 fsync()的进程将阻塞直到设备报告传送已经完成.这个fsync就安全点了.<br>一个程序在写出数据之后，如果继续进行后续处理之前要求确保所写数据已写到磁盘，则应当调用fsync().例如，数据库应用通常会在调用write()保存关键交易数据的同时也调用fsync().这样更能保证数据的安全可靠.</p><h2 id="fdatasync函数"><a href="#fdatasync函数" class="headerlink" title="fdatasync函数"></a>fdatasync函数</h2><p>fdatasync函数类似于fsync函数，但它只影响文件数据部分，强制传送用户已写出的数据至物理存储设备，不包括文件本身的特征数据.这样可以适当减少文件刷新时的数据传送量.而除数据外，fdatasync还会同步更新文件的属性.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓冲区&quot;&gt;&lt;a href=&quot;#缓冲区&quot; class=&quot;headerlink&quot; title=&quot;缓冲区&quot;&gt;&lt;/a&gt;缓冲区&lt;/h2&gt;&lt;p&gt;在调用函数write()时，似乎该函数一旦返回，数据便已经写到了文件中.&lt;/p&gt;
&lt;p&gt;但显然，写磁盘速度很慢，如果加个内存缓冲区，
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>内存碎片与内存整理</title>
    <link href="http://yoursite.com/blog/2020/02/13/2-13%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2020/02/13/2-13技术笔记-1/</id>
    <published>2020-02-13T09:57:03.000Z</published>
    <updated>2020-02-13T10:39:01.321Z</updated>
    
    <content type="html"><![CDATA[<p>内存碎片分为两种，内部碎片和外部碎片。可以简单认为，内部碎片是分页导致的，外部碎片是分段导致的。</p><h1 id="slub"><a href="#slub" class="headerlink" title="slub"></a>slub</h1><p>linux kernel 通过把整个物理内存划分成以一个个page进行管理，管理器就是伙伴系统，它的最小分配单元就是page。但是对于小于page的内存分配，如果直接分配一个page，是一个很大的浪费。linux kernel 通过slab来实现对小于page大小的内存分配。slab把page按2的m次幂进行划分一个个字节块，当kmalloc申请内存时，通过slab管理器返回需要满足申请大小的最小空闲内存块。</p><p>解决了内部碎片的问题。</p><p>slab是Linux操作系统的一种内存分配机制。其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内存碎片，而且处理速度也太慢。<br>而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免这些内碎片。slab分配器并不丢弃已分配的对象，而是释放并把它们保存在内存中。当以后又要请求新的对象时，就可以从内存直接获取而不用重复初始化。</p><h1 id="buddy"><a href="#buddy" class="headerlink" title="buddy"></a>buddy</h1><p>Linux采用著名的伙伴系统(buddy system)算法来解决外碎片问题。把所有的空闲页框分组为11个块链表，每个链表分别包含大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框，对1024个页框的最大请求对应着4MB大小的连续RAM（每页大小为4KB），每个块的第一个页框的物理地址是该块大小的整数倍，例如，大小为16个页框的块，其起始地址是16*2^12的倍数。</p><p>假设现在要请求一个256个页框的块（1MB），算法步骤如下：<br>• 在256个页框的链表中检查是否有一个空闲快，如果没有，查找下一个更大的块，如果有，请求满足。<br>• 在512个页框的链表中检查是否有一个空闲块，如果有，把512个页框的空闲块分为两份，第一份用于满足请求，第二份链接到256个页框的链表中。如果没有空闲块，继续寻找下一个更大的块。<br>以上过程的逆过程，就是页框块的释放过程，也是该算法名字的由来，内核试图把大小为B的一对空闲伙伴块合并为一个2B的单独块，满足以下条件的两个块称之为伙伴：<br>• 两个块具有相同的大小<br>• 他们的物理地址是连续的<br>第一块的第一个页框的物理地址是2 <em> B </em> 2^12<br>该算法是递归的，如果它成功合并了B，就会试图去合并2B，以再次试图形成更大的块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内存碎片分为两种，内部碎片和外部碎片。可以简单认为，内部碎片是分页导致的，外部碎片是分段导致的。&lt;/p&gt;
&lt;h1 id=&quot;slub&quot;&gt;&lt;a href=&quot;#slub&quot; class=&quot;headerlink&quot; title=&quot;slub&quot;&gt;&lt;/a&gt;slub&lt;/h1&gt;&lt;p&gt;linux 
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>VIRT(虚拟内存)，RES(常驻内存)，SHR(共享内存)</title>
    <link href="http://yoursite.com/blog/2020/02/12/2-12%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-2/"/>
    <id>http://yoursite.com/blog/2020/02/12/2-12技术笔记-2/</id>
    <published>2020-02-12T13:31:56.000Z</published>
    <updated>2020-02-13T09:57:14.274Z</updated>
    
    <content type="html"><![CDATA[<p>可以通过top命令查看进程占用了多少内存。这里可以看到VIRT、RES和SHR三个重要的指标。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据，以及malloc、new分配的堆空间和分配的栈空间等；</p><p>2、假如进程新申请10MB的内存，但实际只使用了1MB，那么它会增长10MB，而不是实际的1MB使用量。</p><h2 id="常驻内存"><a href="#常驻内存" class="headerlink" title="常驻内存"></a>常驻内存</h2><p>驻留内存，顾名思义是指那些被映射到进程虚拟内存空间的物理内存。</p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>进程在运行过程中，会加载许多操作系统的动态库，比如 libc.so、libld.so等。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可以通过top命令查看进程占用了多少内存。这里可以看到VIRT、RES和SHR三个重要的指标。&lt;/p&gt;
&lt;h2 id=&quot;虚拟内存&quot;&gt;&lt;a href=&quot;#虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存&quot;&gt;&lt;/a&gt;虚拟内存&lt;/h2&gt;&lt;p&gt;1、进程“需要
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://yoursite.com/blog/2020/02/11/2-11%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/11/2-11技术笔记/</id>
    <published>2020-02-11T03:43:04.000Z</published>
    <updated>2020-02-11T09:23:15.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分段和分页"><a href="#分段和分页" class="headerlink" title="分段和分页"></a>分段和分页</h1><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等，称为帧。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p><p>这样每个页和每个帧存在一个映射关系。即页表。</p><p>每次要取地址，把地址前几位解析出，即页号，后几位即页内偏移。在页表中把页号转换成帧号（找不到即缺页中断），然后加上页内偏移，即物理地址。</p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>将用户程序地址空间分成若干个<strong>大小不等</strong>的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</p><p>作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例程序段、数据段等。每个段都从0开始编址，并采用一段连续的地址空间。</p><p>段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间是二维的。</p><p>显然也有个段表。要取地址，需要两个信息，第几段和段内偏移，然后段表解析出物理地址。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>分页是强行物理划分的，分段是逻辑划分。</p><p>页大小固定，段大小按需求。</p><p>分页的作业地址空间是一维的.分段的地址空间是二维的。实际上分页也是二维的，两个维度放在了一个数高位和地位而已。</p><h1 id="物理地址、虚拟地址（线性地址）、逻辑地址"><a href="#物理地址、虚拟地址（线性地址）、逻辑地址" class="headerlink" title="物理地址、虚拟地址（线性地址）、逻辑地址"></a>物理地址、虚拟地址（线性地址）、逻辑地址</h1><p>现代计算机，其实结合了分段和分页，即段内分页。具体内存寻址</p><p>首先，肯定是给一个段号+段内偏移，即<strong>逻辑地址</strong></p><p>然后段表把段号哈希出来，解读到它的<strong>虚拟地址</strong>，即<strong>线性地址</strong></p><p>在接下来，页表，把虚拟地址，解析出<strong>物理地址</strong></p><p>CPU要<strong>利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址，再利用其页式内存管理单元，转换为最终物理地址</strong>。这样做两次转换，的确是非常麻烦而且没有必要的，因为直接可以把线性地址抽像给进程。之所以这样冗余，Intel完全是为了向前兼容而已。</p><h1 id="大内存分页"><a href="#大内存分页" class="headerlink" title="大内存分页"></a>大内存分页</h1><h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a><strong>TLB</strong></h2><p>页表是储存在内存中的，每次查询都要查内存未免太慢，可以在寄存器中缓存一份最常使用的，即TLB（<strong>页表寄存器缓冲</strong>）。</p><p>TLB是有限的，这点毫无疑问。当超出TLB的存储极限时，就会发生 TLB miss，之后，OS就会命令CPU去访问内存上的页表。如果频繁的出现TLB miss，程序的性能会下降地很快。</p><p>为了让TLB可以存储更多的页地址映射关系，我们的做法是调大内存分页大小。</p><p>如果一个页4M，对比一个页4K，前者可以让TLB多存储1000个页地址映射关系，性能的提升是比较可观的。</p><h1 id="缺页中断和置换算法"><a href="#缺页中断和置换算法" class="headerlink" title="缺页中断和置换算法"></a>缺页中断和置换算法</h1><p>在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。 </p><p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：<br>　　1. 保护CPU现场<br>　　2. 分析中断原因<br>　　3. 转入缺页中断处理程序进行处理<br>　　4. 恢复CPU现场，继续执行<br>但是缺页中断时由于所要访问的页面不存在与内存时，有硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：<br>　　 1. 在指令执行期间产生和处理缺页中断信号<br>　　 2. 一条指令在执行期间，可能产生多次缺页中断<br>　　 3. 缺页中断返回时，执行产生中断的那一条指令，而一般的中断返回时，执行下一条指令</p><p>于是问题来了，页表一直是满的，把哪一页换出？</p><p>理论上来说，置换以后不再被访问，或者在将来最迟才回被访问的页面，缺页中断率最低。这就是最优解，即 最佳置换（Optimal， OPT)，但实际上未来不止，该算法不可实现。</p><p>如果我们洞悉过去，即可预测未来。置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。   最近最久未使用置换算法（ Least Recently Used， LRU）普偏地适用于各种类型的程序，但是系统要时时刻刻对各页的访问历史情况加以记录和更新，开销太大，因此LRU算法必须要有硬件的支持。</p><p>当然最简单的是先进先出。（First In First Out, FIFO)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分段和分页&quot;&gt;&lt;a href=&quot;#分段和分页&quot; class=&quot;headerlink&quot; title=&quot;分段和分页&quot;&gt;&lt;/a&gt;分段和分页&lt;/h1&gt;&lt;h2 id=&quot;分页&quot;&gt;&lt;a href=&quot;#分页&quot; class=&quot;headerlink&quot; title=&quot;分页&quot;&gt;&lt;/a&gt;分
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>free 命令,系统内存的使用情况</title>
    <link href="http://yoursite.com/blog/2020/02/10/2-10%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/10/2-10技术笔记/</id>
    <published>2020-02-10T09:07:52.000Z</published>
    <updated>2020-02-10T09:29:45.445Z</updated>
    
    <content type="html"><![CDATA[<p>free 命令显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yangzhuo@n227-011-128:~$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            15G        1.6G        1.4G        161M         12G         13G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">yangzhuo@n227-011-128:~$</span><br></pre></td></tr></table></figure><h1 id="buff-cache"><a href="#buff-cache" class="headerlink" title="buff/cache"></a>buff/cache</h1><p>buffer是缓冲，cache是缓存。</p><p><strong>Buffer</strong>（缓冲区）是系统两端处理<strong>速度平衡</strong>（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到<strong>流量整形</strong>的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。<em>相当于buffer是两端的中间层，解决双端速度不一致问题。</em></p><p><strong>Cache</strong>（缓存）则是系统两端处理<strong>速度不匹配</strong>时的一种<strong>折衷策略</strong>。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。<em>cache就是传统意义上的缓存</em></p><p>无论是缓冲区还是页高速缓存，它们的实现方式都是一样的。缓冲区只不过是一种概念上比较特殊的页高速缓存罢了。<br>那么为什么 free 命令不直接称为 cache 而非要写成 buff/cache？ 这是因为缓冲区和页高速缓存的实现并非天生就是统一的。在 linux 内核 2.4 中才将它们统一。更早的内核中有两个独立的磁盘缓存：页高速缓存和缓冲区高速缓存。前者缓存页面，后者缓存缓冲区。</p><h1 id="free-与-available"><a href="#free-与-available" class="headerlink" title="free 与 available"></a>free 与 available</h1><p>free 是真正尚未被使用的物理内存数量。至于 available 就比较有意思了，它是从应用程序的角度看到的可用内存数量。Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache。所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，<strong>available = free + buffer + cache</strong>。</p><h1 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h1><p>swap space 是磁盘上的一块区域，可以是一个分区，也可以是一个文件。所以具体的实现可以是 swap 分区也可以是 swap 文件。当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。</p><p>实际上，现在已经没那么缺内存了，可以不用这个，有个参数/etc/sysctl.conf 文件中设置 swappiness，意思是交换的紧迫程度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;free 命令显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linux" scheme="http://yoursite.com/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>僵尸进程</title>
    <link href="http://yoursite.com/blog/2020/02/08/2-8%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/08/2-8技术笔记/</id>
    <published>2020-02-08T06:49:25.000Z</published>
    <updated>2020-02-08T07:03:10.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产生方法"><a href="#产生方法" class="headerlink" title="产生方法"></a>产生方法</h2><pre><code>当一个父进程以fork()系统调用建立一个新的子进程后，核心进程就会在进程表中给这个子进程分配一个进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。当这个子进程结束的时候（比如调用exit命令结束），其实他并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit的作用是使进程退出，但是也仅仅限于一个正常的进程变成了一个僵尸进程，并不能完全将其销毁）。此时原来进程表中的数据会被该进程的退出码（exit code）、执行时所用的CPU时间等数据所取代，这些数据会一直保留到系统将它传递给它的父进程为止。由此可见，defunct进程的出现时间是在子进程终止后，但是父进程尚未读取这些数据之前。</code></pre><p>如果子进程先于父进程退出， 同时父进程又没有调用wait/waitpid，则该子进程将成为僵尸进程。通过ps命令，我们可以看到该进程的状态为Z(表示僵死)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> child = fork();</span><br><span class="line"><span class="keyword">if</span>(child == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nIm in child process:"</span> &lt;&lt;  getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nIm in parent process."</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   sleep(<span class="number">600</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理僵尸进程"><a href="#处理僵尸进程" class="headerlink" title="处理僵尸进程"></a>处理僵尸进程</h2><p>kill命令无法杀死僵尸进程。要么重启服务器。要么杀死其父进程。</p><p>ps -ef | grep defunct_process_pid</p><h2 id="避免产生僵尸进程"><a href="#避免产生僵尸进程" class="headerlink" title="避免产生僵尸进程"></a>避免产生僵尸进程</h2><p>   1.在父进程创建子进程之前，就向系统申明自己并不会对这个子进程的exit动作进行任何关注行为，这样的话，子进程一旦退出后，系统就不会去等待父进程的操作，而是直接将该子进程的资源回收掉，也就不会出现僵尸进程了。具体的办法就是，在父进程的初始化函数中，调用这个函数：signal(SIGCHLD,SIG_IGN)；</p><ol start="2"><li>如果父进程不忙，可以等待子进程，那么可以在创建完子进程后，用waitpid等待子进程返回。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;产生方法&quot;&gt;&lt;a href=&quot;#产生方法&quot; class=&quot;headerlink&quot; title=&quot;产生方法&quot;&gt;&lt;/a&gt;产生方法&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;当一个父进程以fork()系统调用建立一个新的子进程后，核心进程就会在进程表中给这个子进程分配一个进入点，然
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>静态链接/动态链接库的区别</title>
    <link href="http://yoursite.com/blog/2020/02/07/2-7%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/07/2-7技术笔记/</id>
    <published>2020-02-07T11:23:15.000Z</published>
    <updated>2020-02-08T01:30:51.662Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdn.net/20151113153003874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><h2 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h2><p>　　什么是静态链接呢？即在链接阶段，将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件。该可执行文件可能会比较大。</p><p>这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行。</p><p>缺点是：文件太大，一个全静态方式生成的简单print文件都有857K。而动态链接生成的一样的可执行文件却只要8.４Ｋ。</p><h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><p>静态链接库的最大问题不是文件大，而是占内存，因为多个程序可能引用同一个静态链接库，导致它们在内存中存在多份拷贝。</p><p>动态链接是相对静态链接而言的，动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的DLL之间建立链接关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，Windows才转去执行DLL中相应的函数代码。一般情况下，如果一个应用程序使用了动态链接库，Win32系统保证内存中只有DLL的一份复制品。</p><p>动态链接库缺点是需要目标运行的环境中，也有该dll。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20151113153003874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQ
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>原子操作原理</title>
    <link href="http://yoursite.com/blog/2020/02/06/2-6%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/06/2-6技术笔记/</id>
    <published>2020-02-06T07:55:58.000Z</published>
    <updated>2020-02-06T09:35:27.789Z</updated>
    
    <content type="html"><![CDATA[<p>原子操作是什么略过。</p><p>目前实现方式有两种，总线锁和缓存锁。前者其实已被淘汰</p><h2 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h2><p>假设多个处理器同时处理一个共享变量，如果没有锁机制，就会出现同一个共享变量同一时刻被多个处理器同时处理的情况，就会造成结果的不一致性，例如i=1，我们要进行2次i++，就会出现i=2和i=3两种结果情况。很明显这不是我们要的结果，所以要想保证读写共享变量的操作是原子性的，就必须保证当处理器1在操作共享变量时，处理器2不能操作缓存了该共享变量内存地址的缓存。</p><p>因此引出了总线锁，<strong>总线锁</strong>就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就能独占共享内存；</p><p>可以想象为：公司有一个会议室（共享内存），各个部门（处理器）开会都在会议室进行，当有一个部门占用会议室时，就会在会议室门口或者公司群里通知会议室此时被占用，那么其他部门的会议就得先等着（阻塞），等该部门结束会议才能开始下一个会议。</p><p><strong>总线锁的缺点</strong>：总线锁把CPU和内存之间的通信锁住了，在锁期间，其他处理器不能操作其他内存地址的数据，开销比较大。    </p><h2 id="缓存锁"><a href="#缓存锁" class="headerlink" title="缓存锁"></a>缓存锁</h2><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>缓存一致性机制就整体来说，是当某块CPU对缓存中的数据进行操作了之后，就通知其他CPU放弃储存在它们内部的缓存，或者从主内存中重新读取。</p><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>是以缓存行(缓存的基本数据单位，在Intel的CPU上一般是64字节)的几个状态来命名的(全名是Modified、Exclusive、 Share or Invalid)。该协议要求在每个缓存行上维护两个状态位，使得每个数据单位可能处于M、E、S和I这四种状态之一，各种状态含义如下：</p><pre><code>M：被修改的。处于这一状态的数据，只在本CPU中有缓存数据，而其他CPU中没有。同时其状态相对于内存中的值来说，是已经被修改的，且没有更新到内存中。 E：独占的。处于这一状态的数据，只有在本CPU中有缓存，且其数据没有修改，即与内存中一致。 S：共享的。处于这一状态的数据在多个CPU中都有缓存，且与内存一致。 I：无效的。本CPU中的这份缓存已经无效。</code></pre><p> 一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU。<br>        一个处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I。<br>        一个处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S。</p><pre><code>当CPU需要读取数据时，如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他CPU的监听结果，如其他CPU也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取。 当CPU需要写数据时，只有在其缓存行是M或者E的时候才能执行，否则需要发出特殊的RFO指令(Read Or Ownership，这是一种总线事务)，通知其他CPU置缓存无效(I)，这种情况下性能开销是相对较大的。在写入完成后，修改其缓存状态为M。 所以如果一个变量在某段时间只被一个线程频繁地修改，则使用其内部缓存就完全可以办到，不涉及到总线事务，如果缓存一会被这个CPU独占、一会被那个CPU 独占，这时才会不断产生RFO指令影响到并发性能。这里说的缓存频繁被独占并不是指线程越多越容易触发，而是这里的CPU协调机制，这有点类似于有时多线程并不一定提高效率，原因是线程挂起、调度的开销比执行任务的开销还要大，这里的多CPU也是一样，如果在CPU间调度不合理，也会形成RFO指令的开销比任务开销还要大。当然，这不是编程者需要考虑的事，操作系统会有相应的内存地址的相关判断</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原子操作是什么略过。&lt;/p&gt;
&lt;p&gt;目前实现方式有两种，总线锁和缓存锁。前者其实已被淘汰&lt;/p&gt;
&lt;h2 id=&quot;总线锁&quot;&gt;&lt;a href=&quot;#总线锁&quot; class=&quot;headerlink&quot; title=&quot;总线锁&quot;&gt;&lt;/a&gt;总线锁&lt;/h2&gt;&lt;p&gt;假设多个处理器同时处理一个共
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>线程同步方法</title>
    <link href="http://yoursite.com/blog/2020/02/05/2-5%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/05/2-5技术笔记/</id>
    <published>2020-02-05T02:45:49.000Z</published>
    <updated>2020-02-05T11:57:04.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>即最简单的锁机制，这样多线程只会同时有一个执行关键代码。</p><p>显然锁操作有四种，申请锁，上锁，解锁，销毁锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;  </span><br><span class="line"><span class="keyword">int</span> tmp;  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread</span><span class="params">(<span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"thread id is "</span> &lt;&lt; pthread_self() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    pthread_mutex_lock(&amp;mutex);  </span><br><span class="line">    tmp = <span class="number">12</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Now a is "</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> id;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main thread id is "</span> &lt;&lt; pthread_self() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    tmp = <span class="number">3</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"In main func tmp = "</span> &lt;&lt; tmp &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">if</span> (!pthread_create(&amp;id, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>))  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Create thread success!"</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Create thread failed!"</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pthread_join(id, <span class="literal">NULL</span>);  </span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p># </p><h1 id="条件变量-cond"><a href="#条件变量-cond" class="headerlink" title="条件变量(cond)"></a>条件变量(cond)</h1><p>条件变量是利用线程间共享全局变量进行同步的一种机制。条件变量上的基本操作有：触发条件(当条件变为 true 时)；等待条件，挂起线程直到其他线程触发条件。</p><p>有四个操作，初始化，等待，激活，销毁。</p><p>比如：Jack开着一辆出租车来到一个站点停车，看见没人就走了。过段时间，Susan来到站点准备乘车，但是车没有来，于是就等着。过了一会Mike开着车来到了这个站点，Sunsan就上了Mike的车走了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">pthread_cond_t</span> taxicond = PTHREAD_COND_INITIALIZER;  </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> taximutex = PTHREAD_MUTEX_INITIALIZER;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">traveler_arrive</span><span class="params">(<span class="keyword">void</span> *name)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)name;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Travelr: %s need a taxi now!\n"</span>, p);  </span><br><span class="line">    <span class="comment">// 加锁，把信号量加入队列，释放信号量</span></span><br><span class="line">    pthread_mutex_lock(&amp;taximutex);  </span><br><span class="line">    pthread_cond_wait(&amp;taxicond, &amp;taximutex);  </span><br><span class="line">    pthread_mutex_unlock(&amp;taximutex);  </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"traveler: %s now got a taxi!\n"</span>, p);  </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">taxi_arrive</span><span class="params">(<span class="keyword">void</span> *name)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)name;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Taxi: %s arrives.\n"</span>, p);</span><br><span class="line">    <span class="comment">// 给线程或者条件发信号，一定要在改变条件状态后再给线程发信号</span></span><br><span class="line">    pthread_cond_signal(&amp;taxicond);  </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> *name;  </span><br><span class="line">    <span class="keyword">pthread_t</span> thread;  </span><br><span class="line">    <span class="keyword">pthread_attr_t</span> threadattr; <span class="comment">// 线程属性 </span></span><br><span class="line">    pthread_attr_init(&amp;threadattr);  <span class="comment">// 线程属性初始化</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建三个线程</span></span><br><span class="line">    name = <span class="string">"Jack"</span>;  </span><br><span class="line">    pthread_create(&amp;thread, &amp;threadattr, taxi_arrive, (<span class="keyword">void</span> *)name);  </span><br><span class="line">    sleep(<span class="number">1</span>);  </span><br><span class="line">    name = <span class="string">"Susan"</span>;  </span><br><span class="line">    pthread_create(&amp;thread, &amp;threadattr, traveler_arrive, (<span class="keyword">void</span> *)name);  </span><br><span class="line">    sleep(<span class="number">1</span>);  </span><br><span class="line">    name = <span class="string">"Mike"</span>;  </span><br><span class="line">    pthread_create(&amp;thread, &amp;threadattr, taxi_arrive, (<span class="keyword">void</span> *)name);  </span><br><span class="line">    sleep(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥量的解锁和在条件变量上挂起都是自动进行的。因此，在条件变量被触发前，如果所有的线程都要对互斥量加锁，这种机制可保证在线程加锁互斥量和进入等待条件变量期间，条件变量不被触发。条件变量要和互斥量相联结，以避免出现条件竞争——个线程预备等待一个条件变量，当它在真正进入等待之前，另一个线程恰好触发了该条件（条件满足信号有可能在测试条件和调用pthread_cond_wait函数（block）之间被发出，从而造成无限制的等待）。</p><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p>读写锁是互斥锁更高级的形式，读写锁可以有3种状态：<strong>读模式下加锁状态、写模式加锁状态、不加锁状态</strong>。</p><p>  <strong>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁（允许多个线程读但只允许一个线程写）</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个使用读写锁来实现 4 个线程读写一段数据是实例。</span></span><br><span class="line"><span class="comment">// 在此示例程序中，共创建了 4 个线程，</span></span><br><span class="line"><span class="comment">// 其中两个线程用来写入数据，两个线程用来读取数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock; <span class="comment">//读写锁  </span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//读操作，其他线程允许读操作，却不允许写操作  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun1</span><span class="params">(<span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read num first == %d\n"</span>, num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//读操作，其他线程允许读操作，却不允许写操作  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read num second == %d\n"</span>, num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//写操作，其它线程都不允许读或写操作  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun3</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write thread first\n"</span>);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//写操作，其它线程都不允许读或写操作  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun4</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);  </span><br><span class="line">        num++;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write thread second\n"</span>);  </span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);  </span><br><span class="line">        sleep(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> ptd1, ptd2, ptd3, ptd4;  </span><br><span class="line">      </span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);<span class="comment">//初始化一个读写锁  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//创建线程  </span></span><br><span class="line">    pthread_create(&amp;ptd1, <span class="literal">NULL</span>, fun1, <span class="literal">NULL</span>);  </span><br><span class="line">    pthread_create(&amp;ptd2, <span class="literal">NULL</span>, fun2, <span class="literal">NULL</span>);  </span><br><span class="line">    pthread_create(&amp;ptd3, <span class="literal">NULL</span>, fun3, <span class="literal">NULL</span>);  </span><br><span class="line">    pthread_create(&amp;ptd4, <span class="literal">NULL</span>, fun4, <span class="literal">NULL</span>);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//等待线程结束，回收其资源  </span></span><br><span class="line">    pthread_join(ptd1, <span class="literal">NULL</span>);  </span><br><span class="line">    pthread_join(ptd2, <span class="literal">NULL</span>);  </span><br><span class="line">    pthread_join(ptd3, <span class="literal">NULL</span>);  </span><br><span class="line">    pthread_join(ptd4, <span class="literal">NULL</span>);  </span><br><span class="line">      </span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);<span class="comment">//销毁读写锁  </span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>线程也可以用信号量，轻量版本的。和进程类似，pv操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;互斥锁&quot;&gt;&lt;a href=&quot;#互斥锁&quot; class=&quot;headerlink&quot; title=&quot;互斥锁&quot;&gt;&lt;/a&gt;互斥锁&lt;/h1&gt;&lt;p&gt;即最简单的锁机制，这样多线程只会同时有一个执行关键代码。&lt;/p&gt;
&lt;p&gt;显然锁操作有四种，申请锁，上锁，解锁，销毁锁。&lt;/p&gt;
&lt;f
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程调度算法</title>
    <link href="http://yoursite.com/blog/2020/02/04/2-4%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/04/2-4技术笔记/</id>
    <published>2020-02-04T09:14:24.000Z</published>
    <updated>2020-02-05T03:02:18.785Z</updated>
    
    <content type="html"><![CDATA[<p>cpu调度算法有六种，我觉得可以分为两类，四种基础思路，两种复杂的真正使用的。</p><ol><li><p>先到先得，很简单，但不现实，长作业到了，一直持有cpu，其他的傻眼了。</p></li><li><p>按优先级，这个也可以细分为抢占式和非抢占式，就是说有更高优先级的来了，立刻执行还是等当先任务结束。</p></li><li><p>短作业优先，一直有短作业插入，长作业无限等。</p></li><li><p>时间片轮转，把所有就绪的进程按先进先出的原则排成队列，进程以时间片q位单位轮流使用CPU，进程循环轮转使用CPU。缺点在于时间片长短难以确定，如果q太大,则交互性差，设置退化位FCFS调度方法；如果q太小，进程切换频繁，系统开销增加。</p></li><li><p>响应比优先，这样兼顾了等得久的先执行，时间短的先执行。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。</p></li><li><p>多级反馈队列调度算法：将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cpu调度算法有六种，我觉得可以分为两类，四种基础思路，两种复杂的真正使用的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先到先得，很简单，但不现实，长作业到了，一直持有cpu，其他的傻眼了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按优先级，这个也可以细分为抢占式和非抢占式，就是说有更高
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信的方式</title>
    <link href="http://yoursite.com/blog/2020/02/03/2-3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2020/02/03/2-3技术笔记/</id>
    <published>2020-02-03T02:12:03.000Z</published>
    <updated>2020-02-03T08:47:22.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、管道"><a href="#一、管道" class="headerlink" title="一、管道"></a>一、管道</h1><p>管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。</p><h3 id="1、特点："><a href="#1、特点：" class="headerlink" title="1、特点："></a>1、特点：</h3><ol><li><p>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</p></li><li><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</p></li><li><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p></li></ol><h3 id="2、原型："><a href="#2、原型：" class="headerlink" title="2、原型："></a>2、原型：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>; <span class="comment">// 返回值：若成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。要关闭管道只需将这两个文件描述符关闭即可。</p><h3 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h3><p>单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。</p><p>下面代码pipe则创建了管道。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> pipe_default[<span class="number">2</span>];  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//申请管道</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_default) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to create pipe!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//申请子进程</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (pid = fork()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//操作管道读写端，子进程读数据</span></span><br><span class="line">        close(pipe_default[<span class="number">1</span>]);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span>(read(pipe_default[<span class="number">0</span>], buffer, <span class="number">32</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Receive data from server, %s!\n"</span>, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_default[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//操作管道读写端，父进程写数据</span></span><br><span class="line">        close(pipe_default[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> != write(pipe_default[<span class="number">1</span>], <span class="string">"hello"</span>, <span class="built_in">strlen</span>(<span class="string">"hello"</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Send data to client, hello!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_default[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//等待子进程</span></span><br><span class="line">        waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、FIFO"><a href="#二、FIFO" class="headerlink" title="二、FIFO"></a>二、FIFO</h2><p>FIFO，也称为命名管道，它是一种文件类型。</p><h3 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li><p>FIFO可以在无关的进程之间交换数据，与无名管道不同。</p></li><li><p>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p></li></ol><h3 id="2、原型"><a href="#2、原型" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，出错返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>其中的 mode 参数与open函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。</p><p>当 open 一个FIFO时，是否设置非阻塞标志（O_NONBLOCK）的区别：</p><ul><li><p>若没有指定O_NONBLOCK（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。</p></li><li><p>若指定了O_NONBLOCK，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。</p></li></ul><h3 id="3、例子-1"><a href="#3、例子-1" class="headerlink" title="3、例子"></a>3、例子</h3><p>FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。</p><p>读写双端代码如下。</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;   // exit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;    // O_WRONLY</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;     // time</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">time_t</span> tp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am %d process.\n"</span>, getpid()); <span class="comment">// 说明进程ID</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_WRONLY)) &lt; <span class="number">0</span>) <span class="comment">// 以写打开一个FIFO </span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        time(&amp;tp);  <span class="comment">// 取系统当前时间</span></span><br><span class="line">        n=<span class="built_in">sprintf</span>(buf,<span class="string">"Process %d's time is %s"</span>,getpid(),ctime(&amp;tp));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Send message: %s"</span>, buf); <span class="comment">// 打印</span></span><br><span class="line">        <span class="keyword">if</span>(write(fd, buf, n+<span class="number">1</span>) &lt; <span class="number">0</span>)  <span class="comment">// 写入到FIFO中</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"Write FIFO Failed"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">// 休眠1秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> fd;</span><br><span class="line"> <span class="keyword">int</span> len;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> <span class="keyword">if</span>(mkfifo(<span class="string">"fifo1"</span>, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno!=EEXIST) <span class="comment">// 创建FIFO管道</span></span><br><span class="line"> perror(<span class="string">"Create FIFO Failed"</span>);</span><br><span class="line"> <span class="keyword">if</span>((fd = open(<span class="string">"fifo1"</span>, O_RDONLY)) &lt; <span class="number">0</span>) <span class="comment">// 以读打开FIFO</span></span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">"Open FIFO Failed"</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">while</span>((len = read(fd, buf, <span class="number">1024</span>)) &gt; <span class="number">0</span>) <span class="comment">// 读取FIFO管道</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Read message: %s"</span>, buf);</span><br><span class="line"> close(fd); <span class="comment">// 关闭FIFO文件</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子可以扩展成 客户进程—服务器进程 通信的实例，write_fifo的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，read_fifo类似于服务器，它适时监控着FIFO的读端，当有数据时，读出并进行处理，但是有一个关键的问题是，每一个客户端必须预先知道服务器提供的FIFO接口。</p><h2 id="三、消息队列"><a href="#三、消息队列" class="headerlink" title="三、消息队列"></a>三、消息队列</h2><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p><h3 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li><p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p></li><li><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p></li><li><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p></li></ol><h4 id="1-1-消息队列与命名管道的比较"><a href="#1-1-消息队列与命名管道的比较" class="headerlink" title="1.1 消息队列与命名管道的比较"></a>1.1 消息队列与命名管道的比较</h4><pre><code>消息队列跟命名管道有不少的相同之处，通过与命名管道一样，消息队列进行通信的进程可以是不相关的进程，同时它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据用write，接收数据用read，则在消息队列中，发送数据用msgsnd，接收数据用msgrcv。而且它们对每个数据都有一个最大长度的限制。与命名管道相比，消息队列的优势在于，1、消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。2、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。3、接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。</code></pre><h3 id="2、原型-1"><a href="#2、原型-1" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 添加消息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 读取消息：成功返回消息数据的长度，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">long</span> type,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 控制消息队列：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>在以下两种情况下，msgget将创建一个新的消息队列：</p><ul><li>如果没有与键值key相对应的消息队列，并且flag中包含了IPC_CREAT标志位。</li><li>key参数为IPC_PRIVATE。</li></ul><p>函数msgrcv在读取消息队列时，type参数有下面几种情况：</p><ul><li>type == 0，返回队列中的第一个消息；</li><li>type &gt; 0，返回队列中消息类型为 type 的第一个消息；</li><li>type &lt; 0，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。</li></ul><p>可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。</p><h3 id="3、例子-2"><a href="#3、例子-2" class="headerlink" title="3、例子"></a>3、例子</h3><p>下面写了一个简单的使用消息队列进行IPC的例子，服务端程序一直在等待特定类型的消息，当收到该类型的消息以后，发送另一种特定类型的消息作为反馈，客户端读取该反馈并打印出来。</p><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_FILE <span class="meta-string">"/etc/passwd"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span>((key = ftok(MSG_FILE,<span class="string">'z'</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印key值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message Queue - Server key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取消息</span></span><br><span class="line">    <span class="keyword">for</span>(;;) </span><br><span class="line">    &#123;</span><br><span class="line">        msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">888</span>, <span class="number">0</span>);<span class="comment">// 返回类型为888的第一个消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line"></span><br><span class="line">        msg.mtype = <span class="number">999</span>; <span class="comment">// 客户端接收的消息类型</span></span><br><span class="line">        <span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm server %d"</span>, getpid());</span><br><span class="line">        msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于创建一个唯一的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_FILE <span class="meta-string">"/etc/passwd"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_form</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key值</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(MSG_FILE, <span class="string">'z'</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印key值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message Queue - Client key is: %d.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(key, IPC_CREAT|<span class="number">0777</span>)) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息队列ID及进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My msqid is: %d.\n"</span>, msqid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My pid is: %d.\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加消息，类型为888</span></span><br><span class="line">    msg.mtype = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(msg.mtext, <span class="string">"hello, I'm client %d"</span>, getpid());</span><br><span class="line">    msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取类型为777的消息</span></span><br><span class="line">    msgrcv(msqid, &amp;msg, <span class="number">256</span>, <span class="number">999</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtext is: %s.\n"</span>, msg.mtext);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: receive msg.mtype is: %d.\n"</span>, msg.mtype);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、信号量"><a href="#四、信号量" class="headerlink" title="四、信号量"></a>四、信号量</h2><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><h3 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li><p>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p></li><li><p>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p></li><li><p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p></li><li><p>支持信号量组。</p></li></ol><h3 id="2、原型-2"><a href="#2、原型-2" class="headerlink" title="2、原型"></a>2、原型</h3><p>最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做二值信号量（Binary Semaphore）。而可以取多个正整数的信号量被称为通用信号量。</p><p>Linux 下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"><span class="comment">// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf semoparray[], <span class="keyword">size_t</span> numops)</span></span>;  </span><br><span class="line"><span class="comment">// 控制信号量的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>其实PV问题，就是：p操作（wait）：申请一个单位资源，进程进入；v操作（signal）：释放一个单位资源，进程出来。用于解决常见问题 生产者-消费者、读者写者，哲学家就餐等。</p><h2 id="3、例子-3"><a href="#3、例子-3" class="headerlink" title="3、例子"></a>3、例子</h2><p>解决生产者消费者问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[<span class="number">5</span>];<span class="comment">//定义一个数组用于队列</span></span><br><span class="line"><span class="keyword">sem_t</span> p,c;<span class="comment">//两个信号量，一个是头，一个是尾</span></span><br><span class="line"> <span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">product</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//检测是否可以生产</span></span><br><span class="line">        sem_wait(&amp;p);<span class="comment">//？？？？</span></span><br><span class="line">        <span class="built_in">queue</span>[rear] = rand() % <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p:%d\n"</span>,<span class="built_in">queue</span>[rear]);<span class="comment">//可消费数增加</span></span><br><span class="line">        sem_post(&amp;c);<span class="comment">//？？？？</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        sleep(rand()%<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consume</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>,tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//检测队列中是否有数据</span></span><br><span class="line">        <span class="comment">//没有数据就等待</span></span><br><span class="line">        sem_wait(&amp;c);<span class="comment">// 等待信号的到来，信号到来大于0执行下面并减1，等于0阻塞继续等待</span></span><br><span class="line">        tmp = <span class="built_in">queue</span>[front];</span><br><span class="line">        <span class="built_in">queue</span>[front] = <span class="number">-1</span>;</span><br><span class="line">        sem_post(&amp;p);<span class="comment">// 将信号的值加1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"c:%d\n"</span>, tmp);<span class="comment">//要消费的量一般先给中间变量</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        sleep(rand()%<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pid, cid;</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    sem_init(&amp;p,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">    sem_init(&amp;c,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    pthread_create(&amp;pid,<span class="literal">NULL</span>,product,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid,<span class="literal">NULL</span>,consume,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//等待两个线程的汇合</span></span><br><span class="line">    pthread_join(pid,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;p);</span><br><span class="line">    sem_destroy(&amp;c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、共享内存"><a href="#五、共享内存" class="headerlink" title="五、共享内存"></a>五、共享内存</h2><p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。</p><p>共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程<br>共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问，例如前面说到的信号量。</p><h3 id="1、特点-3"><a href="#1、特点-3" class="headerlink" title="1、特点"></a>1、特点</h3><ol><li><p>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</p></li><li><p>因为多个进程可以同时操作，所以需要进行同步。</p></li><li><p>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</p></li></ol><h3 id="2、原型-3"><a href="#2、原型-3" class="headerlink" title="2、原型"></a>2、原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 断开与共享内存的连接：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>; </span><br><span class="line"><span class="comment">// 控制共享内存的相关信息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>当用shmget函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。</p><p>当一段共享内存被创建以后，它并不能被任何进程访问。必须使用shmat函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</p><p>shmdt函数是用来断开shmat建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。</p><p>shmctl函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是IPC_RMID（从系统中删除该共享内存）。</p><h2 id="3、例子-4"><a href="#3、例子-4" class="headerlink" title="3、例子"></a>3、例子</h2><h4 id="写端"><a href="#写端" class="headerlink" title="写端"></a>写端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILENAME <span class="meta-string">"/dev/null"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s string\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">key_t</span> shm_key = ftok(FILENAME, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> shm_size = getpagesize();</span><br><span class="line">    <span class="keyword">int</span> shm_id = shmget(shm_key, shm_size, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shm_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *data = (<span class="keyword">char</span> *)shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(data == (<span class="keyword">void</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmat"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(data, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shmdt(data) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmdt"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读端"><a href="#读端" class="headerlink" title="读端"></a>读端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILENAME <span class="meta-string">"/dev/null"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> shm_key = ftok(FILENAME, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> shm_size = getpagesize();</span><br><span class="line">    <span class="keyword">int</span> shm_id = shmget(shm_key, shm_size, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shm_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *data = (<span class="keyword">char</span> *)shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(data == (<span class="keyword">void</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmat"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"data: %s\n"</span>, data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shmdt(data) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmdt"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"shmctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、管道&quot;&gt;&lt;a href=&quot;#一、管道&quot; class=&quot;headerlink&quot; title=&quot;一、管道&quot;&gt;&lt;/a&gt;一、管道&lt;/h1&gt;&lt;p&gt;管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。&lt;/p&gt;
&lt;h3 id=&quot;1、特点：&quot;&gt;&lt;a href=&quot;#1、
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>分布式对时</title>
    <link href="http://yoursite.com/blog/2019/12/19/12-19%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/12/19/12-19技术笔记/</id>
    <published>2019-12-19T06:34:56.000Z</published>
    <updated>2019-12-26T03:09:37.685Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.qq.com/pdf/DT1VSaFBvSGx3RWxi" target="_blank" rel="noopener">https://docs.qq.com/pdf/DT1VSaFBvSGx3RWxi</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.qq.com/pdf/DT1VSaFBvSGx3RWxi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.qq.com/pdf/DT1VSaFBvSGx3RWxi&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mysql支持json</title>
    <link href="http://yoursite.com/blog/2019/12/11/12-11%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2019/12/11/12-11技术笔记-1/</id>
    <published>2019-12-11T06:16:54.000Z</published>
    <updated>2019-12-26T03:07:23.915Z</updated>
    
    <content type="html"><![CDATA[<p>mysql自5.7开始支持json。</p><h2 id="数据库建表"><a href="#数据库建表" class="headerlink" title="数据库建表"></a>数据库建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`json_test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID '</span>,</span><br><span class="line">  <span class="string">`attr`</span> <span class="keyword">json</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'属性类型'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><h2 id="数组中查询"><a href="#数组中查询" class="headerlink" title="数组中查询"></a>数组中查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`json_test`</span> (<span class="keyword">attr</span>) <span class="keyword">VALUES</span> (<span class="string">'[1, 2, 3]'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> json_test <span class="keyword">WHERE</span> JSON_CONTAINS(<span class="keyword">attr</span>, <span class="string">'2'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iduser_idattr    update_time        create_time</span><br><span class="line">11    [1, 2, 3]2019-12-11 11:45:062019-12-11 11:45:06</span><br></pre></td></tr></table></figure><h2 id="key-value查询"><a href="#key-value查询" class="headerlink" title="key-value查询"></a>key-value查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`json_test`</span> (<span class="keyword">attr</span>) <span class="keyword">VALUES</span> (<span class="string">'&#123;"color":"red","height":1.5&#125;'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> json_test <span class="keyword">WHERE</span> <span class="keyword">attr</span>-&gt;<span class="string">'$.color'</span> = <span class="string">'red'</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iduser_id attr                               update_time create_time</span><br><span class="line">21     &#123;"color": "red", "height": 1.5&#125;2019-12-11 11:54:442019-12-11 11:54:44</span><br></pre></td></tr></table></figure><p>也可以查key存在</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> json_test <span class="keyword">WHERE</span> JSON_CONTAINS_PATH(<span class="keyword">attr</span>,<span class="string">'all'</span>,<span class="string">'$.color'</span>)</span><br></pre></td></tr></table></figure><p>或者用 JSON_EXTRACT查value存在</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>全部更新和插入类似。</p><p>也可以指定key，更新value</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> json_test <span class="keyword">SET</span> <span class="keyword">attr</span> = JSON_SET(<span class="keyword">attr</span>, <span class="string">'$.color'</span>, <span class="string">'blue'</span>) <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql自5.7开始支持json。&lt;/p&gt;
&lt;h2 id=&quot;数据库建表&quot;&gt;&lt;a href=&quot;#数据库建表&quot; class=&quot;headerlink&quot; title=&quot;数据库建表&quot;&gt;&lt;/a&gt;数据库建表&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>NTP协议</title>
    <link href="http://yoursite.com/blog/2019/12/06/12-6%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2019/12/06/12-6技术笔记-1/</id>
    <published>2019-12-06T09:05:36.000Z</published>
    <updated>2019-12-08T14:15:59.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算rtt"><a href="#计算rtt" class="headerlink" title="计算rtt"></a>计算rtt</h1><p>即使两个服务器时间不一样，他们之间的rtt也是可以计算的，过程如下：</p><p>Device A发送一个NTP报文给Device B，该报文带有它离开Device A时的时间戳，该时间戳为10:00:00am（T1）。<br>当此NTP报文到达Device B时，Device B加上自己的时间戳，该时间戳为11:00:01am（T2）。<br>当此NTP报文离开Device B时，Device B再加上自己的时间戳，该时间戳为11:00:02am（T3）。<br>当Device A接收到该响应报文时，Device A的本地时间为10:00:03am（T4）。  </p><p>这样，Device A已经拥有足够的信息来计算两个重要的参数：  </p><p>NTP报文的往返时延Delay=（T4-T1）-（T3-T2）=2秒。<br>Device A相对Device B的时间差offset=（（T2-T1）+（T3-T4））/2=1小时。  </p><p>Device A就能够根据这些信息来设定自己的时钟，与Device B的时钟同步。</p><h1 id="时钟分层"><a href="#时钟分层" class="headerlink" title="时钟分层"></a>时钟分层</h1><p>NTP使用一个分层、半分层的时间源系统。该层次的每个级别被称为“stratum”，顶层分配为数字0。一个通过阶层n同步的服务器将运行在阶层n + 1。数字表示与参考时钟的距离，用于防止层次结构中的循环依赖性。阶层并不总是指示质量或可靠性；在阶层3的时间源得到比阶层2时间源更高的时间质量也很常见。电信系统对[时钟层]使用不同的定义。以下提供了阶层0、1、2、3的简要描述。</p><ol><li>阶层0（Stratum 0）</li></ol><p>这些是高精度计时设备，例如[原子钟]（如铯、铷）、[GPS时钟]或其他[无线电时钟]。它们生成非常精确的[脉冲秒]信号，触发所连接计算机上的[中断]和时间戳。阶层0设备也称为参考（基准）时钟。</p><ol start="2"><li>阶层1</li></ol><p>这些与阶层0设备相连、在几微秒误差内同步[系统时钟]的计算机。阶层1服务器可能与其他阶层1服务器对等相连，以进行完整性检查和备份。它们也被称为主要（primary）时间服务器</p><ol start="3"><li>阶层2</li></ol><p>这些计算机通过网络与阶层1服务器同步。提供阶层2的计算机将查询多个阶层1服务器。阶层2计算机也可能与其他阶层2计算机对等相连，为对等组中的所有设备提供更健全稳定的时间。</p><ol start="3"><li>阶层3</li></ol><p>这些计算机与阶层2的服务器同步。它们使用与阶层2相同的算法进行对等和数据采样，并可以自己作为服务器担任阶层4计算机，以此类推。</p><p>阶层的上限为15；阶层16被用于标识设备未同步。每台计算机上的NTP算法相互构造一个[贝尔曼-福特算法]最短路径[生成树]，以最小化所有客户端到阶层1服务器的累积往返延迟。</p><p>典型的NTP客户端将定期[轮询]不同网络上的三个或更多服务器。为同步其时钟</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算rtt&quot;&gt;&lt;a href=&quot;#计算rtt&quot; class=&quot;headerlink&quot; title=&quot;计算rtt&quot;&gt;&lt;/a&gt;计算rtt&lt;/h1&gt;&lt;p&gt;即使两个服务器时间不一样，他们之间的rtt也是可以计算的，过程如下：&lt;/p&gt;
&lt;p&gt;Device A发送一个NTP报
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>kafka-admin</title>
    <link href="http://yoursite.com/blog/2019/11/03/11-3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/11/03/11-3技术笔记/</id>
    <published>2019-11-03T10:11:45.000Z</published>
    <updated>2019-11-03T10:46:03.033Z</updated>
    
    <content type="html"><![CDATA[<p>常见的有kafka manager和 eagle</p><p>大致是kafka从0.11.0.0版本开始， 提供了一个工具类 org.apache.kafka.clients.admin.KafkaAdminClient，不仅可以用来管理 broker、配置和 ACL（Access Control List），还可以用来管理主题，KafkaAdminClient 继承了 org.apache.kafka.clients.admin.AdminClient 抽象类，并提供了多种方法。诸如，</p><ul><li>创建主题：CreateTopicsResult createTopics(Collection newTopics)。</li><li>删除主题：DeleteTopicsResult deleteTopics(Collection topics)。</li><li>列出所有可用的主题：ListTopicsResult listTopics()。</li><li>查看主题的信息：DescribeTopicsResult describeTopics(Collection topicNames)。</li><li>查询配置信息：DescribeConfigsResult describeConfigs(Collection resources)。</li><li>修改配置信息：AlterConfigsResult alterConfigs(Map&lt;ConfigResource, Config&gt; configs)。</li><li>增加分区：CreatePartitionsResult createPartitions(Map&lt;String, NewPartitions&gt; newPartitions)。</li></ul><p>把这个做成一个可视化的，即admin的基础。</p><p>edge功能如下</p><p><img src="https://i.loli.net/2019/11/03/mT6oKS9ZWdiUELJ.png" alt="mT6oKS9ZWdiUELJ"></p><p>甚至还可以看消息发送和消费情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常见的有kafka manager和 eagle&lt;/p&gt;
&lt;p&gt;大致是kafka从0.11.0.0版本开始， 提供了一个工具类 org.apache.kafka.clients.admin.KafkaAdminClient，不仅可以用来管理 broker、配置和 ACL（A
      
    
    </summary>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kafka可靠性</title>
    <link href="http://yoursite.com/blog/2019/10/31/10-30%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/blog/2019/10/31/10-30技术笔记-1/</id>
    <published>2019-10-31T12:40:28.000Z</published>
    <updated>2019-11-03T13:30:09.681Z</updated>
    
    <content type="html"><![CDATA[<p>在 Kafka 中动态维护着一个 ISR 集合，处于 ISR 集合内的节点保持与 leader 相同的高水位（HW），只有位列其中的副本（unclean.leader.election.enable 配置为 false）才有资格被选为新的 leader。写入消息时只有等到所有ISR集合中的副本都确认收到之后才能被认为已经提交。位于 ISR 中的任何副本节点都有资格成为 leader，选举过程简单、开销低，这也是 Kafka 选用此模型的重要因素。</p><h2 id="副本数"><a href="#副本数" class="headerlink" title="副本数"></a>副本数</h2><p>显然，副本越多可靠性越高，但性能越差。权衡的结果是，一般都是3副本，极少数高可靠性要求，比如银行，可以采用5副本。</p><h2 id="acks"><a href="#acks" class="headerlink" title="acks"></a>acks</h2><p>acks有三个级别，0，1，-1。-1其实是正无穷的意思。</p><p>即，需要多少成功写入本地日志之后会告知生产者已经成功提交。</p><p>0，就是不需要写入本地日志，生产者只管发。</p><p>1，就是只有leader写入本地日志，就成功提交。可靠性问题就是，leader写入-&gt;告知成功提交-&gt;leader挂了-&gt;follower还没来得及同步-&gt;消息丢了。</p><p>-1，等待 ISR 中的 follower 副本全部同步完成才能够告知生产者已经成功提交，即使此时 leader 副本宕机，消息也不会丢失。如果ISR 中的所有副本同步之前 leader 副本宕机了，那么生产者会收到异常以此告知此次发送失败。</p><h2 id="消息发送模式"><a href="#消息发送模式" class="headerlink" title="消息发送模式"></a>消息发送模式</h2><p>发后即忘的模式，不管消息有没有被成功写入，生产者都不会收到通知，那么即使消息写入失败也无从得知。</p><p>同步和异步在可靠性上没区别，他们的区别在于顺序，同步需要等待消息返回，才会继续。异步是回调，意味着，同步可以保证顺序。</p><h2 id="ISR-集合中最小的副本数"><a href="#ISR-集合中最小的副本数" class="headerlink" title="ISR 集合中最小的副本数"></a>ISR 集合中最小的副本数</h2><p>因为ISR里的副本，一旦跟不上，就会被踢，如果leader 副本的消息流入速度很快，而 follower 副本的同步速度很慢，在某个临界点时所有的 follower 副本都被剔除出了 ISR 集合，那么 ISR 中只有一个 leader 副本，最终 acks = -1 演变为 acks = 1 的情形。</p><p>为了避免这个情况，有min.insync.replicas 参数（默认值为1）来作为辅助配合 acks = -1 来使用，个典型的配置方案为：副本数配置为3，min.insync.replicas 参数值配置为2。</p><p>很显然，这个配置很影响可用性。</p><h2 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h2><p>enable.auto.commit 参数的默认值为 true，即开启自动位移提交的功能，如果消费者没能消费成功或者挂了，消息同样也丢失了，所以可以设置手动位移提交。</p><p>但是会带来重复消费的问题，试想，消费者成功消费了，还没来得及手动位移提交，消费者挂了。消费者恢复，此时会重复消费这条消息。所以需要消费者这边做幂等处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Kafka 中动态维护着一个 ISR 集合，处于 ISR 集合内的节点保持与 leader 相同的高水位（HW），只有位列其中的副本（unclean.leader.election.enable 配置为 false）才有资格被选为新的 leader。写入消息时只有等到所
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kafka时间轮</title>
    <link href="http://yoursite.com/blog/2019/10/28/10-28%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/blog/2019/10/28/10-28技术笔记/</id>
    <published>2019-10-28T02:11:56.000Z</published>
    <updated>2019-10-31T12:40:38.371Z</updated>
    
    <content type="html"><![CDATA[<p>定时任务常规实现方法是延时队列DelayQueue，它的时间复杂度nlgn，不适合太多的延时任务，而时间轮时间复杂度1。</p><p><img src="https://i.loli.net/2019/10/28/Fwm5HZi2BSRQgVr.png" alt="Fwm5HZi2BSRQgVr"></p><p>Kafka 中的时间轮（TimingWheel）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。TimerTaskList 是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务（TimerTask）。</p><p>时间轮由多个时间格组成，每个时间格代表当前时间轮的基本时间跨度（tickMs）。时间轮的时间格个数是固定的，可用 wheelSize 来表示，那么整个时间轮的总体时间跨度（interval）可以通过公式 tickMs×wheelSize 计算得出。</p><p>时间轮还有一个表盘指针（currentTime），用来表示时间轮当前所处的时间，currentTime 是 tickMs 的整数倍。currentTime 可以将整个时间轮划分为到期部分和未到期部分，currentTime 当前指向的时间格也属于到期部分，表示刚好到期，需要处理此时间格所对应的 TimerTaskList 中的所有任务。</p><p>我们常见的钟表就是一种具有三层结构的时间轮，第一层时间轮 tickMs=1s、wheelSize=60、interval=1min，此为秒钟；第二层 tickMs=1min、wheelSize=60、interval=1hour，此为分钟；第三层 tickMs=1hour、wheelSize=12、interval=12hours，此为时钟。</p><p>Kafka 中会有一个线程来获取 DelayQueue 中到期的任务列表，有意思的是这个线程所对应的名称叫作“ExpiredOperationReaper”，可以直译为“过期操作收割机”，和第4节的“SkimpyOffsetMap”的取名有异曲同工之妙。当“收割机”线程获取 DelayQueue 中超时的任务列表 TimerTaskList 之后，既可以根据 TimerTaskList 的 expiration 来推进时间轮的时间，也可以就获取的 TimerTaskList 执行相应的操作，对里面的 TimerTaskEntry 该执行过期操作的就执行过期操作，该降级时间轮的就降级时间轮。</p><p>问题在于，时间是怎么推进的，方法是延时队列DelayQueue，那么为什么又绕了回来，区别在于延时队列DelayQueue里放的不再是具体的任务TimerTaskEntry，而是真正有任务的TimerTaskList，而对于时间轮来说，它只需要往delayQueue里面扔各种槽即可，这样的话，比如我们的定时任务长短不一，最长的跨度到了24年，这个delayQueue也仅仅只有300个元素。</p><p>而这个槽到期后，也就是被我们从delayQueue中poll出来后，我们只需要将槽中的所有任务循环一次，重新加到新的槽中（添加失败则直接执行）即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定时任务常规实现方法是延时队列DelayQueue，它的时间复杂度nlgn，不适合太多的延时任务，而时间轮时间复杂度1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/28/Fwm5HZi2BSRQgVr.png&quot; alt=&quot;Fwm
      
    
    </summary>
    
    
      <category term="消息队列" scheme="http://yoursite.com/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
