<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Arvense, NexT">





  <link rel="alternate" href="/blog/atom.xml" title="Arvense" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Arvense">
<meta property="og:url" content="http://yoursite.com/blog/page/15/index.html">
<meta property="og:site_name" content="Arvense">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Arvense">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/blog/page/15/">





  <title>Arvense</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Arvense</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/13/12-13技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/13/12-13技术笔记/" itemprop="url">Dubbo功能和简单配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-13T17:35:55+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Dubbo功能"><a href="#Dubbo功能" class="headerlink" title="Dubbo功能"></a>Dubbo功能</h1><h2 id="没有Dubbo的http"><a href="#没有Dubbo的http" class="headerlink" title="没有Dubbo的http"></a>没有Dubbo的http</h2><p>假设我们的系统非常简单，如何对外提供服务呢？</p>
<p>服务方启动一个tomcat+springmvc，监听80端口，调用方通过httpclient发起http请求，服务方返回json或xml数据结果，调用方拿到http响应结果解析结果数据，一次服务调用结束。</p>
<h2 id="注册中心与客户端负载均衡"><a href="#注册中心与客户端负载均衡" class="headerlink" title="注册中心与客户端负载均衡"></a>注册中心与客户端负载均衡</h2><p>随着服务的增多，一方面在配置中心，服务的内部域名化或url路径不断随业务变化；另一方面，服务器压力变大，这时也需要负载均衡。解决方法：</p>
<p>服务方在启动tomcat后，向注册中心注册自己的服务列表，包括服务器ip、port，以及代表服务的唯一标识，比如以格式/a_service/ip_port,/b_service/ip_port存储在注册中心。<br>这样调用方在启动后，去注册中心寻找a服务的地址列表，并且订阅/a_service，当a服务列表变更就会将变更消息推给调用方。接下来地址列表得到了，调用方创建多个httpClient实例，每个实例对应一个服务器ip_port，每次发起调用，从httpclient实例列表中随机选择一个，发起调用请求。当服务方某台服务器出现宕机或者网络故障，调用方会从收到由注册中心推送过来的通知消息，进而将出现故障的ip_port对应的httpclient从列表中移出；当服务方新增加服务器时，调用方同样会收到通知消息，进而新建httpclient实例，加入httpclient列表。  </p>
<h2 id="服务端负载均衡模块"><a href="#服务端负载均衡模块" class="headerlink" title="服务端负载均衡模块"></a>服务端负载均衡模块</h2><p>服务端也希望设置负载均衡的权重，权重高的服务器的收到更多的请求，这时服务端也向注册中心注册权重信息。</p>
<h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>对于不同的服务，容错机制也应该不同。非幂等操作-&gt;失败立刻报错；要求结果的-&gt;重试其他服务器；无所谓的-&gt;失败忽略；消息通知-&gt;失败重发。</p>
<h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><p>路由机制，Dubbo的路由机制主要解决的目的就是服务调用时，从已知的所有服务提供者中根据路由规则刷选服务提供者。多个业务系统都实现了同一个服务，在调用中通过读取相关配置可以知道此次调用是限制请求到哪几个服务提供者上，而不是所有提供者中任取一个，这个就需要在dubbo上自定义自己的路由规则。</p>
<h2 id="管理和监控"><a href="#管理和监控" class="headerlink" title="管理和监控"></a>管理和监控</h2><p>可视化管理中心，管理和监控各种性能。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>consumer向注册中心注册，并获取服务端相应的信息后，代理工厂创建的远程服务代理，完成了RPC调用。</p>
<h1 id="Dubbo配置"><a href="#Dubbo配置" class="headerlink" title="Dubbo配置"></a>Dubbo配置</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service/&gt; 服务配置，用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心。</span><br><span class="line">eg、&lt;dubbo:service ref=<span class="string">"demoService"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.unj.dubbotest.provider.DemoService"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:reference/&gt; 引用服务配置，用于创建一个远程服务代理，一个引用可以指向多个注册中心。</span><br><span class="line">eg、&lt;dubbo:reference id=<span class="string">"demoService"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.unj.dubbotest.provider.DemoService"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:protocol/&gt; 协议配置，用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受。</span><br><span class="line">eg、&lt;dubbo:protocol name=<span class="string">"dubbo"</span> port=<span class="string">"20880"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:application/&gt; 应用配置，用于配置当前应用信息，不管该应用是提供者还是消费者。</span><br><span class="line">eg、&lt;dubbo:application name=<span class="string">"xixi_provider"</span> /&gt;</span><br><span class="line">    &lt;dubbo:application name=<span class="string">"hehe_consumer"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:<span class="keyword">module</span>/&gt; 模块配置，用于配置当前模块信息，可选。</span><br><span class="line">&lt;dubbo:registry/&gt; 注册中心配置，用于配置连接注册中心相关信息。</span><br><span class="line">eg、&lt;dubbo:registry address=<span class="string">"zookeeper://192.168.2.249:2181"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:monitor/&gt; 监控中心配置，用于配置连接监控中心相关信息，可选。</span><br><span class="line">&lt;dubbo:provider/&gt; 提供方的缺省值，当ProtocolConfig和ServiceConfig某属性没有配置时，采用此缺省值，可选。</span><br><span class="line">&lt;dubbo:consumer/&gt; 消费方缺省配置，当ReferenceConfig某属性没有配置时，采用此缺省值，可选。</span><br><span class="line">&lt;dubbo:method/&gt; 方法配置，用于ServiceConfig和ReferenceConfig指定方法级的配置信息。</span><br><span class="line">&lt;dubbo:argument/&gt; 用于指定方法参数配置。</span><br></pre></td></tr></table></figure>
<h2 id="集群容错方案"><a href="#集群容错方案" class="headerlink" title="集群容错方案"></a>集群容错方案</h2><ol>
<li><p>Failover Cluster失败自动切换，当出现失败，重试其它服务器。(缺省)通常用于读操作，但重试会带来更长延迟。可通过retries=”2”来设置重试次数(不含第一次)。</p>
</li>
<li><p>Failfast Cluster 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
</li>
<li><p>Failsafe Cluster失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
</li>
<li><p>Failback Cluster，失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
</li>
<li><p>Forking Cluster并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks=”2”来设置最大并行数。</p>
</li>
<li><p>Broadcast Cluster，广播调用所有提供者，逐个调用，任意一台报错则报错。(2.1.0开始支持)通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
</li>
</ol>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><ol>
<li><p>Random LoadBalance（默认），随机，其实最后就会平均。</p>
</li>
<li><p>RoundRobin LoadBalance，轮询，适用于机器性能有差异，能者多劳。但实际上，自己加的权不一定是真正的性能个差异，导致慢的积累。</p>
</li>
<li><p>LeastActive LoadBalance， 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>
</li>
<li><p>ConsistentHash LoadBalance，一致性哈希。一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/12/12-12技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/12/12-12技术笔记/" itemprop="url">zookeeper使用场景</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-12T19:31:12+08:00">
                2018-12-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据发布与订阅（配置中心）"><a href="#数据发布与订阅（配置中心）" class="headerlink" title="数据发布与订阅（配置中心）"></a>数据发布与订阅（配置中心）</h1><p>发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。</p>
<p>这类场景通常是这样：应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。</p>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。</p>
<p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。</p>
<p>Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表。</p>
<p><strong>服务提供者</strong>在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。</p>
<p><strong>服务消费者</strong>启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址， 并向/dubbo/${serviceName} /consumers目录下写入自己的URL地址。</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>基于zookeeper的强一致性，通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。</p>
<p>也可以保持时序执行，做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
<h1 id="分布通知-协调"><a href="#分布通知-协调" class="headerlink" title="分布通知/协调"></a>分布通知/协调</h1><p> 使用方法通常是不同系统都对ZK上同一个znode进行注册，监听znode的变化(包括znode本身内容及子节点的)，其中一个系统update了znode，那么另一个系统能够收到通知，并作出相应处理。</p>
<h1 id="集群管理与Master选举"><a href="#集群管理与Master选举" class="headerlink" title="集群管理与Master选举"></a>集群管理与Master选举</h1><p>集群中，可以监控在线，动态上下线，以及选举master。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/12/leetcode20-21-28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/12/leetcode20-21-28/" itemprop="url">有效的括号，合并两个有序单链表，子串在字符串中的位置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-12T19:02:38+08:00">
                2018-12-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="20"><a href="#20" class="headerlink" title="20"></a>20</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，只包含’(‘, ‘)’, ‘{‘, ‘}’, ‘[’ 和’]’这些字符，检查它是否是“有效”的。<br>括号必须以正确的顺序关闭，例如”()” 和”()[]{}”都是有效的，”(]” 和”([)]”是无效的。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>栈的基础题，左括号入栈，匹配出栈即可。注意判断栈是否已空。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> a = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="string">'&#123;'</span>||a==<span class="string">'['</span>||a==<span class="string">'('</span>)&#123;</span><br><span class="line">                stack.push(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.empty()&amp;&amp;stack.peek() == <span class="string">'('</span>) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.empty()&amp;&amp;stack.peek() == <span class="string">'['</span>) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">'&#125;'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.empty()&amp;&amp;stack.peek() == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>栈操作都忘了，pop是出栈，peak是栈顶元素。</p>
<h1 id="21"><a href="#21" class="headerlink" title="21"></a>21</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>合并两个有序单链表</p>
<h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><p>链表操作不熟练的话，还是有点困难，我采用转list排序再转回去的方法，还是有点蠢。</p>
<h2 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       ListNode o1=l1,o2=l2;</span><br><span class="line">       <span class="keyword">while</span> (o1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           list.add(o1.val);</span><br><span class="line">           o1=o1.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (o2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           list.add(o2.val);</span><br><span class="line">           o2=o2.next;</span><br><span class="line">       &#125;</span><br><span class="line">       Collections.sort(list);</span><br><span class="line">       ListNode tmp=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(!list.isEmpty()) &#123;</span><br><span class="line">           ListNode ans = <span class="keyword">new</span> ListNode(list.get(<span class="number">0</span>));</span><br><span class="line">           tmp = ans;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">               ListNode next = <span class="keyword">new</span> ListNode(list.get(i));</span><br><span class="line">               ans.next = next;</span><br><span class="line">               ans = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tmp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>实际上应该用正统链表操作的话，可以加一个“哨兵”节点，就是说在头结点之前的，没有值，只用来开头的节点，以避免一些空指针问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode currentNode=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span>&amp;&amp;l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2!=<span class="keyword">null</span>&amp;&amp;(l1==<span class="keyword">null</span>||l1.val&gt;l2.val))&#123;</span><br><span class="line">                currentNode.next=l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                currentNode.next=l1;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            currentNode=currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h2><p>实际上，链表和链表的节点是同一个东西，都只是对该节点持有的引用。原来C中，习惯起好几个别名，把我搞晕了。据说链表的常用操作有5种。</p>
<ol>
<li><p>反转单链表。用三个指针操作解决。</p>
</li>
<li><p>合并有序链表。如上</p>
</li>
<li><p>判断链表是否有环。一快一慢两个指针，快的每次两格，慢的每次一格。如果有环，将跑不完，最后绕圈子，绕圈子后果是套圈，也即是说，两个指针相遇。</p>
</li>
<li><p>倒数第n个节点。也是双指针法，倒数第n个节点，就是正数第a-n个节点,让第一个指针先移动n个，这样它离到达结尾还剩a-n步，这时，第一个和第二个指针一起移动这a-n步，则第二个指针到达倒数n。</p>
</li>
<li><p>求链表中间节点。有点像上面两者结合，快的每次两格，慢的每次一格，快的到终点了，慢的到了一半。分下奇偶。</p>
</li>
</ol>
<h1 id="28"><a href="#28" class="headerlink" title="28"></a>28</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>求子串在字符串中的位置。</p>
<h2 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h2><p>java内置的有类库实现，indexOf()方法。实际上，考察的是KMP算法。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h2><p>KMP算法还是比较复杂的，有点像动态规划。</p>
<blockquote>
<p><a href="https://blog.csdn.net/gesanghuazgy/article/details/52214718" target="_blank" rel="noopener">https://blog.csdn.net/gesanghuazgy/article/details/52214718</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/11/12-11技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/11/12-11技术笔记/" itemprop="url">Zookeeper特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-11T19:37:22+08:00">
                2018-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h2><p>zookeeper集群角色有三种，leader，follower，observer。权限上的区别，follower不能写，observer不参加leader选举，也不参加过半写成功策略。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>客户端和服务器通过TCP连接建立会话，通过心跳检测保持有效，可以向服务器发送请求接受响应，还可以接受Watch事件的通知。重连时，连上任意一台，即可视为重连有效。</p>
<h2 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h2><p>所有数据都存在内存中，数据节点之间是树状结构，这样像文件系统一样，用/斜杠分隔符表示路径就可以找到节点。</p>
<p>节点分类有两种维度：永久节点和临时节点，可以理解为，前者是服务端用的，后者是客户端用的；顺序节点和非顺序节点，顺序节点，就是父节点在创建下一级子节点的时候，记录每个子节点创建的先后顺序，会给每个子节点名加上一个数字后缀。</p>
<p>临时节点不能创建子节点。</p>
<p>Zookeeper <strong>不能用于存放大量的数据</strong>   ，每个节点的存放数据上限为<strong><em>1M</em></strong>。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>每个ZNode(节点)上都会存储数据。（为了分布式一致性需要？）每个节点都有版本，一共有三种同时维护：自己的，子节点的，ACL版本。</p>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p>客户端可以在指定节点上注册一些Watcher，当事件触发时，服务端会主动通知客户端。一个Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端，以便通知它们。</p>
<p>也就是说Watcher是一次性的，一方面节省服务端性能，另一方面客户端也不需要知道每次变化，只用知道最新的变化即可。</p>
<p>也就是说，客户端不能接收到所有的节点变化通知，因为即使你每次接受到通知就立刻注册Watcher，在这个过程过，数据也有可能已经发生了多次修改。</p>
<h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><p>即控制访问列表，用来权限控制。创建更新获取删除子节点等权限。</p>
<h1 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h1><p>ZooKeeper没有完全采用paxos，而是使用了自己修改过的ZAB协议。</p>
<h2 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h2><p>针对客户端的事务请求，ZAB区别在于，只有一个proposal，然后收集选票，最后事务提交。类似于2PC的过程。为了保证事务的顺序性，所有的proposal都在被提出的时候加上了zxid。</p>
<h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p>2PC问题在于，leader崩溃会导致无法继续，这里采用了崩溃恢复机制，重新选举Leader。谁被选上主要取决于zxid。</p>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>选举完Leader后，通过事务日志，观察Proposal是否被集群中过半的机器提交。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>在一个客户端修改数据后，ZooKeeper不能确保任何客户端能够获取（即Read Request）到一样的数据，除非客户端自己要求：方法是客户端在获取数据之前调用sync方法。    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/11/leetcode1,8,15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/11/leetcode1,8,15/" itemprop="url">两数和，字符串转数字，三数和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-11T10:42:05+08:00">
                2018-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给一个int数组，和一个目标数，数组中某两数只和为目标数，要求找到这两个数的下标。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>遍历数组时，将数和下标存入一个哈希表中，同时查找和目标数差值是否在哈希表中即可。一次遍历。复杂度O(N)。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int ans[] = new int[2] ;</span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        for (int i = 0;i&lt;nums.length;i++) &#123;</span><br><span class="line">            if(hashMap.containsKey(target-nums[i]))&#123;</span><br><span class="line">                ans[0]=(int)hashMap.get(target-nums[i]);</span><br><span class="line">                ans[1]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>其实大学时，经常听人说哈希表的思路，但当时的理解只是数组下标和数组内容的映射，因为C数据结构似乎都要手动实现，所以直接使用HashMap也没那么方便，也不知道。Java封装好了的，用即可。</p>
<h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>字符串转数字。前面的空格忽略。比如”42”-&gt;42,”    -40”-&gt;-40,” 42avv”-&gt;42,”dw42”-&gt;0;</p>
<h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><p>其实没啥好说的，遍历字符串，处理各种情况即可。</p>
<ol>
<li>Character.isWhitespace()判断空字符</li>
<li>str.charAt(begin) &lt;= 57 &amp;&amp; str.charAt(begin) &gt;= 48判断是数字</li>
<li>str.charAt(u) - ‘0’字符转数字        </li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public int myAtoi(String str) &#123;</span><br><span class="line">        int begin = 0, ans = 0, flag = 1;</span><br><span class="line">        if(str.length() != 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">                char a = str.charAt(i);</span><br><span class="line">                if(Character.isWhitespace(a)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    begin = i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(str.charAt(begin) == &apos;-&apos;) &#123;</span><br><span class="line">                flag = -1;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(str.charAt(begin) == &apos;+&apos;)&#123;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(begin == str.length()) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                if(str.charAt(begin) &lt;= 57 &amp;&amp; str.charAt(begin) &gt;= 48) &#123;</span><br><span class="line">                    for (int u = begin; u &lt; str.length(); u++) &#123;</span><br><span class="line">                        if(!(str.charAt(u) &lt;= 57 &amp;&amp; str.charAt(u) &gt;= 48)) &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;else &#123;</span><br><span class="line">                            if(flag * (ans * 10D + (str.charAt(u) - &apos;0&apos;)) &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                                return Integer.MAX_VALUE;</span><br><span class="line">                            &#125;else if(flag * (ans * 10D + (str.charAt(u) - &apos;0&apos;)) &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                                return Integer.MIN_VALUE;</span><br><span class="line">                            &#125;else &#123;</span><br><span class="line">                                ans = ans * 10 + (str.charAt(u) - &apos;0&apos;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                return ans * flag;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h2><p>leetcode最令人感动的是，告诉哪个测试数据错了啊。大学时不想做oj，最大的原因就是反正就是Error,然而自己和样例输出对比结果是一样的，就是不知道哪个测试数据过不了，简直折磨。<br>三次错误分别是:1.空字符串;2.只有一个负号后面没数字3.正号。</p>
<h1 id="15"><a href="#15" class="headerlink" title="15"></a>15</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>三数求和，类似于第一题，题目有所简化，和不是给出的，而是固定的。给定一个数组，他们某三个之和为0，输出所有的不重复组合。</p>
<h2 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h2><p>用的是首尾两指针向中间移动法。这样一种简化情况，求哪两数和为某个值，先把数组排序，首尾两个指针，如果所指两数之和小于给定值，说明左指针该右移。反之的话，就反过来。然后我们固定第一个数，后面两个数用这个方法就好。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 2; i++) &#123;</span><br><span class="line">        if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int l = i + 1, r = nums.length - 1;//下一个元素，最后一个元素</span><br><span class="line">       while (l&lt;r) &#123;//两个指针向中间移动</span><br><span class="line">            if(nums[l] + nums[r] +nums[i]== 0) &#123;//得到答案</span><br><span class="line">                List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">                arrayList.add(nums[i]);</span><br><span class="line">                arrayList.add(nums[l]);</span><br><span class="line">                arrayList.add(nums[r]);</span><br><span class="line">                ans.add(arrayList);</span><br><span class="line"></span><br><span class="line">                while (l &lt; r &amp;&amp; nums[l + 1] == nums[l]) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">                while (l &lt; r &amp;&amp; nums[r - 1] == nums[r]) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[l] + nums[r] +nums[i]&gt; 0) &#123;//如果大了，右指针左移</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[l] + nums[r] +nums[i]&lt; 0) &#123;//如果小了，左指针右移</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h2><p>其实两指针向中间移动这方法很正常啊，但不知为什么，内心潜意识总觉得这种方法会漏掉情况，我觉得关键是如果数组是有序的，求和这个情况的确不会漏掉。什么时候会漏掉，却暂时想不到。</p>
<p>与其在循环里反复判断跳出，为什么不直接写在循环条件里呢233</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/07/12-7技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/07/12-7技术笔记/" itemprop="url">redis运营细节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T18:02:32+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>新版本redis退出了stream，这样基本实现了消息中间件功能。借鉴了很多kafka设计，功能似乎很齐全。</p>
<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>redis运维指令info，告诉各种运行状况</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>集群下使用分布式锁，有一致性问题，比如在 Sentinel 集群中，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。<br>如果不能容忍的话，redis有redlock算法，牺牲了性能，增加了类库，解决了这个问题。但是我觉得，还是应该从业务出发。redis应该性能优先，保证安全性不应该在redis这一层做。</p>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>为了避免很多同时过期，带来淘汰的压力。应该给expire加上个随机的时间，这样过期会均匀分布。</p>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>Redis基于内存的，但当内存空间不足时，需要和磁盘交互。此时采用的是随机方法逼近LRU(最近最久未使用)，即每次随机采样，淘汰最旧。但我觉得，不应该让redis内存溢出，而不是靠与磁盘交互来解决问题。</p>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>Java 程序一般都是多线程的应用程序，意味着我们很少直接使用 Jedis，而是要用到 Jedis 的连接池 —— JedisPool。同时因为 Jedis 对象不是线程安全的，当我们要使用 Jedis 对象时，需要从连接池中拿出一个 Jedis 对象独占，使用完毕后再将这个对象还给连接池。为了避免在使用时出现异常，应该用try-with-resource 语句来保护 Jedis 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    JedisPool pool = new JedisPool();</span><br><span class="line">    try (Jedis jedis = pool.getResource()) &#123; // 用完自动 close</span><br><span class="line">      doSomething(jedis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/06/12-6技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/06/12-6技术笔记/" itemprop="url">redis分布式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-06T19:55:00+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="主从备份"><a href="#主从备份" class="headerlink" title="主从备份"></a>主从备份</h1><p>redis支持主从备份，但从机只是防宕机的备份作用，采用读写分离可以缓解主机压力，但由于每次写操作后，主机数据同步到从机的过程，是非阻塞异步的，意味着这样有数据一致性的问题。</p>
<h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><p>哨兵机制是，主机挂了自动找到合适的从机，并且将从机切换为主机。功能上，监控了主机和各从机是否正常；如果某redis实例有故障，通知管理员；出现故障后，自动找到从机将其切换为主机；如果故障转移发生了，通知client客户端有新的master地址。<br>为了避免哨兵自己挂了，哨兵也是集群的方式。</p>
<h2 id="解决异步复制的一致性和脑裂问题"><a href="#解决异步复制的一致性和脑裂问题" class="headerlink" title="解决异步复制的一致性和脑裂问题"></a>解决异步复制的一致性和脑裂问题</h2><p>即，主机新的数据，还没复制到从机，主机就挂了怎么办。根据CAP定理，这个问题是无法完美解决的，只能有所取舍。取舍程度取决于两个参数：min-slaves-to-write 1 和 min-slaves-max-lag 10：<br>这两个参数的意思就是，要求至少有1个slave，数据复制和同步的延迟不能超过10s，如果说一旦所有的slave，数据复制和同步的延迟都超过10s，那么这个时候，master就不会再接受任何请求了。<br>一旦slave复制数据和ack延迟时间太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样就可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低到可控范围内。<br>如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保的说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求。这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失。</p>
<h1 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h1><p>redis单机单线程，解决方法最简单就是集群。Redis Cluster解决方法很简单，根据哈希值分池，对每个key值做CRC16取值，对16384求模后分池，redis cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot。hash slot让node的增加和移除很简单，增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去。<br>在redis cluster架构下，每个redis要放开两个端口号，比如一个是6379，另外一个就是加10000的端口号，比如16379。16379端口号是用来进行节点间通信的，也就是cluster bus的东西，集群总线。cluster bus的通信，用来进行故障检测，配置更新，故障转移授权等。cluster bus用了另外一种二进制的协议，主要用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/04/12-4技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/04/12-4技术笔记/" itemprop="url">redis原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-04T15:57:17+08:00">
                2018-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h1><p>redis是单线程的，内存的，但仍然很快，原因是多路复用技术。即事件轮询，select，NIO啊。</p>
<h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h1><p>redis用的自己的通信协议，是基于分隔符的，即回车换行符。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>持久化有两种方式，存量的RBD，增量的AOF。</p>
<h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>RDB是快照的形式每隔一段时间，新起一个<strong>进程</strong>，数据集快照写入磁盘。简单来说，fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>AOF是日志的形式，就是记录每一个对数据有改变的操作，存在日志里。以文本的方式记录，可以打开文件看到详细的操作记录。实际上文件在内存里，还需要写回磁盘，写回磁盘有三种策略，每次操作：性能很差；每秒：意味着秒级别的数据丢失；从无：依赖于操作系统，不安全。这么看一般都是用折中的每秒。<br>对于日益增长的AOF文件，还可以瘦身，即AOF重写，开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>RDB缺点有两个，一是每隔一段时间，要是宕机，隔的时间里没了。比如说，每1分钟快照一次，第2分30秒挂了，那第2分钟到第二分钟30秒这三十秒的数据丢失了。二是新起一个进程，数据集较大时，备份会卡顿<br>AOF缺点在于，备份文件较大，重放耗时较长。<br>现在支持混合持久化，将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。</p>
<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道实际上不是redis的技术，而是来自于客户端的操作。管道简单来说，就是把多次读写请求放一起。<br>没有管道，客户端与服务端交互是：写“读数据1”请求，读“数据1”回应。写“读数据2”请求，读“数据2”回应。写“读数据2”请求，读“数据2”回应。这样来回操作。<br>使用管道，就是把请求放在一起，变成：写“读数据123”请求，读“数据123”回应。这样就节省了时间。<br>就像批处理请求，这样，使用管道的场景应该是，这些交互都是独立的，他们之间没有先后互不依赖，这样才可以放一起。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="无原子性"><a href="#无原子性" class="headerlink" title="无原子性"></a>无原子性</h2><p>redis的事务和数据库事务并不是同义词，即使使用了事务，也不能保证原子性，仅仅是满足了事务的「隔离性」，隔离性中的串行化——当前执行的事务有着不被其它事务打断的权利。<br>形式上和一般事务差不多，multi 指示事务的开始，exec 指示事务的执行，discard 指示事务的丢弃。但这里没有回滚。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为了性能，事务应该和管道一起进行。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>分布式锁是悲观锁，redis也有乐观锁机制，即watch。乐观锁就是监测变量在事务过程中有没有变化，要是没有，说明没有并发问题，就提交。<br>watch应该在multi之前。操作顺序应该是，watch 变量-&gt;变量操作-&gt;multi-&gt;set提交修改-&gt;exec；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    jedis.watch(key); //watch 变量</span><br><span class="line">    int value = Integer.parseInt(jedis.get(key));</span><br><span class="line">    value *= 2; // 变量操作</span><br><span class="line">    Transaction tx = jedis.multi(); //multi</span><br><span class="line">    tx.set(key, String.valueOf(value)); //set提交修改</span><br><span class="line">    List&lt;Object&gt; res = tx.exec(); //exec</span><br><span class="line">    if (res != null) &#123;</span><br><span class="line">      break; // 成功了</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Integer.parseInt(jedis.get(key)); // 重新获取余额</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>redis做的消息队列PubSub基本已经凉了，有个新的未发布的Disque。Redis5.0 新增了 Stream 数据结构，这个功能给 Redis 带来了持久化消息队列.</p>
<h1 id="小对象压缩"><a href="#小对象压缩" class="headerlink" title="小对象压缩"></a>小对象压缩</h1><h2 id="32位编译"><a href="#32位编译" class="headerlink" title="32位编译"></a>32位编译</h2><p>如果占用内存不超过4G，可以采用更快的32位编译，指令更短。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>当数据较少时，使用ziplist，将稀疏二维矩阵一维化，节省空间。<br>采用了类似池化的技术，并不直接回收内存，而是分页的方式留待下次使用。<br>内存分配没有自己做，用的第三方的，有facebook家的jemalloc，谷歌家的tcmalloc，默认的前者性能好。</p>
<h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><p>根据CAP定理，在网络分区下，一致性和可用性无法同时获得。白话来说，如果主机和从机之间的网络断开了，如果主机继续运行，从机无法备份，那么主从数据将不一致；如果主机暂时停机，等从机再连上，那么服务将暂时不可用。<br>在这种情况下，redis的取舍是牺牲一致性，也就是等连上了，从机再追回数据。</p>
<h2 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h2><p>主机将影响状态的增量操作存在缓存中，等连上了后，传给从机，从机同步数据。然而缓存有限，后面的数据会覆盖前面的，如果数据太多，有特别久的操作将无法同步。</p>
<h2 id="存量同步"><a href="#存量同步" class="headerlink" title="存量同步"></a>存量同步</h2><p>用快照将内存所有数据存在磁盘，再传给从库，从库复制数据。时间较长。</p>
<h2 id="同步死循环"><a href="#同步死循环" class="headerlink" title="同步死循环"></a>同步死循环</h2><p>存量同步时间较长，期间又产生了数据，如果此时的数据又太多溢出了，则同步失败。</p>
<h2 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h2><p>redis也支持放弃可用性，得到一致性。以同步阻塞的方式同步，wait指令。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/03/12-3技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/03/12-3技术笔记/" itemprop="url">netty编解码器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-03T14:32:43+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>ByteToMessageDecoder有decodeLast方法，Netty提供的这个默认实现只是简单地调用了decode()方法。当Channel的状态变为非活动时，这个方法将会被调用一次。可以重写该方法以提供特殊的处理，比如产生一个一个 LastHttpContent 消息。</li>
<li>ReplayingDecoder扩展了ByteToMessageDecoder类，使得我们不必调用 readableBytes()方法。它通过使用一个自定义的ByteBuf实现 ，ReplayingDecoderByteBuf，包装传入的ByteBuf实现了这一点，其将在内部执行该调用。简单来说，不用数字节，每四个读一个int.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* if (in.readableBytes() &gt;= 4) &#123;</span><br><span class="line">  *     out.add(in.readInt());</span><br><span class="line">  &#125;*/</span><br><span class="line">//上面的操作被下面替代</span><br><span class="line">out.add(in.readInt());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>ReplayingDecoder 和ByteToMessageDecoder 最大的不同就是ReplayingDecoder 允许你实现decode()和decodeLast()就像所有的字节已经接收到一样，不需要判断可用的字节</p>
<ol start="3">
<li>由于 Netty 是一个异步框架，所以需要在字节可以解码之前在内存中缓冲它们。因此，不能让解码器缓冲大量的数据以至于耗尽可用的内存。为了解除这个常见的顾虑，Netty 提供了TooLongFrameException 类，该异常在ChannelHandler.exceptionCaught()其将由解码器在帧超出指定的大小限制时抛出。有些协议如HTTP可能有对应的操作，比如返回一个响应，但大部分选择都是关闭连接。</li>
<li>Codec结尾的编解码器是双向的。ByteToMessageCodec。我觉得，从这来看，发送的消息不一定要是个实体，以字节的形式发送，然后用ReplayingDecoder解决沾包拆包，最后接受方把收到的字节解析成实体，或许是更好的方式？</li>
<li><p>CombinedChannelDuplexHandler通过提供分别继承了解码器类和编码器类的类型，我们可以实现一个编解码器，而又不必直接扩展抽象的编解码器类。这样意义在于提高重用性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CombinedByteCharCodec extends</span><br><span class="line">CombinedChannelDuplexHandler&lt;ByteToCharDecoder, CharToByteEncoder&gt; &#123;</span><br><span class="line">  public CombinedByteCharCodec() &#123;</span><br><span class="line">      super(new ByteToCharDecoder(), new CharToByteEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>支持SSl/TSL非常简单，继承ChannelInitializer，把jdk的（或者netty的性能更好的）Handler加载pipeline的首位即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void initChannel(Channel ch) throws Exception &#123;</span><br><span class="line">  SSLEngine engine = context.newEngine(ch.alloc());</span><br><span class="line">  ch.pipeline().addFirst(&quot;ssl&quot;,</span><br><span class="line">  new SslHandler(engine, startTls));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP的支持同样简单，http+response/request+encoder/decoder,四种编解码器。此外还应该用聚合器HttpObjectAggregator来聚合消息，用服务器用压缩器HttpContentCompressor()压缩，客户端用HttpContentDecompressor()解压。</p>
</li>
<li><p>对websocket的支持也是通过Handler实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(</span><br><span class="line">        new HttpServerCodec(),</span><br><span class="line">        new HttpObjectAggregator(65536), //聚合</span><br><span class="line">        new WebSocketServerProtocolHandler(&quot;/websocket&quot;),//如果被请求 HttpRequest的端点是&quot;/websocket&quot;，则处理该升级握手</span><br><span class="line">        new TextFrameHandler(),//自己完成三种不同的数据帧处理器，来处理不同的websocket数据</span><br><span class="line">        new BinaryFrameHandler(),</span><br><span class="line">        new ContinuationFrameHandler());</span><br></pre></td></tr></table></figure>
</li>
<li><p>IdleStateHandler处理心跳和超时,当连接空闲时间太长时，将会触发一个 IdleStateEvent 事件。然后，你可以通过在你的 ChannelInboundHandler 中重写 userEventTriggered()方法来处理该IdleStateEvent 事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">        if(evt instanceof IdleStateEvent) &#123; //发送心跳消息，并在发送失败时关闭该连接</span><br><span class="line">            ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate()).addListener(</span><br><span class="line">                    ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            super.userEventTriggered(ctx, evt);//不是 IdleStateEvent事件，所以将它传递给下一个 ChannelInboundHandler</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此外还有ReadTimeoutHandler和WriteTimeoutHandler，他们会抛异常，捕获异常处理超时。</p>
<ol start="10">
<li>FileRegion写文件等大型数据,可以直接往channel里面写入一个FileRegion对象，而不需要相应的encoder,比如ch.write(region); 。在需要将数据从文件系统复制到用户内存中时，可以使用 ChunkedWriteHandler,要使用你自己的 ChunkedInput 实现，需要在 ChannelPipeline 中安装一个ChunkedWriteHandler。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final FileRegion region =  new DefaultFileRegion(raf.getChannel(), 0, fileLength);  </span><br><span class="line">ch.write(region);  </span><br><span class="line">@Override</span><br><span class="line">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">  super.channelActive(ctx);</span><br><span class="line">  ctx.writeAndFlush(new ChunkedStream(new FileInputStream(file)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/30/11-30技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/30/11-30技术笔记/" itemprop="url">redis高阶数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-30T15:50:23+08:00">
                2018-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>数据是布尔类型的时候，进行记录可以使用位图，即每个数据占一位而不是一字节。最简单的使用场景就是签到表啦。还有在线人数统计之内。<br>我看来，位图实际上是三维的，key,value,exist,所以很适合做签到这种事，因为也是三维的：用户，日期，是否签到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.setbit(offsetDate, user_id, 1);</span><br></pre></td></tr></table></figure></p>
<p>统计也很简单，某天的活跃用户数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String key = offsetDate;</span><br><span class="line">BitSet users = BitSet.valueOf(redis.get(key.getBytes()));</span><br><span class="line">users.cardinality();</span><br></pre></td></tr></table></figure></p>
<p>用BitSet相关计算，第一和第二天的交集，就是首日留存，之类的所有操作。<br>如果交换key,value值的位置，则是反过来统计，比如本月用户签到了多少次，某天用户是否签到。redis-&gt;bitCount($UserID)</p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><ol>
<li>HyperLogLog是去重计数器。比如统计访客数量，简单做法是，一个Set，来一个人就sadd加进集合，要计数就scard数一下集合里多少个。HyperLogLog就是针对这种情况设计的，功能单一，只有 pfadd 和 pfcount，加进去和计数。还有pfmerge合并计数器。   </li>
<li>优势：内部实现靠复杂的数学计算，而不是萝卜占坑，因而存储空间占用很小。   </li>
<li>缺点：其实是估算出来的，存在0.81%，也就是说不到1%的误差。    </li>
<li>使用场景：去重计数。    </li>
<li>原理和使用限制：分桶计数，用到的是 16384 个桶，也就是 2^14，每个桶的 maxbits 需要 6 个 bits 来存储，最大可以表示 maxbits=63，于是总共占用内存就是2^14 * 6 / 8 = 12k字节。即数据量很少也要12k，但适用于大量数据计数。    </li>
</ol>
<h2 id="布隆过滤器Bloom-Filter"><a href="#布隆过滤器Bloom-Filter" class="headerlink" title="布隆过滤器Bloom Filter"></a>布隆过滤器Bloom Filter</h2><ol>
<li>Bloom Filter和HyperLogLog类似，是一个估计工具。相当于节省空间结果粗略的哈希表。与HyperLogLog不同的是，布隆过滤器是查询集合内某元素是否存在。比如说，steam要存储用户的购买记录，很多用户很多购买记录，n个set，每个set也很大。只是想知道用户有没有买过某个游戏。这时可以用Bloom Filter。</li>
<li>它存储的是键值对，bf.add csgo user1，则user1购买了csgo。<br>bf.exists codehole user1，查询user1是否购买了csgo。<br>bf.madd和bf.mexists多值判断和查询</li>
<li>当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。虽然Bloom Filter是估测，但布隆过滤器对于已经见过的元素肯定不会误判，它只会误判那些没见过的元素。把编号1到10000的用户插入，然后再查它们是否存在，答案是都存在，不会有错误，但如果查10001到20000号用户是否存在，并不会回答都不存在，这里有误差，只会回答绝大部分的用户不存在。</li>
<li>自定义参数，可以自定义预计数量和误差范围，显然可知，要求的误差越小，所需要的存储空间越大。比如5万数据，0.1%误差：client.createFilter(“codehole”, 50000, 0.001);</li>
<li>使用的时候一是可以忍受误差的场景，比如说使用爬虫爬取URl,不爬重复的，这时就适合用布隆过滤器，即使有遗漏的，做统计也不要紧；二是利用“如果说不存在，那肯定不存在的特性”，在解决缓存攻击的时候, 也用到了布隆过滤器, 就是不法分子构造缓存中没有的key进行大量请求, 导致大量查询db, 这时候, 如果先在boom中查询一下是不是有这个key就可以抵挡这个攻击。如果布隆过滤器说该行不存在，那肯定不存在。那就不用查了。</li>
</ol>
<h2 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h2><blockquote>
<p><a href="https://www.cnblogs.com/LBSer/p/3310455.html" target="_blank" rel="noopener">https://www.cnblogs.com/LBSer/p/3310455.html</a>     </p>
</blockquote>
<p>理论基础，简单来说，希尔伯特曲线表示，一维曲线可以填满二维空间。这个理论的实际意义在于，将二维的坐标一维表示，这样我们就可以用B树索引了。<br>GeoHash使用看皮亚诺曲线，有突变的问题，解决方法是，不只查这个小正方形区域，还要查它周围的八个正方形。</p>
<ol>
<li>geoadd 指令携带集合名称以及多个经纬度名称三元组，注意这里可以加入多个三元组。简单来说，就是表示(经度，维度，谁)。</li>
<li>geodist 指令可以用来计算两个元素之间的距离，携带集合名称、2 个名称和距离单位。</li>
<li>geopos 指令可以获取集合中任意元素的经纬度坐标，可以一次获取多个。</li>
<li>geohash 可以获取元素的经纬度编码字符串，它是 base32 编码。 可以使用这个编码值直接查到地理位置。比如在<a href="http://geohash.org/" target="_blank" rel="noopener">http://geohash.org/</a></li>
<li><p>georadiusbymember可以用来查询指定元素附近的其它元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//范围 20 公里以内最多 3 个元素按距离倒排</span><br><span class="line">georadiusbymember company ireader 20 km count 3 desc</span><br></pre></td></tr></table></figure>
</li>
<li><p>GeoHash本质是zset，删除点用zset的命令，即zrem。</p>
</li>
</ol>
<h2 id="漏斗限流"><a href="#漏斗限流" class="headerlink" title="漏斗限流"></a>漏斗限流</h2><p>工作中对外提供的API 接口设计都要考虑限流，如果不考虑限流，会成系统的连锁反应，轻者响应缓慢，重者系统宕机，整个业务线崩溃，如何应对这种情况呢，我们可以对请求进行引流或者直接拒绝等操作，保持系统的可用性和稳定性，防止因流量暴增而导致的系统运行缓慢或宕机。<br>把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。即可以累积待处理的服务，但不能累积太多待处理的服务，并且处理速度恒定。</p>
<ol>
<li>在漏斗中没有水的时候：<br>如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，此时，不会积水。<br>如果进水速率大于最大出水速率，那么，漏斗以最大速率出水，此时，多余的水会积在漏斗中</li>
<li>在漏斗中有水的时候：<br>出水口以最大速率出水<br>如果漏斗未满，且有进水的话，那么这些水会积在漏斗中<br>如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外   </li>
</ol>
<p>Redis 4.0 提供了一个限流 Redis 模块，它叫 redis-cell。只有一个指令cl.throttle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; cl.throttle laoqian:reply 15 30 60 #参数分别是，漏斗容量15，每60秒处理30个，need 1 quota (可选参数，默认值也是1)。   </span><br><span class="line">1) (integer) 0   # 0 表示允许，1表示拒绝</span><br><span class="line">2) (integer) 15  # 漏斗容量capacity</span><br><span class="line">3) (integer) 14  # 漏斗剩余空间left_quota</span><br><span class="line">4) (integer) -1  # 如果拒绝了，需要多长时间后再试(漏斗有空间了，单位秒)</span><br><span class="line">5) (integer) 2   # 多长时间后，漏斗完全空出来(left_quota==capacity，单位秒)...</span><br></pre></td></tr></table></figure></p>
<h2 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h2><p>keys 用来列出所有满足特定正则字符串规则的 key，但其一该指令是阻塞的，而且算法复杂度O(n)，数据量太大会使Redis服务卡顿；其二，不支持各种粒度的参数，offset和limit之类。<br>后来提供了另一个的版本scan。通过游标实现，不会阻塞线程，但会带来并发问题。</p>
<ol>
<li>游标分步进行的，不会阻塞线程。</li>
<li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;</li>
<li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;也就是说在使用中，如果要遍历完，需要循环执行，每次将上一次传回的游标值作为参数，进行下一次遍历，知道返回游标为0.</li>
<li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</li>
<li>返回的结果可能会有重复，需要客户端去重复，这点非常重要;</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/14/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/blog/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/23/">23</a><a class="extend next" rel="next" href="/blog/page/16/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Arvense</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">228</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/blog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>


  
</div>


  <div class="powered-by">Powered by <a>Arvense</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">blog   </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
