<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Arvense, NexT">





  <link rel="alternate" href="/blog/atom.xml" title="Arvense" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Arvense">
<meta property="og:url" content="http://yoursite.com/blog/page/11/index.html">
<meta property="og:site_name" content="Arvense">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Arvense">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/blog/page/11/">





  <title>Arvense</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Arvense</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/23/11-23技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/23/11-23技术笔记/" itemprop="url">netty心跳检测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-23T15:28:24+08:00">
                2018-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h2><p>连接假死的现象是：在某一端（服务端或者客户端）看来，底层的 TCP 连接已经断开了，但是应用程序并没有捕获到，因此会认为这条连接仍然是存在的，从 TCP 层面来说，只有收到四次握手数据包或者一个 RST 数据包，连接的状态才表示已断开。</p>
<h2 id="服务端心跳检测"><a href="#服务端心跳检测" class="headerlink" title="服务端心跳检测"></a>服务端心跳检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class IMIdleStateHandler extends IdleStateHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final int READER_IDLE_TIME = 15;</span><br><span class="line"></span><br><span class="line">    public IMIdleStateHandler() &#123;</span><br><span class="line">        super(READER_IDLE_TIME, 0, 0, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) &#123;</span><br><span class="line">        System.out.println(READER_IDLE_TIME + &quot;秒内未读到数据，关闭连接&quot;);</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>IMIdleStateHandler 的构造函数，他调用父类 IdleStateHandler 的构造函数，有四个参数，其中第一个表示读空闲时间，指的是在这段时间内如果没有数据读到，就表示连接假死；第二个是写空闲时间，指的是 在这段时间如果没有写数据，就表示连接假死；第三个参数是读写空闲时间，表示在这段时间内如果没有产生数据读或者写，就表示连接假死。写空闲和读写空闲为0，表示我们不关心者两类条件；最后一个参数表示时间单位。在我们的例子中，表示的是：如果 15 秒内没有读到数据，就表示连接假死。</li>
<li>连接假死之后会回调 channelIdle() 方法，我们这个方法里面打印消息，并手动关闭连接。</li>
<li>该handler需要插入在pipeline的最前面，是因为如果插入到最后面的话，如果这条连接读到了数据，但是在 inBound 传播的过程中出错了或者数据处理完完毕就不往后传递了（我们的应用程序属于这类），那么最终 IMIdleStateHandler 就不会读到数据，最终导致误判。<h2 id="客户端发送心跳"><a href="#客户端发送心跳" class="headerlink" title="客户端发送心跳"></a>客户端发送心跳</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HeartBeatTimerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private static final int HEARTBEAT_INTERVAL = 5;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        scheduleSendHeartBeat(ctx);</span><br><span class="line"></span><br><span class="line">        super.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void scheduleSendHeartBeat(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        ctx.executor().schedule(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            if (ctx.channel().isActive()) &#123;</span><br><span class="line">                ctx.writeAndFlush(new HeartBeatRequestPacket());</span><br><span class="line">                scheduleSendHeartBeat(ctx);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, HEARTBEAT_INTERVAL, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>ctx.executor() 返回的是当前的 channel 绑定的 NIO 线程，然后，NIO 线程有一个方法，schedule()，类似 jdk 的延时任务机制，可以隔一段时间之后执行一个任务，而我们这边是实现了每隔 5 秒，向服务端发送一个心跳数据包，这个时间段通常要比服务端的空闲检测时间的一半要短一些，我们这里直接定义为空闲检测时间的三分之一，主要是为了排除公网偶发的秒级抖动。</p>
<h2 id="服务端响应心跳"><a href="#服务端响应心跳" class="headerlink" title="服务端响应心跳"></a>服务端响应心跳</h2><p>服务端无需主动发送心跳，只需向客户端发送，我已经接收到了心跳的消息即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/21/失望的游戏《倩女幽魂》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/21/失望的游戏《倩女幽魂》/" itemprop="url">失望的游戏《倩女幽魂》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-21T19:21:33+08:00">
                2018-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于买了新手机，全面屏看起来很适合玩MMO游戏，由于最近没有新出的，找了一款老游戏《倩女幽魂》。<br>其实期望还是有一点的，因为之前玩手游吃鸡和QQ飞车，游戏好不好玩不论，硬件品质相当不错。<br>但这款游戏打开的第一秒，我就想弃游了，不是进入游戏的第一秒，是打开的第一秒。还在载入界面，那“正在加载资源”的字体设计，下方资源载入进度的进度条UI设计，这真的是前年的游戏吗？？？<br>讲真，页游的美工都比他有心。具体我不懂美术不是吐槽从何吐起，但给我的感受不是丑，而是没有设计。<br>至于游戏玩法，没细玩，页游套路，自动接任务，自动寻路，自动打怪，自动交任务。没细的原因是，一进游戏就有三四个骗子加我，套路都是进群，然后号称帮会要去新服，让我下载apk，apk名字就叫“渠道统一倩女幽魂之类”。我也不知道下了之后怎么样，这套路怎么发展的，反正肯定骗子比游戏好玩，于是便弃游了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/21/11-21技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/21/11-21技术笔记/" itemprop="url">netty实现群聊</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-21T14:09:04+08:00">
                2018-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="建群"><a href="#建群" class="headerlink" title="建群"></a>建群</h1><p>群聊首先需要一个群，服务端保存群ID和群里成员的ID的映射，有人说话，需要指明哪个群，这样，服务端把这个消息转发给该群里的所有人。</p>
<h2 id="客户端构建"><a href="#客户端构建" class="headerlink" title="客户端构建"></a>客户端构建</h2><p>如果客户端可用指令较多，简陋的设计是，先输入指令，然后判断指令，根据指令类型进行相应数据包处理。这里可以采用策略模式，根据指令选择处理方式。</p>
<h3 id="指令基类"><a href="#指令基类" class="headerlink" title="指令基类"></a>指令基类</h3><p>思考下指令里应该有什么，是输入的内容，以及channel。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ConsoleCommand &#123;</span><br><span class="line">    void exec(Scanner scanner, Channel channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="具体指令类"><a href="#具体指令类" class="headerlink" title="具体指令类"></a>具体指令类</h3><p>有多少具体功能，应该就有多少具体指令类，里面是业务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CreateGroupConsoleCommand implements ConsoleCommand &#123;</span><br><span class="line"></span><br><span class="line">    private static final String USER_ID_SPLITER = &quot;,&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exec(Scanner scanner, Channel channel) &#123;</span><br><span class="line">        CreateGroupRequestPacket createGroupRequestPacket = new CreateGroupRequestPacket();</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;【拉人群聊】输入 userId 列表，userId 之间英文逗号隔开：&quot;);</span><br><span class="line">        String userIds = scanner.next();</span><br><span class="line">        createGroupRequestPacket.setUserIdList(Arrays.asList(userIds.split(USER_ID_SPLITER)));</span><br><span class="line">        channel.writeAndFlush(createGroupRequestPacket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="指令管理类"><a href="#指令管理类" class="headerlink" title="指令管理类"></a>指令管理类</h3><p>储存着指令名和指令的映射，使用时根据指令名选择到指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ConsoleCommandManager implements ConsoleCommand &#123;</span><br><span class="line">    private Map&lt;String, ConsoleCommand&gt; consoleCommandMap;</span><br><span class="line"></span><br><span class="line">    public ConsoleCommandManager() &#123;</span><br><span class="line">        consoleCommandMap = new HashMap&lt;&gt;();</span><br><span class="line">        consoleCommandMap.put(&quot;sendToUser&quot;, new SendToUserConsoleCommand());</span><br><span class="line">        consoleCommandMap.put(&quot;logout&quot;, new LogoutConsoleCommand());</span><br><span class="line">        consoleCommandMap.put(&quot;createGroup&quot;, new CreateGroupConsoleCommand());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exec(Scanner scanner, Channel channel) &#123;</span><br><span class="line">        //  获取第一个指令</span><br><span class="line">        String command = scanner.next();</span><br><span class="line"></span><br><span class="line">        ConsoleCommand consoleCommand = consoleCommandMap.get(command);</span><br><span class="line"></span><br><span class="line">        if (consoleCommand != null) &#123;</span><br><span class="line">            consoleCommand.exec(scanner, channel);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.err.println(&quot;无法识别[&quot; + command + &quot;]指令，请重新输入!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="客户端控制台"><a href="#客户端控制台" class="headerlink" title="客户端控制台"></a>客户端控制台</h3><p>在连接成功后，启动控制台即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static void startConsoleThread(Channel channel) &#123;</span><br><span class="line">    ConsoleCommandManager consoleCommandManager = new ConsoleCommandManager();</span><br><span class="line">    LoginConsoleCommand loginConsoleCommand = new LoginConsoleCommand();</span><br><span class="line">    Scanner scanner = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        while (!Thread.interrupted()) &#123;</span><br><span class="line">            if (!SessionUtil.hasLogin(channel)) &#123;</span><br><span class="line">                loginConsoleCommand.exec(scanner, channel);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                consoleCommandManager.exec(scanner, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="群聊请求数据包"><a href="#群聊请求数据包" class="headerlink" title="群聊请求数据包"></a>群聊请求数据包</h3><p>建立一个群聊，只需要建群的人的ID列表即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class CreateGroupRequestPacket extends Packet &#123;</span><br><span class="line">    private List&lt;String&gt; userIdList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="客户端处理创建群聊响应"><a href="#客户端处理创建群聊响应" class="headerlink" title="客户端处理创建群聊响应"></a>客户端处理创建群聊响应</h3><p>建群请求数据包发给服务端后，服务端返回成功失败信息。客户端处理。显然也是需要一个handler，加到pipeline中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CreateGroupResponseHandler extends SimpleChannelInboundHandler&lt;CreateGroupResponsePacket&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, CreateGroupResponsePacket createGroupResponsePacket) &#123;</span><br><span class="line">        System.out.print(&quot;群创建成功，id 为[&quot; + createGroupResponsePacket.getGroupId() + &quot;], &quot;);</span><br><span class="line">        System.out.println(&quot;群里面有：&quot; + createGroupResponsePacket.getUserNameList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="服务端处理"><a href="#服务端处理" class="headerlink" title="服务端处理"></a>服务端处理</h2><p>显然需要添加一个处理群聊请求数据包的Handler<br><strong>ChannelGroup</strong> 就是一组Channel，对外暴露方式和Channel一样，并且实现了Set接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CreateGroupRequestHandler extends SimpleChannelInboundHandler&lt;CreateGroupRequestPacket&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, CreateGroupRequestPacket createGroupRequestPacket) &#123;</span><br><span class="line">        List&lt;String&gt; userIdList = createGroupRequestPacket.getUserIdList();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; userNameList = new ArrayList&lt;&gt;();</span><br><span class="line">        // 1. 创建一个 channel 分组</span><br><span class="line">        ChannelGroup channelGroup = new DefaultChannelGroup(ctx.executor());</span><br><span class="line"></span><br><span class="line">        // 2. 筛选出待加入群聊的用户的 channel 和 userName</span><br><span class="line">        for (String userId : userIdList) &#123;</span><br><span class="line">            Channel channel = SessionUtil.getChannel(userId);</span><br><span class="line">            if (channel != null) &#123;</span><br><span class="line">                channelGroup.add(channel);</span><br><span class="line">                userNameList.add(SessionUtil.getSession(channel).getUserName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 创建群聊创建结果的响应</span><br><span class="line">        CreateGroupResponsePacket createGroupResponsePacket = new CreateGroupResponsePacket();</span><br><span class="line">        createGroupResponsePacket.setSuccess(true);</span><br><span class="line">        createGroupResponsePacket.setGroupId(IDUtil.randomId());</span><br><span class="line">        createGroupResponsePacket.setUserNameList(userNameList);</span><br><span class="line"></span><br><span class="line">        // 4. 给每个客户端发送拉群通知</span><br><span class="line">        channelGroup.writeAndFlush(createGroupResponsePacket);</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;群创建成功，id 为[&quot; + createGroupResponsePacket.getGroupId() + &quot;], &quot;);</span><br><span class="line">        System.out.println(&quot;群里面有：&quot; + createGroupResponsePacket.getUserNameList());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="群成员管理"><a href="#群成员管理" class="headerlink" title="群成员管理"></a>群成员管理</h1><h2 id="加群"><a href="#加群" class="headerlink" title="加群"></a>加群</h2><h3 id="客户端加群指令"><a href="#客户端加群指令" class="headerlink" title="客户端加群指令"></a>客户端加群指令</h3><p>加一个指令后，CommandManager也应该改变，加一下这个映射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class JoinGroupConsoleCommand implements ConsoleCommand &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void exec(Scanner scanner, Channel channel) &#123;</span><br><span class="line">        JoinGroupRequestPacket joinGroupRequestPacket = new JoinGroupRequestPacket();</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;输入 groupId，加入群聊：&quot;);</span><br><span class="line">        String groupId = scanner.next();</span><br><span class="line"></span><br><span class="line">        joinGroupRequestPacket.setGroupId(groupId);</span><br><span class="line">        channel.writeAndFlush(joinGroupRequestPacket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="服务端处理加群"><a href="#服务端处理加群" class="headerlink" title="服务端处理加群"></a>服务端处理加群</h3><p>增加一个handler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class JoinGroupRequestHandler extends SimpleChannelInboundHandler&lt;JoinGroupRequestPacket&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, JoinGroupRequestPacket requestPacket) &#123;</span><br><span class="line">        // 1. 获取群对应的 channelGroup，然后将当前用户的 channel 添加进去</span><br><span class="line">        String groupId = requestPacket.getGroupId();</span><br><span class="line">        ChannelGroup channelGroup = SessionUtil.getChannelGroup(groupId);</span><br><span class="line">        channelGroup.add(ctx.channel());</span><br><span class="line"></span><br><span class="line">        // 2. 构造加群响应发送给客户端</span><br><span class="line">        JoinGroupResponsePacket responsePacket = new JoinGroupResponsePacket();</span><br><span class="line"></span><br><span class="line">        responsePacket.setSuccess(true);</span><br><span class="line">        responsePacket.setGroupId(groupId);</span><br><span class="line">        ctx.channel().writeAndFlush(responsePacket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="客户端响应响应"><a href="#客户端响应响应" class="headerlink" title="客户端响应响应"></a>客户端响应响应</h3><p>没啥好说的，增加一个handler,打印服务端传回的信息即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class JoinGroupResponseHandler extends SimpleChannelInboundHandler&lt;JoinGroupResponsePacket&gt; &#123;</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, JoinGroupResponsePacket responsePacket) &#123;</span><br><span class="line">        if (responsePacket.isSuccess()) &#123;</span><br><span class="line">            System.out.println(&quot;加入群[&quot; + responsePacket.getGroupId() + &quot;]成功!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.err.println(&quot;加入群[&quot; + responsePacket.getGroupId() + &quot;]失败，原因为：&quot; + responsePacket.getReason());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="退群"><a href="#退群" class="headerlink" title="退群"></a>退群</h2><p>其实和加群没啥区别，调用channelGroup.remove(ctx.channel());从ChannelGroup中删除当前channel即可。还可以踢人，从映射中拿到指定的channel，然后remove就好。</p>
<h2 id="获取群成员列表"><a href="#获取群成员列表" class="headerlink" title="获取群成员列表"></a>获取群成员列表</h2><p>其实和退群区别也不大，客户端新加指令，服务端先从SessionUtil中保存的GroupID和ChannelGroup映射中取出ChannelGroup，因为ChannelGroup实现了Set接口，直接foreach循环遍历所有的channel，从SessionUtil中保存的ID和Channel的映射中找到ID，这些ID就是群成员了。</p>
<h1 id="发送群消息"><a href="#发送群消息" class="headerlink" title="发送群消息"></a>发送群消息</h1><p>同样，通过groupID获得ChannelGroup，然后构造转发的消息包，channelGroup.writeAndFlush(responsePacket);转发即可。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="单例模式与handler"><a href="#单例模式与handler" class="headerlink" title="单例模式与handler"></a>单例模式与handler</h2><p>什么时候可以用单例模式呢，考察标准是 <strong>“无状态”</strong> ，即内部没有成员变量。或者说它的成员变量也是无状态的。换句话说，有状态对象可以保存数据，不是线程安全的，无状态对象反过来。<br>实际上，我们写的所有handler都是无状态的，在每一个连接pipeline中，都new了一个handler，实际上不需要，这里可以用单例模式，所有的连接用同一个单例即可。<br>@ChannelHandler.Sharable注解表示告诉netty，该handler是单例的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class LoginRequestHandler extends SimpleChannelInboundHandler&lt;LoginRequestPacket&gt; &#123;</span><br><span class="line">        //私有静态内部类实现单例</span><br><span class="line">        private static class SingletonHolder &#123;</span><br><span class="line">            private static final LoginRequestHandler INSTANCE = new LoginRequestHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        private LoginRequestHandler ()&#123;&#125;</span><br><span class="line">        public static final LoginRequestHandler getInstance() &#123;</span><br><span class="line">            return SingletonHolder.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestPacket loginRequestPacket) &#123;</span><br><span class="line">      //业务</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="合并编解码器"><a href="#合并编解码器" class="headerlink" title="合并编解码器"></a>合并编解码器</h2><p>Netty 内部提供了一个类，叫做 MessageToMessageCodec，使用它可以让我们的编解码操作放到一个类里面去实现，没啥好说的，就是编解码加起来，同样它也是无状态的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class PacketCodecHandler extends MessageToMessageCodec&lt;ByteBuf, Packet&gt; &#123;</span><br><span class="line">    private static class PacketCodecHandlerHolder &#123;</span><br><span class="line">        private static final PacketCodecHandler INSTASNSE = new PacketCodecHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    private PacketCodecHandler()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static PacketCodecHandler getInstance()&#123;</span><br><span class="line">        return PacketCodecHandlerHolder.INSTASNSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; out) &#123;</span><br><span class="line">        out.add(PacketCodec.INSTANCE.decode(byteBuf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void encode(ChannelHandlerContext ctx, Packet packet, List&lt;Object&gt; out) &#123;</span><br><span class="line">        ByteBuf byteBuf = ctx.channel().alloc().ioBuffer();</span><br><span class="line">        PacketCodec.INSTANCE.encode(byteBuf, packet);</span><br><span class="line">        out.add(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="策略模式处理平行的Handler"><a href="#策略模式处理平行的Handler" class="headerlink" title="策略模式处理平行的Handler"></a>策略模式处理平行的Handler</h2><p>有些Handler不会同时发生，只会n选一，这里可以用策略模式，合并它们，根据需求调用。这样pipeline中只需要一个IMhandler。而IMHandler从其映射中存储的Handler，调用他们的对应函数即可。<br>netty对此有所提供，因为channelRead0方法是protected的，无法在IMHandler中调用对应Handler的channelRead0方法，netty在SimpleChannelInboundHandler提供了channelRead方法，该方法内部调用了对应Handler的channelRead0()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class IMHandler extends SimpleChannelInboundHandler&lt;Packet&gt; &#123;</span><br><span class="line">    public static final IMHandler INSTANCE = new IMHandler();</span><br><span class="line"></span><br><span class="line">    private Map&lt;Byte, SimpleChannelInboundHandler&lt;? extends Packet&gt;&gt; handlerMap;</span><br><span class="line"></span><br><span class="line">    private IMHandler() &#123;</span><br><span class="line">        handlerMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        handlerMap.put(MESSAGE_REQUEST, MessageRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(CREATE_GROUP_REQUEST, CreateGroupRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(JOIN_GROUP_REQUEST, JoinGroupRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(QUIT_GROUP_REQUEST, QuitGroupRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(LIST_GROUP_MEMBERS_REQUEST, ListGroupMembersRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(GROUP_MESSAGE_REQUEST, GroupMessageRequestHandler.INSTANCE);</span><br><span class="line">        handlerMap.put(LOGOUT_REQUEST, LogoutRequestHandler.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, Packet packet) throws Exception &#123;</span><br><span class="line">        handlerMap.get(packet.getCommand()).channelRead(ctx, packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/20/11-20技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/20/11-20技术笔记/" itemprop="url">netty实现单聊</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-20T14:47:23+08:00">
                2018-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h1><p>单聊不可能是一个人是服务端一个人是客户端，而应该是两个人都是客户端，把信息发送给同一个服务端，由服务端进行信息处理和转发。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>服务端里保存了客户端的session信息，用来找到收信人。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Session &#123;</span><br><span class="line">    // 用户唯一性标识</span><br><span class="line">    private String userId;</span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    public Session(String userId, String userName) &#123;</span><br><span class="line">        this.userId = userId;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return userId + &quot;:&quot; + userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对session的管理主要是管理用户和channel的映射，和channel中自设的session属性。前者用来找个用户对应的channel，后者用来验证登陆状况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class SessionUtil &#123;</span><br><span class="line">    private static final Map&lt;String, Channel&gt; userIdChannelMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void bindSession(Session session, Channel channel) &#123;</span><br><span class="line">        userIdChannelMap.put(session.getUserId(), channel);</span><br><span class="line">        channel.attr(Attributes.SESSION).set(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void unBindSession(Channel channel) &#123;</span><br><span class="line">        if (hasLogin(channel)) &#123;</span><br><span class="line">            userIdChannelMap.remove(getSession(channel).getUserId());</span><br><span class="line">            channel.attr(Attributes.SESSION).set(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean hasLogin(Channel channel) &#123;</span><br><span class="line"></span><br><span class="line">        return channel.hasAttr(Attributes.SESSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Session getSession(Channel channel) &#123;</span><br><span class="line"></span><br><span class="line">        return channel.attr(Attributes.SESSION).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Channel getChannel(String userId) &#123;</span><br><span class="line"></span><br><span class="line">        return userIdChannelMap.get(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>新起一个控制台线程，如果没有登录，则发送登录数据包；如果登录了，则发送消息包即可。这样一来，客户端发送的消息，不但有消息的内容，还要指定消息发送给谁，即消息数据包里应该多一条目的人的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class MessageRequestPacket extends Packet &#123;</span><br><span class="line">    private String toUserId;</span><br><span class="line">    private String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体控制台代码,连接成功后，调用该函数即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private static void startConsoleThread(Channel channel) &#123;</span><br><span class="line">       Scanner sc = new Scanner(System.in);</span><br><span class="line">       LoginRequestPacket loginRequestPacket = new LoginRequestPacket();</span><br><span class="line"></span><br><span class="line">       new Thread(() -&gt; &#123;</span><br><span class="line">           while (!Thread.interrupted()) &#123;</span><br><span class="line">               if (!SessionUtil.hasLogin(channel)) &#123;</span><br><span class="line">                   System.out.print(&quot;输入用户名登录: &quot;);</span><br><span class="line">                   String username = sc.nextLine();</span><br><span class="line">                   loginRequestPacket.setUserName(username);</span><br><span class="line"></span><br><span class="line">                   // 密码使用默认的</span><br><span class="line">                   loginRequestPacket.setPassword(&quot;pwd&quot;);</span><br><span class="line"></span><br><span class="line">                   // 发送登录数据包</span><br><span class="line">                   channel.writeAndFlush(loginRequestPacket);</span><br><span class="line">                   waitForLoginResponse();</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   String toUserId = sc.next();</span><br><span class="line">                   String message = sc.next();</span><br><span class="line">                   channel.writeAndFlush(new MessageRequestPacket(toUserId, message));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   private static void waitForLoginResponse() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           Thread.sleep(1000);</span><br><span class="line">       &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>服务端处理登录，就是接受到登录数据包后，验证账号密码，找到UserID，然后响应登录即可。还有一点，当连接断开，需要取消session的绑定。（重载 channelInactive(ChannelHandlerContext ctx)方法）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class LoginRequestHandler extends SimpleChannelInboundHandler&lt;LoginRequestPacket&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestPacket loginRequestPacket) &#123;</span><br><span class="line">        LoginResponsePacket loginResponsePacket = new LoginResponsePacket();</span><br><span class="line">        loginResponsePacket.setVersion(loginRequestPacket.getVersion());</span><br><span class="line">        loginResponsePacket.setUserName(loginRequestPacket.getUserName());</span><br><span class="line"></span><br><span class="line">        if (valid(loginRequestPacket)) &#123;</span><br><span class="line">            loginResponsePacket.setSuccess(true);</span><br><span class="line">            String userId = randomUserId();</span><br><span class="line">            loginResponsePacket.setUserId(userId);</span><br><span class="line">            System.out.println(&quot;[&quot; + loginRequestPacket.getUserName() + &quot;]登录成功&quot;);</span><br><span class="line">            SessionUtil.bindSession(new Session(userId, loginRequestPacket.getUserName()), ctx.channel());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            loginResponsePacket.setReason(&quot;账号密码校验失败&quot;);</span><br><span class="line">            loginResponsePacket.setSuccess(false);</span><br><span class="line">            System.out.println(new Date() + &quot;: 登录失败!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 登录响应</span><br><span class="line">        ctx.channel().writeAndFlush(loginResponsePacket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean valid(LoginRequestPacket loginRequestPacket) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String randomUserId() &#123;</span><br><span class="line">        return UUID.randomUUID().toString().split(&quot;-&quot;)[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        SessionUtil.unBindSession(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>服务端处理消息，找到对应channel，然后转发即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MessageRequestHandler extends SimpleChannelInboundHandler&lt;MessageRequestPacket&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, MessageRequestPacket messageRequestPacket) &#123;</span><br><span class="line">        // 1.拿到消息发送方的会话信息</span><br><span class="line">        Session session = SessionUtil.getSession(ctx.channel());</span><br><span class="line"></span><br><span class="line">        // 2.通过消息发送方的会话信息构造要发送的消息</span><br><span class="line">        MessageResponsePacket messageResponsePacket = new MessageResponsePacket();</span><br><span class="line">        messageResponsePacket.setFromUserId(session.getUserId());</span><br><span class="line">        messageResponsePacket.setFromUserName(session.getUserName());</span><br><span class="line">        messageResponsePacket.setMessage(messageRequestPacket.getMessage());</span><br><span class="line"></span><br><span class="line">        // 3.拿到消息接收方的 channel</span><br><span class="line">        Channel toUserChannel = SessionUtil.getChannel(messageRequestPacket.getToUserId());</span><br><span class="line"></span><br><span class="line">        // 4.将消息发送给消息接收方</span><br><span class="line">        if (toUserChannel != null &amp;&amp; SessionUtil.hasLogin(toUserChannel)) &#123;</span><br><span class="line">            toUserChannel.writeAndFlush(messageResponsePacket);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.err.println(&quot;[&quot; + messageRequestPacket.getToUserId() + &quot;] 不在线，发送失败);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h2><p>很简单，接收消息即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MessageResponseHandler extends SimpleChannelInboundHandler&lt;MessageResponsePacket&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, MessageResponsePacket messageResponsePacket) &#123;</span><br><span class="line">        String fromUserId = messageResponsePacket.getFromUserId();</span><br><span class="line">        String fromUserName = messageResponsePacket.getFromUserName();</span><br><span class="line">        System.out.println(fromUserId + &quot;:&quot; + fromUserName + &quot; -&gt; &quot; + messageResponsePacket</span><br><span class="line">                .getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/19/11-19技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/19/11-19技术笔记/" itemprop="url">pipeline及相关组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-19T14:31:20+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们通过 if else 逻辑进行逻辑的处理，当我们要处理的指令越来越多的时候，代码会显得越来越臃肿，我们可以通过给 pipeline 添加多个 handler(ChannelInboundHandlerAdapter的子类) 来解决。</p>
<h2 id="SimpleChannelInboundHandler"><a href="#SimpleChannelInboundHandler" class="headerlink" title="SimpleChannelInboundHandler"></a>SimpleChannelInboundHandler</h2><p>SimpleChannelInboundHandler 对象，类型判断和对象传递的活都自动帮我们实现了，而我们可以专注于处理我们所关心的指令即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//SimpleChannelInboundHandler是泛型，类型是该处理器所处理的消息包</span><br><span class="line">public class LoginRequestHandler extends SimpleChannelInboundHandler&lt;LoginRequestPacket&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestPacket loginRequestPacket) &#123;</span><br><span class="line">        // 无返回值函数，不用传递对象，基类已经实现，只用关心逻辑。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ByteToMessageDecoder"><a href="#ByteToMessageDecoder" class="headerlink" title="ByteToMessageDecoder"></a>ByteToMessageDecoder</h2><p>当我们继承了 ByteToMessageDecoder 这个类之后，我们只需要实现一下 decode() 方法，这里的 in ，传递进来的时候就已经是 ByteBuf 类型，所以我们不再需要强转，第三个参数是 List 类型，通过往这个 List 里面添加解码后的结果对象，就可以自动实现结果往下一个 handler 进行传递，这样就实现了解码的逻辑 handler。<br>最大的优点是，自动内存管理，因为ByteBuf是堆外的，自动内存管理不用担心内存泄漏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PacketDecoder extends ByteToMessageDecoder &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List out) &#123;</span><br><span class="line">        out.add(PacketCodeC.INSTANCE.decode(in));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="MessageToByteEncoder"><a href="#MessageToByteEncoder" class="headerlink" title="MessageToByteEncoder"></a>MessageToByteEncoder</h2><p>编码同样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PacketEncoder extends MessageToByteEncoder&lt;Packet&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void encode(ChannelHandlerContext ctx, Packet packet, ByteBuf out) &#123;</span><br><span class="line">        PacketCodeC.INSTANCE.encode(out, packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PacketEncoder 继承自 MessageToByteEncoder，泛型参数 Packet 表示这个类的作用是实现 Packet 类型对象到二进制的转换。</p>
<p>这里我们只需要实现 encode() 方法，我们注意到，在这个方法里面，第二个参数是 Java 对象，而第三个参数是 ByteBuf 对象，我们在这个方法里面要做的事情就是把 Java 对象里面的字段写到 ByteBuf，我们不再需要自行去分配 ByteBuf。<br>所以编码器也需要变化，编码器里不需要管理ByteBuf,不需要新建和返回ByteBuf（而是作为参数），只需要关注编码即可。</p>
<h2 id="ChannelInboundHandlerAdapter-与-ChannelOutboundHandlerAdapter"><a href="#ChannelInboundHandlerAdapter-与-ChannelOutboundHandlerAdapter" class="headerlink" title="ChannelInboundHandlerAdapter 与 ChannelOutboundHandlerAdapter"></a>ChannelInboundHandlerAdapter 与 ChannelOutboundHandlerAdapter</h2><p>一个是进一个是出，各自保持一致即可。</p>
<h2 id="热插拔与身份校验"><a href="#热插拔与身份校验" class="headerlink" title="热插拔与身份校验"></a>热插拔与身份校验</h2><p>可以把身份验证逻辑独立出来，通信时身份验证，实际上，在连接中，只需要第一次需要身份验证，这时pipeline的热插拔机制就有效了。 ctx.pipeline().remove(this);移除自身即可，同时可以重载handlerRemoved()方法，在handler被移除时触发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class AuthHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        if (!LoginUtil.hasLogin(ctx.channel())) &#123;</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 一行代码实现逻辑的删除</span><br><span class="line">            ctx.pipeline().remove(this);</span><br><span class="line">            super.channelRead(ctx, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRemoved(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        if (LoginUtil.hasLogin(ctx.channel())) &#123;</span><br><span class="line">            System.out.println(&quot;当前连接登录验证完毕，无需再次验证, AuthHandler 被移除&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;无登录验证，强制关闭连接!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="沾包拆包组件"><a href="#沾包拆包组件" class="headerlink" title="沾包拆包组件"></a>沾包拆包组件</h2><p>tcp报文与我们的数据包不一定一样大，导致Netty 应用层面，重新拼装成的ByteBuf与客户端按顺序发送的 ByteBuf 可能是不对等的。解决很简单，就是检测数据包，是一个完整包再解析，手写也不难。Netty封装了四种拆包器handler，分别对应四种不同的数据包：固定大小的；按分隔符分隔的；按行分隔的；数据包头部有该数据包长度的。只需要把它加入到pipeLine中即可。<br>对于最后一种LengthFieldBasedFrameDecoder，有三个参数：第一个参数指的是数据包的最大长度，第二个参数指的是长度域的偏移量，第三个参数指的是长度域的长度，这样一个拆包器写好之后，只需要在 pipeline 的最前面加上这个拆包器。</p>
<p>我们在拆包时，可以再做点别的事，比如屏蔽非本协议的数据包，继承该类，重写decode()方法，在该方法中如果协议不对，连接关闭即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Spliter extends LengthFieldBasedFrameDecoder &#123;</span><br><span class="line">    private static final int LENGTH_FIELD_OFFSET = 7;</span><br><span class="line">    private static final int LENGTH_FIELD_LENGTH = 4;</span><br><span class="line"></span><br><span class="line">    public Spliter() &#123;</span><br><span class="line">        super(Integer.MAX_VALUE, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception &#123;</span><br><span class="line">        // 屏蔽非本协议的客户端</span><br><span class="line">        if (in.getInt(in.readerIndex()) != PacketCodeC.MAGIC_NUMBER) &#123;</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.decode(ctx, in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h2><p>最后pipeline中有如下组件：拆包及过滤，解码，业务处理，编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                        ch.pipeline().addLast(new Spliter());</span><br><span class="line">                        ch.pipeline().addLast(new PacketDecoder());</span><br><span class="line">                        ch.pipeline().addLast(new LoginResponseHandler());</span><br><span class="line">                        ch.pipeline().addLast(new MessageResponseHandler());</span><br><span class="line">                        ch.pipeline().addLast(new PacketEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/16/11-16技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/16/11-16技术笔记/" itemprop="url">双端通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-16T15:33:35+08:00">
                2018-11-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="通讯基础"><a href="#通讯基础" class="headerlink" title="通讯基础"></a>通讯基础</h1><h2 id="编码解码和序列化"><a href="#编码解码和序列化" class="headerlink" title="编码解码和序列化"></a>编码解码和序列化</h2><h3 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package the.flash.protocol;</span><br><span class="line"></span><br><span class="line">import io.netty.buffer.ByteBuf;</span><br><span class="line">import io.netty.buffer.ByteBufAllocator;</span><br><span class="line">import the.flash.protocol.request.LoginRequestPacket;</span><br><span class="line">import the.flash.protocol.request.MessageRequestPacket;</span><br><span class="line">import the.flash.protocol.response.LoginResponsePacket;</span><br><span class="line">import the.flash.protocol.response.MessageResponsePacket;</span><br><span class="line">import the.flash.serialize.Serializer;</span><br><span class="line">import the.flash.serialize.impl.JSONSerializer;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import static the.flash.protocol.command.Command.*;</span><br><span class="line"></span><br><span class="line">public class PacketCodeC &#123;</span><br><span class="line"></span><br><span class="line">    private static final int MAGIC_NUMBER = 0x12345678;</span><br><span class="line">    public static final PacketCodeC INSTANCE = new PacketCodeC();</span><br><span class="line"></span><br><span class="line">    private final Map&lt;Byte, Class&lt;? extends Packet&gt;&gt; packetTypeMap;</span><br><span class="line">    private final Map&lt;Byte, Serializer&gt; serializerMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private PacketCodeC() &#123;</span><br><span class="line">        packetTypeMap = new HashMap&lt;&gt;();</span><br><span class="line">        packetTypeMap.put(LOGIN_REQUEST, LoginRequestPacket.class);</span><br><span class="line">        packetTypeMap.put(LOGIN_RESPONSE, LoginResponsePacket.class);</span><br><span class="line">        packetTypeMap.put(MESSAGE_REQUEST, MessageRequestPacket.class);</span><br><span class="line">        packetTypeMap.put(MESSAGE_RESPONSE, MessageResponsePacket.class);</span><br><span class="line"></span><br><span class="line">        serializerMap = new HashMap&lt;&gt;();</span><br><span class="line">        Serializer serializer = new JSONSerializer();</span><br><span class="line">        serializerMap.put(serializer.getSerializerAlogrithm(), serializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ByteBuf encode(ByteBufAllocator byteBufAllocator, Packet packet) &#123;</span><br><span class="line">        // 1. 创建 ByteBuf 对象</span><br><span class="line">        ByteBuf byteBuf = byteBufAllocator.ioBuffer();</span><br><span class="line">        // 2. 序列化 java 对象</span><br><span class="line">        byte[] bytes = Serializer.DEFAULT.serialize(packet);</span><br><span class="line"></span><br><span class="line">        // 3. 实际编码过程</span><br><span class="line">        byteBuf.writeInt(MAGIC_NUMBER);</span><br><span class="line">        byteBuf.writeByte(packet.getVersion());</span><br><span class="line">        byteBuf.writeByte(Serializer.DEFAULT.getSerializerAlogrithm());</span><br><span class="line">        byteBuf.writeByte(packet.getCommand());</span><br><span class="line">        byteBuf.writeInt(bytes.length);</span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">        return byteBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Packet decode(ByteBuf byteBuf) &#123;</span><br><span class="line">        // 跳过 magic number</span><br><span class="line">        byteBuf.skipBytes(4);</span><br><span class="line"></span><br><span class="line">        // 跳过版本号</span><br><span class="line">        byteBuf.skipBytes(1);</span><br><span class="line"></span><br><span class="line">        // 序列化算法</span><br><span class="line">        byte serializeAlgorithm = byteBuf.readByte();</span><br><span class="line"></span><br><span class="line">        // 指令</span><br><span class="line">        byte command = byteBuf.readByte();</span><br><span class="line"></span><br><span class="line">        // 数据包长度</span><br><span class="line">        int length = byteBuf.readInt();</span><br><span class="line"></span><br><span class="line">        byte[] bytes = new byte[length];</span><br><span class="line">        byteBuf.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends Packet&gt; requestType = getRequestType(command);</span><br><span class="line">        Serializer serializer = getSerializer(serializeAlgorithm);</span><br><span class="line"></span><br><span class="line">        if (requestType != null &amp;&amp; serializer != null) &#123;</span><br><span class="line">            return serializer.deserialize(requestType, bytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Serializer getSerializer(byte serializeAlgorithm) &#123;</span><br><span class="line"></span><br><span class="line">        return serializerMap.get(serializeAlgorithm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Class&lt;? extends Packet&gt; getRequestType(byte command) &#123;</span><br><span class="line"></span><br><span class="line">        return packetTypeMap.get(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ol>
<li><p>使用接口保存全局数据：序列化编码的序号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface SerializerAlogrithm &#123;</span><br><span class="line">    /**</span><br><span class="line">     * json 序列化</span><br><span class="line">     */</span><br><span class="line">    byte JSON = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fastjson进行序列化接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializer &#123;</span><br><span class="line"></span><br><span class="line">    Serializer DEFAULT = new JSONSerializer();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列化算法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    byte getSerializerAlogrithm();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * java 对象转换成二进制</span><br><span class="line">     */</span><br><span class="line">    byte[] serialize(Object object);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 二进制转换成 java 对象</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fastjson进行序列化实现    </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class JSONSerializer implements Serializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte getSerializerAlogrithm() &#123;</span><br><span class="line">        return SerializerAlogrithm.JSON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(Object object) &#123;</span><br><span class="line"></span><br><span class="line">        return JSON.toJSONBytes(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;</span><br><span class="line"></span><br><span class="line">        return JSON.parseObject(bytes, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通信数据包"><a href="#通信数据包" class="headerlink" title="通信数据包"></a>通信数据包</h2><h3 id="通信数据包基类"><a href="#通信数据包基类" class="headerlink" title="通信数据包基类"></a>通信数据包基类</h3><p>包括版本号，协议号，以及策略模式通信包中的channelread(),还有提供给子类使用的工具方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Packet &#123;</span><br><span class="line">    @JSONField(deserialize = false, serialize = false)</span><br><span class="line">    private Byte version = 1;</span><br><span class="line"></span><br><span class="line">    @JSONField(serialize = false)</span><br><span class="line">    public abstract Byte getCommand();</span><br></pre></td></tr></table></figure></p>
<h3 id="具体通信数据包类"><a href="#具体通信数据包类" class="headerlink" title="具体通信数据包类"></a>具体通信数据包类</h3><p>实现双端通信，这里需要这几步：1.客户端给服务端发送登录请求；2.服务端回复登录请求；3.客户端给客服端发送消息；4.服务端回复消息。则需要四种数据包。</p>
<ol>
<li><p>登录请求数据包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class LoginRequestPacket extends Packet &#123;</span><br><span class="line">    private String userId;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Byte getCommand() &#123;</span><br><span class="line"></span><br><span class="line">        return LOGIN_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>登陆请求回复数据包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class LoginResponsePacket extends Packet &#123;</span><br><span class="line">    private boolean success;</span><br><span class="line"></span><br><span class="line">    private String reason;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Byte getCommand() &#123;</span><br><span class="line">        return LOGIN_RESPONSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息发送数据包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class MessageRequestPacket extends Packet &#123;</span><br><span class="line"></span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Byte getCommand() &#123;</span><br><span class="line">        return MESSAGE_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回复消息数据包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class MessageResponsePacket extends Packet &#123;</span><br><span class="line"></span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Byte getCommand() &#123;</span><br><span class="line"></span><br><span class="line">        return MESSAGE_RESPONSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><p>为了在登录后的通信中，判断是否已经登录。使用Channel 绑定属性，通过 channel.attr(xxx).set(xx) 的方式，在登录成功之后，给 Channel 绑定一个登录成功的标志位，然后判断是否登录成功的时候取出这个标志位就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LoginUtil &#123;</span><br><span class="line">    public static void markAsLogin(Channel channel) &#123;</span><br><span class="line">        channel.attr(Attributes.LOGIN).set(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean hasLogin(Channel channel) &#123;</span><br><span class="line">        Attribute&lt;Boolean&gt; loginAttr = channel.attr(Attributes.LOGIN);</span><br><span class="line"></span><br><span class="line">        return loginAttr.get() != null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h1><h2 id="服务端引导"><a href="#服务端引导" class="headerlink" title="服务端引导"></a>服务端引导</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class NettyServer &#123;</span><br><span class="line"></span><br><span class="line">    private static final int PORT = 8000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioEventLoopGroup boosGroup = new NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        final ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">        serverBootstrap</span><br><span class="line">                .group(boosGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                        ch.pipeline().addLast(new ServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        bind(serverBootstrap, PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void bind(final ServerBootstrap serverBootstrap, final int port) &#123;</span><br><span class="line">        serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">            if (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(new Date() + &quot;: 端口[&quot; + port + &quot;]绑定成功!&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.err.println(&quot;端口[&quot; + port + &quot;]绑定失败!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务端业务逻辑"><a href="#服务端业务逻辑" class="headerlink" title="服务端业务逻辑"></a>服务端业务逻辑</h2><p>具体业务逻辑分为三步四部分：1. 解码 2. 根据数据包选择响应逻辑 3. 编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">        ByteBuf requestByteBuf = (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        Packet packet = PacketCodeC.INSTANCE.decode(requestByteBuf);</span><br><span class="line"></span><br><span class="line">        if (packet instanceof LoginRequestPacket) &#123;</span><br><span class="line">            System.out.println(new Date() + &quot;: 收到客户端登录请求……&quot;);</span><br><span class="line">            // 登录流程</span><br><span class="line">            LoginRequestPacket loginRequestPacket = (LoginRequestPacket) packet;</span><br><span class="line"></span><br><span class="line">            LoginResponsePacket loginResponsePacket = new LoginResponsePacket();</span><br><span class="line">            loginResponsePacket.setVersion(packet.getVersion());</span><br><span class="line">            if (valid(loginRequestPacket)) &#123;</span><br><span class="line">                loginResponsePacket.setSuccess(true);</span><br><span class="line">                System.out.println(new Date() + &quot;: 登录成功!&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                loginResponsePacket.setReason(&quot;账号密码校验失败&quot;);</span><br><span class="line">                loginResponsePacket.setSuccess(false);</span><br><span class="line">                System.out.println(new Date() + &quot;: 登录失败!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 登录响应</span><br><span class="line">            ByteBuf responseByteBuf = PacketCodeC.INSTANCE.encode(ctx.alloc(), loginResponsePacket);</span><br><span class="line">            ctx.channel().writeAndFlush(responseByteBuf);</span><br><span class="line">        &#125; else if (packet instanceof MessageRequestPacket) &#123;</span><br><span class="line">            // 客户端发来消息</span><br><span class="line">            MessageRequestPacket messageRequestPacket = ((MessageRequestPacket) packet);</span><br><span class="line"></span><br><span class="line">            MessageResponsePacket messageResponsePacket = new MessageResponsePacket();</span><br><span class="line">            System.out.println(new Date() + &quot;: 收到客户端消息: &quot; + messageRequestPacket.getMessage());</span><br><span class="line">            messageResponsePacket.setMessage(&quot;服务端回复【&quot; + messageRequestPacket.getMessage() + &quot;】&quot;);</span><br><span class="line">            ByteBuf responseByteBuf = PacketCodeC.INSTANCE.encode(ctx.alloc(), messageResponsePacket);</span><br><span class="line">            ctx.channel().writeAndFlush(responseByteBuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean valid(LoginRequestPacket loginRequestPacket) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h2><p>客户端其启动时，新起了一个控制台线程，用来发送消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class NettyClient &#123;</span><br><span class="line">    private static final int MAX_RETRY = 5;</span><br><span class="line">    private static final String HOST = &quot;127.0.0.1&quot;;</span><br><span class="line">    private static final int PORT = 8000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">        bootstrap</span><br><span class="line">                .group(workerGroup)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                        ch.pipeline().addLast(new ClientHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        connect(bootstrap, HOST, PORT, MAX_RETRY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void connect(Bootstrap bootstrap, String host, int port, int retry) &#123;</span><br><span class="line">        bootstrap.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">            if (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(new Date() + &quot;: 连接成功，启动控制台线程……&quot;);</span><br><span class="line">                Channel channel = ((ChannelFuture) future).channel();</span><br><span class="line">                startConsoleThread(channel);</span><br><span class="line">            &#125; else if (retry == 0) &#123;</span><br><span class="line">                System.err.println(&quot;重试次数已用完，放弃连接！&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 第几次重连</span><br><span class="line">                int order = (MAX_RETRY - retry) + 1;</span><br><span class="line">                // 本次重连的间隔</span><br><span class="line">                int delay = 1 &lt;&lt; order;</span><br><span class="line">                System.err.println(new Date() + &quot;: 连接失败，第&quot; + order + &quot;次重连……&quot;);</span><br><span class="line">                bootstrap.config().group().schedule(() -&gt; connect(bootstrap, host, port, retry - 1), delay, TimeUnit</span><br><span class="line">                        .SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void startConsoleThread(Channel channel) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (!Thread.interrupted()) &#123;</span><br><span class="line">                if (LoginUtil.hasLogin(channel)) &#123;</span><br><span class="line">                    System.out.println(&quot;输入消息发送至服务端: &quot;);</span><br><span class="line">                    Scanner sc = new Scanner(System.in);</span><br><span class="line">                    String line = sc.nextLine();</span><br><span class="line"></span><br><span class="line">                    MessageRequestPacket packet = new MessageRequestPacket();</span><br><span class="line">                    packet.setMessage(line);</span><br><span class="line">                    ByteBuf byteBuf = PacketCodeC.INSTANCE.encode(channel.alloc(), packet);</span><br><span class="line">                    channel.writeAndFlush(byteBuf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="客户端业务逻辑"><a href="#客户端业务逻辑" class="headerlink" title="客户端业务逻辑"></a>客户端业务逻辑</h2><p>重写了两个函数，分别在连接建立时和每次收到信息时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class ClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        System.out.println(new Date() + &quot;: 客户端开始登录&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建登录对象</span><br><span class="line">        LoginRequestPacket loginRequestPacket = new LoginRequestPacket();</span><br><span class="line">        loginRequestPacket.setUserId(UUID.randomUUID().toString());</span><br><span class="line">        loginRequestPacket.setUsername(&quot;flash&quot;);</span><br><span class="line">        loginRequestPacket.setPassword(&quot;pwd&quot;);</span><br><span class="line"></span><br><span class="line">        // 编码</span><br><span class="line">        ByteBuf buffer = PacketCodeC.INSTANCE.encode(ctx.alloc(), loginRequestPacket);</span><br><span class="line"></span><br><span class="line">        // 写数据</span><br><span class="line">        ctx.channel().writeAndFlush(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        Packet packet = PacketCodeC.INSTANCE.decode(byteBuf);</span><br><span class="line"></span><br><span class="line">        if (packet instanceof LoginResponsePacket) &#123;</span><br><span class="line">            LoginResponsePacket loginResponsePacket = (LoginResponsePacket) packet;</span><br><span class="line"></span><br><span class="line">            if (loginResponsePacket.isSuccess()) &#123;</span><br><span class="line">                System.out.println(new Date() + &quot;: 客户端登录成功&quot;);</span><br><span class="line">                LoginUtil.markAsLogin(ctx.channel());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(new Date() + &quot;: 客户端登录失败，原因：&quot; + loginResponsePacket.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (packet instanceof MessageResponsePacket) &#123;</span><br><span class="line">            MessageResponsePacket messageResponsePacket = (MessageResponsePacket) packet;</span><br><span class="line">            System.out.println(new Date() + &quot;: 收到服务端的消息: &quot; + messageResponsePacket.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/14/11-14技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/14/11-14技术笔记/" itemprop="url">ByteBuf与通信协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-14T14:18:20+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ByteBuf与内存管理"><a href="#ByteBuf与内存管理" class="headerlink" title="ByteBuf与内存管理"></a>ByteBuf与内存管理</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>ByteBuf结构上，类似一段连续的内存（数组），和其上的两个指针（读和写）。这样，通过读写指针的移动，可以控制到指定位置的读写。   </p>
<h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><p>为了支持可扩容，实际上还保存了当前容量，然后自动扩容。直到最大容量（默认为Interger.Max）。   </p>
<ol>
<li>capacity()表示 ByteBuf 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节），不同的底层实现机制有不同的计算方式</li>
<li>readableBytes() 表示 ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex，如果两者相等，则不可读，isReadable() 方法返回 false</li>
<li>writableBytes() 表示 ByteBuf 当前可写的字节数，它的值等于 capacity-writerIndex，如果两者相等，则表示不可写，isWritable() 返回 false，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往 ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity，而 maxWritableBytes() 就表示可写的最大字节数，它的值等于 maxCapacity-writerIndex.    </li>
</ol>
<h2 id="读写指针"><a href="#读写指针" class="headerlink" title="读写指针"></a>读写指针</h2><p>readerIndex()表示返回当前的读指针 readerIndex 与 readerIndex(int)表示设置读指针。<br>writeIndex()表示返回当前的写指针 writerIndex 与 writeIndex(int)表示设置写指针。<br>markReaderIndex()表示把当前的读指针保存起来 与 resetReaderIndex()表示把当前的读指针恢复到之前保存的值。<br>markWriterIndex() 与 resetWriterIndex()同理。   </p>
<h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><p>关于 ByteBuf 的读写都可以看作从指针开始的地方开始读写数据，write和read表示读写数据的同时指针移动，get和set只读写，指针不移动。<br>同时有Discard和clear等方法，抛弃前面的内容时，数组后面会延伸，以保持当年容量。</p>
<blockquote>
<p><a href="https://www.itcodemonkey.com/article/4655.html" target="_blank" rel="noopener">https://www.itcodemonkey.com/article/4655.html</a>    </p>
</blockquote>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>由于netty可以使用堆外内存，这里GC不工作，所以此处需要自己管理内存。所管理的应该是引用计数，当引用计数为0时，才会自动清除。<br>默认情况下，当创建完一个 ByteBuf，它的引用为1，然后每次调用 retain() 方法， 它的引用就加一， release() 方法原理是将引用计数减一，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存。<br>duplicate()和slice()创建的只是视图，也就是说对原内存的一个新的引用，对其内容的修改会导致原ByteBuf内容变化。</p>
<p>两种形式，池化和非池化；三个位置堆，直接内存，混合。组合出六种生成的方式。<br>池化需要ByteBufAllocator，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBufAllocator allocator = channel.alloc();</span><br><span class="line">ByteBufAllocator allocator2 = ctx.alloc();</span><br></pre></td></tr></table></figure></p>
<p>均可获得ByteBufAllocator对象。<br>heapBuffer()基于堆，directBuffer()基于直接内存，buffer()两者或，compositeBuffer()两者混合。<br>而非池化可以直接用Unpooled的静态方法。<br>buffer()基于堆，directBuffer()基于直接内存。</p>
<h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h1><h2 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h2><p>netty可以自己设计通信协议，为什么需要通信协议。比如说服务端接收到客户端的数据包，怎么知道传来的是用户名密码还是发的消息呢？对于用户名密码，怎么知道哪些字节是用户名，哪些字节是密码呢，这些都需要规定，规定的结果就是协议。<br><a href="https://imgchr.com/i/ijAp40" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/14/ijAp40.md.png" alt="ijAp40.md.png"></a>   </p>
<ol>
<li>第一个字段是魔数，通常情况下为固定的几个字节（我们这边规定为4个字节）。魔数是用来区分协议的，不同的协议不同的魔数。对比魔数才能找到协议。</li>
<li>第二个字段版本号。  </li>
<li>第三部分，序列化算法表示如何把 Java 对象转换二进制数据以及二进制数据如何转换回 Java 对象，比如 Java 自带的序列化，json，hessian 等序列化方式。</li>
<li>第四部分的字段表示指令，关于指令相关的介绍，我们在前面已经讨论过，服务端或者客户端每收到一种指令都会有相应的处理逻辑，正如之前说的区分账号密码还是说的话。</li>
<li>数据长度。</li>
<li>数据内容。    </li>
</ol>
<h2 id="（参考）实际上RPC协议"><a href="#（参考）实际上RPC协议" class="headerlink" title="（参考）实际上RPC协议"></a>（参考）实际上RPC协议</h2><p>一般 RPC 框架首先获取协议类型，根据这个协议类型得到协议处理器，然后再处理（一个端口处理多个协议的场景）。<br>生产级别的 RPC 通常较为复杂，以 SOFABolt 为例，需要以下字段：</p>
<ol>
<li>协议版本</li>
<li>请求类型，即指令（Request，Response， oneway）</li>
<li>指令版本</li>
<li>RequestID 负责数据对应</li>
<li>序列号器</li>
<li>协议开关（例如 CRC 校验，安全校验）</li>
<li>响应码，约定异常，简化异常</li>
<li>类名长度，Java rpc 框架必备</li>
<li>请求头长度（参照 http header）</li>
<li>请求体长度（参照http body）</li>
<li>类名</li>
<li>业务请求头内容（一般是 Map，SOFABolt 支持自定义，SOFARPC 里面藏着是否泛化调用等信息）</li>
<li>业务请求体内容（一般就是个Request对象或 Response对象，里面包含约定的属性，例如参数，返回值，超级多，SOFARPC 有个属性类 RemotingConstants，这里都有）</li>
<li>CRC 校验码（金融场景必备）</li>
</ol>
<h2 id="数据包设计"><a href="#数据包设计" class="headerlink" title="数据包设计"></a>数据包设计</h2><ol>
<li>数据包基类应该包括版本和指令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Packet &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 协议版本</span><br><span class="line">     */</span><br><span class="line">    @JSONField(deserialize = false, serialize = false)</span><br><span class="line">    private Byte version = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @JSONField(serialize = false)</span><br><span class="line">    public abstract Byte getCommand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>具体登陆数据包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LoginRequestPacket extends Packet &#123;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Byte getCommand() &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ol>
<li><p>定义序列化接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializer &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列化算法</span><br><span class="line">     */</span><br><span class="line">    byte getSerializerAlgorithm();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * java 对象转换成二进制</span><br><span class="line">     */</span><br><span class="line">    byte[] serialize(Object object);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 二进制转换成 java 对象</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);</span><br><span class="line">    /**</span><br><span class="line">    * 默认采用JSON</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">     Serializer DEFAULT = new JSONSerializer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 fastjson进行序列化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class JSONSerializer implements Serializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte getSerializerAlgorithm() &#123;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(Object object) &#123;</span><br><span class="line"></span><br><span class="line">        return JSON.toJSONBytes(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;</span><br><span class="line"></span><br><span class="line">        return JSON.parseObject(bytes, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAGIC_NUMBER = 0x12345678;</span><br><span class="line"></span><br><span class="line">public ByteBuf encode(Packet packet) &#123;</span><br><span class="line">    // 1. 创建 ByteBuf 对象</span><br><span class="line">    ByteBuf byteBuf = ByteBufAllocator.DEFAULT.ioBuffer();</span><br><span class="line">    // 2. 序列化 Java 对象</span><br><span class="line">    byte[] bytes = Serializer.DEFAULT.serialize(packet);</span><br><span class="line"></span><br><span class="line">    // 3. 实际编码过程</span><br><span class="line">    byteBuf.writeInt(MAGIC_NUMBER);</span><br><span class="line">    byteBuf.writeByte(packet.getVersion());</span><br><span class="line">    byteBuf.writeByte(Serializer.DEFAULT.getSerializerAlgorithm());</span><br><span class="line">    byteBuf.writeByte(packet.getCommand());</span><br><span class="line">    byteBuf.writeInt(bytes.length);</span><br><span class="line">    byteBuf.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">    return byteBuf;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>
<ol>
<li>首先，我们需要创建一个 ByteBuf，这里我们调用 Netty 的 ByteBuf 分配器来创建，ioBuffer() 方法会返回适配 io 读写相关的内存，它会尽可能创建一个直接内存，直接内存可以理解为不受 jvm 堆管理的内存空间，写到 IO 缓冲区的效果更高。</li>
<li>接下来，我们将 Java 对象序列化成二进制数据包。</li>
<li>最后，我们对照本小节开头协议的设计以及上一小节 ByteBuf 的 API，逐个往 ByteBuf 写入字段，即实现了编码过程，到此，编码过程结束</li>
</ol>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public Packet decode(ByteBuf byteBuf) &#123;</span><br><span class="line">    // 跳过 magic number</span><br><span class="line">    byteBuf.skipBytes(4);</span><br><span class="line"></span><br><span class="line">    // 跳过版本号</span><br><span class="line">    byteBuf.skipBytes(1);</span><br><span class="line"></span><br><span class="line">    // 序列化算法标识</span><br><span class="line">    byte serializeAlgorithm = byteBuf.readByte();</span><br><span class="line"></span><br><span class="line">    // 指令</span><br><span class="line">    byte command = byteBuf.readByte();</span><br><span class="line"></span><br><span class="line">    // 数据包长度</span><br><span class="line">    int length = byteBuf.readInt();</span><br><span class="line"></span><br><span class="line">    byte[] bytes = new byte[length];</span><br><span class="line">    byteBuf.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Packet&gt; requestType = getRequestType(command);</span><br><span class="line">    Serializer serializer = getSerializer(serializeAlgorithm);</span><br><span class="line"></span><br><span class="line">    if (requestType != null &amp;&amp; serializer != null) &#123;</span><br><span class="line">        return serializer.deserialize(requestType, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>我们假定 decode 方法传递进来的 ByteBuf 已经是合法的，即首四个字节是我们前面定义的魔数 0x12345678，这里我们调用 skipBytes 跳过这四个字节。</li>
<li>这里，我们暂时不关注协议版本，通常我们在没有遇到协议升级的时候，这个字段暂时不处理，因为，你会发现，绝大多数情况下，这个字段几乎用不着，但我们仍然需要暂时留着。</li>
<li>接下来，我们调用 ByteBuf 的 API 分别拿到序列化算法标识、指令、数据包的长度。</li>
<li>最后，我们根据拿到的数据包的长度取出数据，通过指令拿到该数据包对应的 Java 对象的类型，根据序列化算法标识拿到序列化对象，将字节数组转换为 Java 对象，至此，解码过程结束。</li>
<li>指令号对应的指令，序列法序号对应的序列化方法，储存在服务端，两个get函数既是查询本机的映射表，得到相应的映射方法。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/13/11-13技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/13/11-13技术笔记/" itemprop="url">netty基础搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-13T14:41:08+08:00">
                2018-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class NettyServer &#123;</span><br><span class="line"></span><br><span class="line">    private static final int BEGIN_PORT = 8000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /*</span><br><span class="line">        我们创建了两个NioEventLoopGroup，这两个对象可以看做是传统IO编程模型的两大线程组，</span><br><span class="line">        bossGroup表示监听端口，accept 新连接的线程组，workerGroup表示处理每一条连接的数据读写的线程组</span><br><span class="line">         */</span><br><span class="line">        NioEventLoopGroup boosGroup = new NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        /*</span><br><span class="line">        创建了一个引导类 ServerBootstrap，这个类将引导我们进行服务端的启动工作，直接new出来</span><br><span class="line">         */</span><br><span class="line">        final ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">        final AttributeKey&lt;Object&gt; clientKey = AttributeKey.newInstance(&quot;clientKey&quot;);</span><br><span class="line">        serverBootstrap</span><br><span class="line">                /*</span><br><span class="line">                我们通过.group(bossGroup, workerGroup)给引导类配置两大线程组，这个引导类的线程模型也就定型了。</span><br><span class="line">                 */</span><br><span class="line">                .group(boosGroup, workerGroup)</span><br><span class="line">                /*</span><br><span class="line">                指定我们服务端的 IO 模型为NIO，我们通过.channel(NioServerSocketChannel.class)来指定 IO 模型，</span><br><span class="line">                当然，这里也有其他的选择，如果你想指定 IO 模型为 BIO，那么这里配置上OioServerSocketChannel.class</span><br><span class="line">                类型即可，当然通常我们也不会这么做，因为Netty的优势就在于NIO。</span><br><span class="line">                 */</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                /*</span><br><span class="line">                childHandler()用于指定处理新连接数据的读写处理逻辑，handler()用于指定在服务端启动过程中的一些逻辑</span><br><span class="line">                 */</span><br><span class="line">                .handler(new ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">                        super.channelActive(ctx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                        System.out.println(ch.attr(clientKey).get());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                 /*</span><br><span class="line">                attr()方法可以给服务端的 channel，也就是NioServerSocketChannel指定一些自定义属性，</span><br><span class="line">                然后我们可以通过channel.attr()取出这个属性，</span><br><span class="line">                比如，下面的代码我们指定我们服务端channel的一个serverName属性，属性值为nettyServer</span><br><span class="line">                childAttr可以给每一条连接指定自定义属性，然后后续我们可以通过channel.attr()取出该属性。</span><br><span class="line">                 */</span><br><span class="line">                .attr(AttributeKey.newInstance(&quot;serverName&quot;), &quot;nettyServer&quot;)</span><br><span class="line">                .childAttr(clientKey, &quot;clientValue&quot;)</span><br><span class="line">                /*</span><br><span class="line">                childOption()可以给每条连接设置一些TCP底层相关的属性，比如上面，我们设置了两种TCP属性，其中</span><br><span class="line">                ChannelOption.SO_KEEPALIVE表示是否开启TCP底层心跳机制，true为开启</span><br><span class="line">                ChannelOption.TCP_NODELAY表示是否开启Nagle算法，true表示关闭，false表示开启，</span><br><span class="line">                通俗地说，如果要求高实时性，有数据发送时就马上发送，就关闭，如果需要减少发送次数减少网络交互，就开启。</span><br><span class="line"></span><br><span class="line">                除了给每个连接设置这一系列属性之外，我们还可以给服务端channel设置一些属性，最常见的就是so_backlog，</span><br><span class="line">                如下设置表示系统用于临时存放已完成三次握手的请求的队列的最大长度，如果连接建立频繁</span><br><span class="line">                ，服务器处理创建新连接较慢，可以适当调大这个参数...</span><br><span class="line">                 */</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        调用bind(8000)，我们就可以在本地绑定一个 8000 端口启动起来。</span><br><span class="line">        这里手写了重载函数，如果绑定失败，则绑定下一个端口。</span><br><span class="line">         */</span><br><span class="line">        bind(serverBootstrap, BEGIN_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void bind(final ServerBootstrap serverBootstrap, final int port) &#123;</span><br><span class="line">        serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">            if (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(&quot;端口[&quot; + port + &quot;]绑定成功!&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.err.println(&quot;端口[&quot; + port + &quot;]绑定失败!&quot;);</span><br><span class="line">                bind(serverBootstrap, port + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class NettyClient &#123;</span><br><span class="line">    private static final int MAX_RETRY = 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">        bootstrap</span><br><span class="line">                // 1.指定线程模型,客户端只需要一个EventLoopGroup</span><br><span class="line">                .group(workerGroup)</span><br><span class="line">                // 2.指定 IO 类型为 NIO</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                // 绑定自定义属性到 channel</span><br><span class="line">                .attr(AttributeKey.newInstance(&quot;clientName&quot;), &quot;nettyClient&quot;)</span><br><span class="line">                // 设置TCP底层属性</span><br><span class="line">                /*</span><br><span class="line">                 ChannelOption.CONNECT_TIMEOUT_MILLIS 表示连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span><br><span class="line">                 ChannelOption.SO_KEEPALIVE 表示是否开启 TCP 底层心跳机制，true 为开启</span><br><span class="line">                 ChannelOption.TCP_NODELAY 表示是否开始 Nagle 算法，true 表示关闭，false 表示开启。</span><br><span class="line">                 通俗地说，如果要求高实时性，有数据发送时就马上发送，就设置为 true 关闭，如果需要减少发送次数减少网络交互，就设置为 false 开启</span><br><span class="line">                 */</span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                // 3.IO 处理逻辑</span><br><span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        // 4.建立连接</span><br><span class="line">        connect(bootstrap, &quot;127.0.0.1&quot;, 8000, MAX_RETRY);</span><br><span class="line">    &#125;</span><br><span class="line">    //这里建立连接，为了避免失败，同样手写了方法，超时重试机制。</span><br><span class="line">    private static void connect(Bootstrap bootstrap, String host, int port, int retry) &#123;</span><br><span class="line">        bootstrap.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">            if(future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(&quot;连接成功!&quot;);</span><br><span class="line">            &#125;else if(retry == 0) &#123;</span><br><span class="line">                System.err.println(&quot;重试次数已用完，放弃连接！&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                // 第几次重连</span><br><span class="line">                int order = (MAX_RETRY - retry) + 1;</span><br><span class="line">                // 本次重连的间隔</span><br><span class="line">                int delay = 1 &lt;&lt; order;</span><br><span class="line">                System.err.println(new Date() + &quot;: 连接失败，第&quot; + order + &quot;次重连……&quot;);</span><br><span class="line">                bootstrap.config().group().schedule(() -&gt; connect(bootstrap, host, port, retry - 1), delay, TimeUnit</span><br><span class="line">                        .SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="服务端和客户端数据交互"><a href="#服务端和客户端数据交互" class="headerlink" title="服务端和客户端数据交互"></a>服务端和客户端数据交互</h1><h2 id="业务逻辑位置"><a href="#业务逻辑位置" class="headerlink" title="业务逻辑位置"></a>业务逻辑位置</h2><p>在客户端启动中，childHandler中并没有写业务逻辑，仅仅一个打印。实际上，所以的业务都应该写于此种，这里使用了责任链模式。NioSocketChannel中有pipeline，pipe里有个双向链表，向其中添加业务逻辑的ChannelHandler即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">        ch.pipeline().addLast(new FirstServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同样，在服务端中，数据读写是handler() 方法中的initChannel()。    </p>
<h2 id="客户端写出数据"><a href="#客户端写出数据" class="headerlink" title="客户端写出数据"></a>客户端写出数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class FirstClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    [覆盖了 channelActive()方法，这个方法会在客户端连接建立成功之后被调用]</span><br><span class="line">    写数据的逻辑分为两步：首先我们需要获取一个 netty 对二进制数据的抽象 ByteBuf，, ctx.alloc() 获取到一个 ByteBuf 的内存管理器，</span><br><span class="line">    这个内存管理器的作用就是分配一个 ByteBuf，然后我们把字符串的二进制数据填充到 ByteBuf，</span><br><span class="line">    这样我们就获取到了 Netty 需要的一个数据格式，最后我们调用 ctx.channel().writeAndFlush() 把数据写到服务端...</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        System.out.println(new Date() + &quot;: 客户端写出数据&quot;);</span><br><span class="line">        // 1.获取数据</span><br><span class="line">        ByteBuf buffer = getByteBuf(ctx);</span><br><span class="line">        // 2.写数据</span><br><span class="line">        ctx.channel().writeAndFlush(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    private ByteBuf getByteBuf(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        byte[] bytes = &quot;hello world!&quot;.getBytes(Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">        ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">        buffer.writeBytes(bytes);</span><br><span class="line">        return buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务端读入数据，写出数据"><a href="#服务端读入数据，写出数据" class="headerlink" title="服务端读入数据，写出数据"></a>服务端读入数据，写出数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class FirstServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    /*</span><br><span class="line">        [这里覆盖的方法是 channelRead()，这个方法在接收到客户端发来的数据之后被回调。]</span><br><span class="line">        这里的 msg 参数指的就是 Netty 里面数据读写的载体，</span><br><span class="line">        我们强转之后，然后调用 byteBuf.toString() 就能够拿到我们客户端发过来的字符串数据。</span><br><span class="line">         */</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(new Date() + &quot;: 服务端读到数据 -&gt; &quot; + byteBuf.toString(Charset.forName(&quot;utf-8&quot;)));</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">       服务端向客户端写数据逻辑与客户端侧的写数据逻辑一样，</span><br><span class="line">       先创建一个 ByteBuf，然后填充二进制数据，最后调用 writeAndFlush() 方法写出去</span><br><span class="line">        */</span><br><span class="line">        System.out.println(new Date() + &quot;: 服务端写出数据&quot;);</span><br><span class="line">        ByteBuf out = getByteBuf(ctx);</span><br><span class="line">        ctx.channel().writeAndFlush(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ByteBuf getByteBuf(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        byte[] bytes = &quot;你好!&quot;.getBytes(Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">        ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">        buffer.writeBytes(bytes);</span><br><span class="line">        return buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端再读入数据"><a href="#客户端再读入数据" class="headerlink" title="客户端再读入数据"></a>客户端再读入数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class FirstClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    // 写数据相关的逻辑省略</span><br><span class="line">    /*</span><br><span class="line">        客户端的读取数据的逻辑和服务端读取数据的逻辑一样，同样是覆盖 ChannelRead() 方法</span><br><span class="line">    */</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        System.out.println(new Date() + &quot;: 客户端读到数据 -&gt; &quot; + byteBuf.toString(Charset.forName(&quot;utf-8&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*异常处理覆盖的方法是 exceptionCaught()。记录 Throwable，关闭 Channel，在这个场景下，终止到服务器的连接*/</span><br><span class="line">@Override</span><br><span class="line">public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/08/11-8技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/08/11-8技术笔记/" itemprop="url">netty基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-08T15:37:36+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="netty特点"><a href="#netty特点" class="headerlink" title="netty特点"></a>netty特点</h2><ol>
<li><strong>高并发</strong>，通过非阻塞的NIO方式，使用了Selector，实现了高并发性。</li>
<li><strong>高传输</strong>，Netty针对这种情况，使用了NIO中的另一大特性——零拷贝，当他需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。</li>
<li><strong>封装好</strong>    </li>
</ol>
<h2 id="netty组成"><a href="#netty组成" class="headerlink" title="netty组成"></a>netty组成</h2><p> （客户端+服务端）*（启动连接+业务逻辑处理）。完成交互至少需要这四部分。</p>
<h2 id="netty术语"><a href="#netty术语" class="headerlink" title="netty术语"></a>netty术语</h2><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p><a href="https://imgchr.com/i/i7jEp8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/08/i7jEp8.md.png" alt="i7jEp8.md.png"></a>   </p>
<ol>
<li>Channel，表示一个连接，可以理解为每一个请求，就是一个Channel。</li>
<li>ChannelHandler，核心处理业务就在这里，用于处理业务请求。</li>
<li>ChannelHandlerContext，用于传输业务数据。</li>
<li>ChannelPipeline，用于保存处理过程需要用到的ChannelHandler和ChannelHandlerContext。   </li>
</ol>
<h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>ByteBuf是一个存储字节的容器，最大特点就是使用方便，它既有自己的读索引和写索引，方便你对整段字节缓存进行读写，也支持get/set，方便你对其中每一个字节进行读写.</p>
<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>EventLoopGroup 是用来处理I/O操作的多线程事件循环器.NioEventLoopGroup是其一个实现。<br>一般至少需要两个EventLoopGroup，boss这个EventLoopGroup作为一个acceptor负责接收来自客户端的请求，然后分发给worker这个EventLoopGroup来处理所有的事件event和channel的IO。    </p>
<h3 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h3><p>BootStrap在netty的应用程序中负责引导服务器和客户端。netty包含了两种不同类型的引导：</p>
<ol>
<li>使用服务器的ServerBootStrap，用于接受客户端的连接以及为已接受的连接创建子通道。</li>
<li>用于客户端的BootStrap，不接受新的连接，并且是在父通道类完成一些操作。<br>BootStrap配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(new SimpleChatServerInitializer())</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, 128)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, true);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>分别配置了BootStrap的EventLoop，channel，channelHandler来处理客户端的请求的channel的IO，设置TCP连接中的一些可选项，只作用于被acceptor(也就是boss EventLoopGroup)接收之后的channel的可选项。   </p>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>ChannelFuture是Channel结果的回调。当令Channel开始一个I/O操作时,会创建一个新的ChannelFuture去异步完成操作.<br>被创建时的ChannelFuture处于uncompleted状态(非失败,非成功,非取消);一旦ChannelFuture完成I/O操作,ChannelFuture将处于completed状态,结果可能有三种:</p>
<ol>
<li>操作成功</li>
<li>操作失败</li>
<li>操作被取消(I/O操作被主动终止)</li>
</ol>
<h2 id="channel生命周期"><a href="#channel生命周期" class="headerlink" title="channel生命周期"></a>channel生命周期</h2><p>下列重载函数在对应的时候触发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class LifeCyCleTestHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;逻辑处理器被添加：handlerAdded()&quot;);</span><br><span class="line">        super.handlerAdded(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 绑定到线程(NioEventLoop)：channelRegistered()&quot;);</span><br><span class="line">        super.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 准备就绪：channelActive()&quot;);</span><br><span class="line">        super.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 有数据可读：channelRead()&quot;);</span><br><span class="line">        super.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 某次数据读完：channelReadComplete()&quot;);</span><br><span class="line">        super.channelReadComplete(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 被关闭：channelInactive()&quot;);</span><br><span class="line">        super.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 取消线程(NioEventLoop) 的绑定: channelUnregistered()&quot;);</span><br><span class="line">        super.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;逻辑处理器被移除：handlerRemoved()&quot;);</span><br><span class="line">        super.handlerRemoved(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/07/11-6技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/07/11-6技术笔记/" itemprop="url">SpringMVC+jsp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-07T11:13:45+08:00">
                2018-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>需要视图解析器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;</span><br><span class="line">  &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;/&gt;</span><br><span class="line">  &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果用jstl，还需要加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;taglibs&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;standard&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>为了避免.jsp进入spring的 DispatcherServlet类。DispatcherServlet中ServletMapping需要是/而不是/*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&lt; url-pattern &gt; / <url-pattern> 不会匹配到.jsp，即：.jsp不会进入spring的 DispatcherServlet类 。<br>&lt; url-pattern &gt; /<em> <url-pattern> 会匹配</url-pattern></em>.jsp，会出现返回jsp视图时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。</url-pattern></p>
<p>关于web.xml的url映射规则：<br>&lt; url-pattern&gt;/<url-pattern> 会匹配到/login这样的路径型url，不会匹配到模式为<em>.jsp这样的后缀型url<br>&lt; url-pattern&gt;/\</em></url-pattern> 会匹配所有url：路径型的和后缀型的url(包括/login,.jsp,.js和*.html等)</p>
<ol start="3">
<li>属性值引号冲突<br>如果属性的内容有引号，属性值的引号会冲突。实际上，HTML 中,属性值用双引号、单引号、不加引号都可以。此时，把双引号换成单引号即可。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/blog/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/18/">18</a><a class="extend next" rel="next" href="/blog/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Arvense</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">174</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/blog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>


  
</div>


  <div class="powered-by">Powered by <a>Arvense</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">blog   </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
