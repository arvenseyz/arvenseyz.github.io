<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Arvense, NexT">





  <link rel="alternate" href="/atom.xml" title="Arvense" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Arvense">
<meta property="og:url" content="https://arvenseyz.github.io/page/17/index.html">
<meta property="og:site_name" content="Arvense">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Arvense">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://arvenseyz.github.io/page/17/">





  <title>Arvense</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Arvense</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/12/18/leetcode2-3-56/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/leetcode2-3-56/" itemprop="url">链表两数和，最长无重复字母子串长度，合并间隔</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-18T16:58:23+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>两数之和,只不过两数是用链表的形式给出的,而且是倒序.(实际上倒序才好算)</p>
<p><strong>Input:</strong> (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>Output:</strong> 7 -&gt; 0 -&gt; 8<br><strong>Explanation:</strong> 342 + 465 = 807.</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>思路不难,但链表操作还是有点复杂的,我们需要保存进位信息,用cur和next两个节点来回操作.就是按位加就行了.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode q = l1, p = l2, head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span> || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q == <span class="keyword">null</span> ? <span class="number">0</span> : q.val;</span><br><span class="line">            <span class="keyword">int</span> y = p == <span class="keyword">null</span> ? <span class="number">0</span> : p.val;</span><br><span class="line">            <span class="keyword">int</span> sum = x + y + j;</span><br><span class="line">            next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            j = sum / <span class="number">10</span>;</span><br><span class="line">            cur.next = next;</span><br><span class="line">            cur = next;</span><br><span class="line">            <span class="keyword">if</span>(p!=<span class="keyword">null</span>)p = p.next;</span><br><span class="line">            <span class="keyword">if</span>(q!=<span class="keyword">null</span>)q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j != <span class="number">0</span>) &#123;</span><br><span class="line">            next = <span class="keyword">new</span> ListNode(j);</span><br><span class="line">            cur.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这题其实没啥意思,全是链表的操作,思路和数据结构算法知识都不涉及.</p>
<h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>最长无重复字母子串长度</p>
<p><strong>Input:</strong> “abcabcbb”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The answer is `“abc”`, with the length of 3.</p>
<h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><p>解答方法是滑动窗口,从头滑动到尾,窗口里维护着一个集合,右边的字母不在集合里,就窗口往右边衍生.一旦右边的字母重复了,窗口从左边往右缩,直到无重复.</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(r))) &#123;</span><br><span class="line">                set.add(s.charAt(r));</span><br><span class="line">                r++;</span><br><span class="line">                ans = Math.max(ans, set.size());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(s.charAt(l));</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h2><p>滑动窗口思路．用集合和左右两个指针，也形成了滑动窗口．</p>
<h1 id="56"><a href="#56" class="headerlink" title="56"></a>56</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>合并间隔</p>
<p><strong>Input:</strong> [[1,3],[2,6],[8,10],[15,18]]<br><strong>Output:</strong> [[1,6],[8,10],[15,18]]<br><strong>Explanation:</strong> Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</p>
<h2 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h2><p>第一步当然是排序,重写List的sort方法,按照间隔的左边界排序.</p>
<p>然后就是合并,技巧是,建立一个tmp间隔,用来操作,它等于当前间隔.</p>
<p>如果和下一个间隔不交接,就把这个tmp间隔放入答案列表;如果交接,就合并下一个间隔.</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123;</span><br><span class="line">        List&lt;Interval&gt; listResult = new ArrayList&lt;&gt;();</span><br><span class="line">        intervals.sort(new Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Interval o1, Interval o2) &#123;</span><br><span class="line">                return o1.start - o2.start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        LinkedList&lt;Interval&gt; merged = new LinkedList&lt;Interval&gt;();</span><br><span class="line">        for (Interval interval : intervals) &#123;</span><br><span class="line">            if (merged.isEmpty() || merged.getLast().end &lt; interval.start) &#123;</span><br><span class="line">                merged.add(interval);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                merged.getLast().end = Math.max(merged.getLast().end, interval.end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h2><p>用一个类似操作的节点,每次放入的是操作节点,避免了连环交接的问题.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/12/14/12-14技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/12-14技术笔记/" itemprop="url">dubbo使用细节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-14T10:50:32+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Dubbo的Container详解模块，是一个独立的容器，因为服务通常不需要Tomcat/JBoss等Web容器的特性，没必要用Web容器去加载服务。</p>
<p>即Dubbo用自己的容器，不需要Web容器。</p>
<p>内置了三个服务容器，Spring，jetty，log4j。分别用于加载Spring，汇报状态，配置日志。默认调用SpringContainer。</p>
<p>通过JDK的ShutdownHook来完成优雅停机。</p>
<h2 id="服务注册与发现的流程"><a href="#服务注册与发现的流程" class="headerlink" title="服务注册与发现的流程"></a>服务注册与发现的流程</h2><p><a href="https://imgchr.com/i/FN4q10" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/12/14/FN4q10.md.png" alt="FN4q10.md.png"></a></p>
<p><img src="https://i.loli.net/2018/12/14/5c131d5942525.png" alt="5c131d5942525"></p>
<h2 id="服务宕机"><a href="#服务宕机" class="headerlink" title="服务宕机"></a>服务宕机</h2><p>Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？<br>可以的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用</p>
<p>注册中心对等集群，任意一台宕掉后，会自动切换到另一台<br>注册中心全部宕掉，服务提供者和消费者仍可以通过本地缓存通讯<br>服务提供者无状态，任一台 宕机后，不影响使用<br>服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复</p>
<h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><p>默认是同步等待结果阻塞的，支持异步调用。</p>
<p>Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</p>
<h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><p>Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方</p>
<h2 id="服务端配置消费者属性"><a href="#服务端配置消费者属性" class="headerlink" title="服务端配置消费者属性"></a>服务端配置消费者属性</h2><p>1）timeout：方法调用超时<br>2）retries：失败重试次数，默认重试 2 次<br>3）loadbalance：负载均衡算法，默认随机<br>4）actives 消费者端，最大并发调用限制</p>
<h2 id="启动时检查"><a href="#启动时检查" class="headerlink" title="启动时检查"></a>启动时检查</h2><p>缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止Spring初始化完成，也可以关闭</p>
<h2 id="直连消费者"><a href="#直连消费者" class="headerlink" title="直连消费者"></a>直连消费者</h2><p>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，<br>点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表。</p>
<h2 id="服务分组"><a href="#服务分组" class="headerlink" title="服务分组"></a>服务分组</h2><p>当一个接口有多种实现时，可以用group区分。</p>
<h2 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。<br>一般处理步骤</p>
<p> 1）在低压力时间段，先升级一半提供者为新版本 </p>
<p>2）再将所有消费者升级为新版本 </p>
<p>3）然后将剩下的一半提供者升级为新版本</p>
<h2 id="延迟暴露"><a href="#延迟暴露" class="headerlink" title="延迟暴露"></a>延迟暴露</h2><p>如果你的服务需要Warmup时间，比如初始化缓存，等待相关资源就位等，可以使用delay进行延迟暴露。 &lt;dubbo:provider delay=”-1” /&gt; 当然，也可以配置到服务级别。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/12/13/12-13技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/12-13技术笔记/" itemprop="url">Dubbo功能和简单配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-13T17:35:55+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Dubbo功能"><a href="#Dubbo功能" class="headerlink" title="Dubbo功能"></a>Dubbo功能</h1><h2 id="没有Dubbo的http"><a href="#没有Dubbo的http" class="headerlink" title="没有Dubbo的http"></a>没有Dubbo的http</h2><p>假设我们的系统非常简单，如何对外提供服务呢？</p>
<p>服务方启动一个tomcat+springmvc，监听80端口，调用方通过httpclient发起http请求，服务方返回json或xml数据结果，调用方拿到http响应结果解析结果数据，一次服务调用结束。</p>
<h2 id="注册中心与客户端负载均衡"><a href="#注册中心与客户端负载均衡" class="headerlink" title="注册中心与客户端负载均衡"></a>注册中心与客户端负载均衡</h2><p>随着服务的增多，一方面在配置中心，服务的内部域名化或url路径不断随业务变化；另一方面，服务器压力变大，这时也需要负载均衡。解决方法：</p>
<p>服务方在启动tomcat后，向注册中心注册自己的服务列表，包括服务器ip、port，以及代表服务的唯一标识，比如以格式/a_service/ip_port,/b_service/ip_port存储在注册中心。<br>这样调用方在启动后，去注册中心寻找a服务的地址列表，并且订阅/a_service，当a服务列表变更就会将变更消息推给调用方。接下来地址列表得到了，调用方创建多个httpClient实例，每个实例对应一个服务器ip_port，每次发起调用，从httpclient实例列表中随机选择一个，发起调用请求。当服务方某台服务器出现宕机或者网络故障，调用方会从收到由注册中心推送过来的通知消息，进而将出现故障的ip_port对应的httpclient从列表中移出；当服务方新增加服务器时，调用方同样会收到通知消息，进而新建httpclient实例，加入httpclient列表。  </p>
<h2 id="服务端负载均衡模块"><a href="#服务端负载均衡模块" class="headerlink" title="服务端负载均衡模块"></a>服务端负载均衡模块</h2><p>服务端也希望设置负载均衡的权重，权重高的服务器的收到更多的请求，这时服务端也向注册中心注册权重信息。</p>
<h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>对于不同的服务，容错机制也应该不同。非幂等操作-&gt;失败立刻报错；要求结果的-&gt;重试其他服务器；无所谓的-&gt;失败忽略；消息通知-&gt;失败重发。</p>
<h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><p>路由机制，Dubbo的路由机制主要解决的目的就是服务调用时，从已知的所有服务提供者中根据路由规则刷选服务提供者。多个业务系统都实现了同一个服务，在调用中通过读取相关配置可以知道此次调用是限制请求到哪几个服务提供者上，而不是所有提供者中任取一个，这个就需要在dubbo上自定义自己的路由规则。</p>
<h2 id="管理和监控"><a href="#管理和监控" class="headerlink" title="管理和监控"></a>管理和监控</h2><p>可视化管理中心，管理和监控各种性能。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>consumer向注册中心注册，并获取服务端相应的信息后，代理工厂创建的远程服务代理，完成了RPC调用。</p>
<h1 id="Dubbo配置"><a href="#Dubbo配置" class="headerlink" title="Dubbo配置"></a>Dubbo配置</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service/&gt; 服务配置，用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心。</span><br><span class="line">eg、&lt;dubbo:service ref=<span class="string">"demoService"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.unj.dubbotest.provider.DemoService"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:reference/&gt; 引用服务配置，用于创建一个远程服务代理，一个引用可以指向多个注册中心。</span><br><span class="line">eg、&lt;dubbo:reference id=<span class="string">"demoService"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.unj.dubbotest.provider.DemoService"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:protocol/&gt; 协议配置，用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受。</span><br><span class="line">eg、&lt;dubbo:protocol name=<span class="string">"dubbo"</span> port=<span class="string">"20880"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:application/&gt; 应用配置，用于配置当前应用信息，不管该应用是提供者还是消费者。</span><br><span class="line">eg、&lt;dubbo:application name=<span class="string">"xixi_provider"</span> /&gt;</span><br><span class="line">    &lt;dubbo:application name=<span class="string">"hehe_consumer"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:<span class="keyword">module</span>/&gt; 模块配置，用于配置当前模块信息，可选。</span><br><span class="line">&lt;dubbo:registry/&gt; 注册中心配置，用于配置连接注册中心相关信息。</span><br><span class="line">eg、&lt;dubbo:registry address=<span class="string">"zookeeper://192.168.2.249:2181"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:monitor/&gt; 监控中心配置，用于配置连接监控中心相关信息，可选。</span><br><span class="line">&lt;dubbo:provider/&gt; 提供方的缺省值，当ProtocolConfig和ServiceConfig某属性没有配置时，采用此缺省值，可选。</span><br><span class="line">&lt;dubbo:consumer/&gt; 消费方缺省配置，当ReferenceConfig某属性没有配置时，采用此缺省值，可选。</span><br><span class="line">&lt;dubbo:method/&gt; 方法配置，用于ServiceConfig和ReferenceConfig指定方法级的配置信息。</span><br><span class="line">&lt;dubbo:argument/&gt; 用于指定方法参数配置。</span><br></pre></td></tr></table></figure>
<h2 id="集群容错方案"><a href="#集群容错方案" class="headerlink" title="集群容错方案"></a>集群容错方案</h2><ol>
<li><p>Failover Cluster失败自动切换，当出现失败，重试其它服务器。(缺省)通常用于读操作，但重试会带来更长延迟。可通过retries=”2”来设置重试次数(不含第一次)。</p>
</li>
<li><p>Failfast Cluster 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
</li>
<li><p>Failsafe Cluster失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
</li>
<li><p>Failback Cluster，失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
</li>
<li><p>Forking Cluster并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks=”2”来设置最大并行数。</p>
</li>
<li><p>Broadcast Cluster，广播调用所有提供者，逐个调用，任意一台报错则报错。(2.1.0开始支持)通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
</li>
</ol>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><ol>
<li><p>Random LoadBalance（默认），随机，其实最后就会平均。</p>
</li>
<li><p>RoundRobin LoadBalance，轮询，适用于机器性能有差异，能者多劳。但实际上，自己加的权不一定是真正的性能个差异，导致慢的积累。</p>
</li>
<li><p>LeastActive LoadBalance， 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>
</li>
<li><p>ConsistentHash LoadBalance，一致性哈希。一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/12/12/12-12技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/12/12-12技术笔记/" itemprop="url">zookeeper使用场景</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-12T19:31:12+08:00">
                2018-12-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据发布与订阅（配置中心）"><a href="#数据发布与订阅（配置中心）" class="headerlink" title="数据发布与订阅（配置中心）"></a>数据发布与订阅（配置中心）</h1><p>发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。</p>
<p>这类场景通常是这样：应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。</p>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。</p>
<p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。</p>
<p>Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表。</p>
<p><strong>服务提供者</strong>在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。</p>
<p><strong>服务消费者</strong>启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址， 并向/dubbo/${serviceName} /consumers目录下写入自己的URL地址。</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>基于zookeeper的强一致性，通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。</p>
<p>也可以保持时序执行，做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
<h1 id="分布通知-协调"><a href="#分布通知-协调" class="headerlink" title="分布通知/协调"></a>分布通知/协调</h1><p> 使用方法通常是不同系统都对ZK上同一个znode进行注册，监听znode的变化(包括znode本身内容及子节点的)，其中一个系统update了znode，那么另一个系统能够收到通知，并作出相应处理。</p>
<h1 id="集群管理与Master选举"><a href="#集群管理与Master选举" class="headerlink" title="集群管理与Master选举"></a>集群管理与Master选举</h1><p>集群中，可以监控在线，动态上下线，以及选举master。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/12/12/leetcode20-21-28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/12/leetcode20-21-28/" itemprop="url">有效的括号，合并两个有序单链表，子串在字符串中的位置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-12T19:02:38+08:00">
                2018-12-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="20"><a href="#20" class="headerlink" title="20"></a>20</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，只包含’(‘, ‘)’, ‘{‘, ‘}’, ‘[’ 和’]’这些字符，检查它是否是“有效”的。<br>括号必须以正确的顺序关闭，例如”()” 和”()[]{}”都是有效的，”(]” 和”([)]”是无效的。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>栈的基础题，左括号入栈，匹配出栈即可。注意判断栈是否已空。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> a = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="string">'&#123;'</span>||a==<span class="string">'['</span>||a==<span class="string">'('</span>)&#123;</span><br><span class="line">                stack.push(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.empty()&amp;&amp;stack.peek() == <span class="string">'('</span>) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.empty()&amp;&amp;stack.peek() == <span class="string">'['</span>) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">'&#125;'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.empty()&amp;&amp;stack.peek() == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>栈操作都忘了，pop是出栈，peak是栈顶元素。</p>
<h1 id="21"><a href="#21" class="headerlink" title="21"></a>21</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>合并两个有序单链表</p>
<h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><p>链表操作不熟练的话，还是有点困难，我采用转list排序再转回去的方法，还是有点蠢。</p>
<h2 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       ListNode o1=l1,o2=l2;</span><br><span class="line">       <span class="keyword">while</span> (o1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           list.add(o1.val);</span><br><span class="line">           o1=o1.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (o2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           list.add(o2.val);</span><br><span class="line">           o2=o2.next;</span><br><span class="line">       &#125;</span><br><span class="line">       Collections.sort(list);</span><br><span class="line">       ListNode tmp=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(!list.isEmpty()) &#123;</span><br><span class="line">           ListNode ans = <span class="keyword">new</span> ListNode(list.get(<span class="number">0</span>));</span><br><span class="line">           tmp = ans;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">               ListNode next = <span class="keyword">new</span> ListNode(list.get(i));</span><br><span class="line">               ans.next = next;</span><br><span class="line">               ans = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tmp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>实际上应该用正统链表操作的话，可以加一个“哨兵”节点，就是说在头结点之前的，没有值，只用来开头的节点，以避免一些空指针问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode currentNode=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span>&amp;&amp;l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2!=<span class="keyword">null</span>&amp;&amp;(l1==<span class="keyword">null</span>||l1.val&gt;l2.val))&#123;</span><br><span class="line">                currentNode.next=l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                currentNode.next=l1;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            currentNode=currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h2><p>实际上，链表和链表的节点是同一个东西，都只是对该节点持有的引用。原来C中，习惯起好几个别名，把我搞晕了。据说链表的常用操作有5种。</p>
<ol>
<li><p>反转单链表。用三个指针操作解决。</p>
</li>
<li><p>合并有序链表。如上</p>
</li>
<li><p>判断链表是否有环。一快一慢两个指针，快的每次两格，慢的每次一格。如果有环，将跑不完，最后绕圈子，绕圈子后果是套圈，也即是说，两个指针相遇。</p>
</li>
<li><p>倒数第n个节点。也是双指针法，倒数第n个节点，就是正数第a-n个节点,让第一个指针先移动n个，这样它离到达结尾还剩a-n步，这时，第一个和第二个指针一起移动这a-n步，则第二个指针到达倒数n。</p>
</li>
<li><p>求链表中间节点。有点像上面两者结合，快的每次两格，慢的每次一格，快的到终点了，慢的到了一半。分下奇偶。</p>
</li>
</ol>
<h1 id="28"><a href="#28" class="headerlink" title="28"></a>28</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>求子串在字符串中的位置。</p>
<h2 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h2><p>java内置的有类库实现，indexOf()方法。实际上，考察的是KMP算法。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h2><p>KMP算法还是比较复杂的，有点像动态规划。</p>
<blockquote>
<p><a href="https://blog.csdn.net/gesanghuazgy/article/details/52214718" target="_blank" rel="noopener">https://blog.csdn.net/gesanghuazgy/article/details/52214718</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/12/11/12-11技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/12-11技术笔记/" itemprop="url">Zookeeper特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-11T19:37:22+08:00">
                2018-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h2><p>zookeeper集群角色有三种，leader，follower，observer。权限上的区别，follower不能写，observer不参加leader选举，也不参加过半写成功策略。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>客户端和服务器通过TCP连接建立会话，通过心跳检测保持有效，可以向服务器发送请求接受响应，还可以接受Watch事件的通知。重连时，连上任意一台，即可视为重连有效。</p>
<h2 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h2><p>所有数据都存在内存中，数据节点之间是树状结构，这样像文件系统一样，用/斜杠分隔符表示路径就可以找到节点。</p>
<p>节点分类有两种维度：永久节点和临时节点，可以理解为，前者是服务端用的，后者是客户端用的；顺序节点和非顺序节点，顺序节点，就是父节点在创建下一级子节点的时候，记录每个子节点创建的先后顺序，会给每个子节点名加上一个数字后缀。</p>
<p>临时节点不能创建子节点。</p>
<p>Zookeeper <strong>不能用于存放大量的数据</strong>   ，每个节点的存放数据上限为<strong><em>1M</em></strong>。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>每个ZNode(节点)上都会存储数据。（为了分布式一致性需要？）每个节点都有版本，一共有三种同时维护：自己的，子节点的，ACL版本。</p>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p>客户端可以在指定节点上注册一些Watcher，当事件触发时，服务端会主动通知客户端。一个Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端，以便通知它们。</p>
<p>也就是说Watcher是一次性的，一方面节省服务端性能，另一方面客户端也不需要知道每次变化，只用知道最新的变化即可。</p>
<p>也就是说，客户端不能接收到所有的节点变化通知，因为即使你每次接受到通知就立刻注册Watcher，在这个过程过，数据也有可能已经发生了多次修改。</p>
<h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><p>即控制访问列表，用来权限控制。创建更新获取删除子节点等权限。</p>
<h1 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h1><p>ZooKeeper没有完全采用paxos，而是使用了自己修改过的ZAB协议。</p>
<h2 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h2><p>针对客户端的事务请求，ZAB区别在于，只有一个proposal，然后收集选票，最后事务提交。类似于2PC的过程。为了保证事务的顺序性，所有的proposal都在被提出的时候加上了zxid。</p>
<h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p>2PC问题在于，leader崩溃会导致无法继续，这里采用了崩溃恢复机制，重新选举Leader。谁被选上主要取决于zxid。</p>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>选举完Leader后，通过事务日志，观察Proposal是否被集群中过半的机器提交。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>在一个客户端修改数据后，ZooKeeper不能确保任何客户端能够获取（即Read Request）到一样的数据，除非客户端自己要求：方法是客户端在获取数据之前调用sync方法。    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/12/11/leetcode1,8,15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/leetcode1,8,15/" itemprop="url">两数和，字符串转数字，三数和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-11T10:42:05+08:00">
                2018-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给一个int数组，和一个目标数，数组中某两数只和为目标数，要求找到这两个数的下标。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>遍历数组时，将数和下标存入一个哈希表中，同时查找和目标数差值是否在哈希表中即可。一次遍历。复杂度O(N)。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int ans[] = new int[2] ;</span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        for (int i = 0;i&lt;nums.length;i++) &#123;</span><br><span class="line">            if(hashMap.containsKey(target-nums[i]))&#123;</span><br><span class="line">                ans[0]=(int)hashMap.get(target-nums[i]);</span><br><span class="line">                ans[1]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>其实大学时，经常听人说哈希表的思路，但当时的理解只是数组下标和数组内容的映射，因为C数据结构似乎都要手动实现，所以直接使用HashMap也没那么方便，也不知道。Java封装好了的，用即可。</p>
<h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>字符串转数字。前面的空格忽略。比如”42”-&gt;42,”    -40”-&gt;-40,” 42avv”-&gt;42,”dw42”-&gt;0;</p>
<h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><p>其实没啥好说的，遍历字符串，处理各种情况即可。</p>
<ol>
<li>Character.isWhitespace()判断空字符</li>
<li>str.charAt(begin) &lt;= 57 &amp;&amp; str.charAt(begin) &gt;= 48判断是数字</li>
<li>str.charAt(u) - ‘0’字符转数字        </li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public int myAtoi(String str) &#123;</span><br><span class="line">        int begin = 0, ans = 0, flag = 1;</span><br><span class="line">        if(str.length() != 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">                char a = str.charAt(i);</span><br><span class="line">                if(Character.isWhitespace(a)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    begin = i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(str.charAt(begin) == &apos;-&apos;) &#123;</span><br><span class="line">                flag = -1;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(str.charAt(begin) == &apos;+&apos;)&#123;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(begin == str.length()) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                if(str.charAt(begin) &lt;= 57 &amp;&amp; str.charAt(begin) &gt;= 48) &#123;</span><br><span class="line">                    for (int u = begin; u &lt; str.length(); u++) &#123;</span><br><span class="line">                        if(!(str.charAt(u) &lt;= 57 &amp;&amp; str.charAt(u) &gt;= 48)) &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;else &#123;</span><br><span class="line">                            if(flag * (ans * 10D + (str.charAt(u) - &apos;0&apos;)) &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                                return Integer.MAX_VALUE;</span><br><span class="line">                            &#125;else if(flag * (ans * 10D + (str.charAt(u) - &apos;0&apos;)) &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                                return Integer.MIN_VALUE;</span><br><span class="line">                            &#125;else &#123;</span><br><span class="line">                                ans = ans * 10 + (str.charAt(u) - &apos;0&apos;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                return ans * flag;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想-1"><a href="#感想-1" class="headerlink" title="感想"></a>感想</h2><p>leetcode最令人感动的是，告诉哪个测试数据错了啊。大学时不想做oj，最大的原因就是反正就是Error,然而自己和样例输出对比结果是一样的，就是不知道哪个测试数据过不了，简直折磨。<br>三次错误分别是:1.空字符串;2.只有一个负号后面没数字3.正号。</p>
<h1 id="15"><a href="#15" class="headerlink" title="15"></a>15</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>三数求和，类似于第一题，题目有所简化，和不是给出的，而是固定的。给定一个数组，他们某三个之和为0，输出所有的不重复组合。</p>
<h2 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h2><p>用的是首尾两指针向中间移动法。这样一种简化情况，求哪两数和为某个值，先把数组排序，首尾两个指针，如果所指两数之和小于给定值，说明左指针该右移。反之的话，就反过来。然后我们固定第一个数，后面两个数用这个方法就好。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 2; i++) &#123;</span><br><span class="line">        if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int l = i + 1, r = nums.length - 1;//下一个元素，最后一个元素</span><br><span class="line">       while (l&lt;r) &#123;//两个指针向中间移动</span><br><span class="line">            if(nums[l] + nums[r] +nums[i]== 0) &#123;//得到答案</span><br><span class="line">                List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">                arrayList.add(nums[i]);</span><br><span class="line">                arrayList.add(nums[l]);</span><br><span class="line">                arrayList.add(nums[r]);</span><br><span class="line">                ans.add(arrayList);</span><br><span class="line"></span><br><span class="line">                while (l &lt; r &amp;&amp; nums[l + 1] == nums[l]) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">                while (l &lt; r &amp;&amp; nums[r - 1] == nums[r]) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[l] + nums[r] +nums[i]&gt; 0) &#123;//如果大了，右指针左移</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[l] + nums[r] +nums[i]&lt; 0) &#123;//如果小了，左指针右移</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想-2"><a href="#感想-2" class="headerlink" title="感想"></a>感想</h2><p>其实两指针向中间移动这方法很正常啊，但不知为什么，内心潜意识总觉得这种方法会漏掉情况，我觉得关键是如果数组是有序的，求和这个情况的确不会漏掉。什么时候会漏掉，却暂时想不到。</p>
<p>与其在循环里反复判断跳出，为什么不直接写在循环条件里呢233</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/12/07/12-7技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/12-7技术笔记/" itemprop="url">redis运营细节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T18:02:32+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>新版本redis退出了stream，这样基本实现了消息中间件功能。借鉴了很多kafka设计，功能似乎很齐全。</p>
<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>redis运维指令info，告诉各种运行状况</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>集群下使用分布式锁，有一致性问题，比如在 Sentinel 集群中，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。<br>如果不能容忍的话，redis有redlock算法，牺牲了性能，增加了类库，解决了这个问题。但是我觉得，还是应该从业务出发。redis应该性能优先，保证安全性不应该在redis这一层做。</p>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>为了避免很多同时过期，带来淘汰的压力。应该给expire加上个随机的时间，这样过期会均匀分布。</p>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>Redis基于内存的，但当内存空间不足时，需要和磁盘交互。此时采用的是随机方法逼近LRU(最近最久未使用)，即每次随机采样，淘汰最旧。但我觉得，不应该让redis内存溢出，而不是靠与磁盘交互来解决问题。</p>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>Java 程序一般都是多线程的应用程序，意味着我们很少直接使用 Jedis，而是要用到 Jedis 的连接池 —— JedisPool。同时因为 Jedis 对象不是线程安全的，当我们要使用 Jedis 对象时，需要从连接池中拿出一个 Jedis 对象独占，使用完毕后再将这个对象还给连接池。为了避免在使用时出现异常，应该用try-with-resource 语句来保护 Jedis 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    JedisPool pool = new JedisPool();</span><br><span class="line">    try (Jedis jedis = pool.getResource()) &#123; // 用完自动 close</span><br><span class="line">      doSomething(jedis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/12/06/12-6技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/12-6技术笔记/" itemprop="url">redis分布式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-06T19:55:00+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="主从备份"><a href="#主从备份" class="headerlink" title="主从备份"></a>主从备份</h1><p>redis支持主从备份，但从机只是防宕机的备份作用，采用读写分离可以缓解主机压力，但由于每次写操作后，主机数据同步到从机的过程，是非阻塞异步的，意味着这样有数据一致性的问题。</p>
<h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><p>哨兵机制是，主机挂了自动找到合适的从机，并且将从机切换为主机。功能上，监控了主机和各从机是否正常；如果某redis实例有故障，通知管理员；出现故障后，自动找到从机将其切换为主机；如果故障转移发生了，通知client客户端有新的master地址。<br>为了避免哨兵自己挂了，哨兵也是集群的方式。</p>
<h2 id="解决异步复制的一致性和脑裂问题"><a href="#解决异步复制的一致性和脑裂问题" class="headerlink" title="解决异步复制的一致性和脑裂问题"></a>解决异步复制的一致性和脑裂问题</h2><p>即，主机新的数据，还没复制到从机，主机就挂了怎么办。根据CAP定理，这个问题是无法完美解决的，只能有所取舍。取舍程度取决于两个参数：min-slaves-to-write 1 和 min-slaves-max-lag 10：<br>这两个参数的意思就是，要求至少有1个slave，数据复制和同步的延迟不能超过10s，如果说一旦所有的slave，数据复制和同步的延迟都超过10s，那么这个时候，master就不会再接受任何请求了。<br>一旦slave复制数据和ack延迟时间太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样就可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低到可控范围内。<br>如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保的说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求。这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失。</p>
<h1 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h1><p>redis单机单线程，解决方法最简单就是集群。Redis Cluster解决方法很简单，根据哈希值分池，对每个key值做CRC16取值，对16384求模后分池，redis cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot。hash slot让node的增加和移除很简单，增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去。<br>在redis cluster架构下，每个redis要放开两个端口号，比如一个是6379，另外一个就是加10000的端口号，比如16379。16379端口号是用来进行节点间通信的，也就是cluster bus的东西，集群总线。cluster bus的通信，用来进行故障检测，配置更新，故障转移授权等。cluster bus用了另外一种二进制的协议，主要用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/12/04/12-4技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/04/12-4技术笔记/" itemprop="url">redis原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-04T15:57:17+08:00">
                2018-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h1><p>redis是单线程的，内存的，但仍然很快，原因是多路复用技术。即事件轮询，select，NIO啊。</p>
<h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h1><p>redis用的自己的通信协议，是基于分隔符的，即回车换行符。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>持久化有两种方式，存量的RBD，增量的AOF。</p>
<h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>RDB是快照的形式每隔一段时间，新起一个<strong>进程</strong>，数据集快照写入磁盘。简单来说，fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>AOF是日志的形式，就是记录每一个对数据有改变的操作，存在日志里。以文本的方式记录，可以打开文件看到详细的操作记录。实际上文件在内存里，还需要写回磁盘，写回磁盘有三种策略，每次操作：性能很差；每秒：意味着秒级别的数据丢失；从无：依赖于操作系统，不安全。这么看一般都是用折中的每秒。<br>对于日益增长的AOF文件，还可以瘦身，即AOF重写，开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>RDB缺点有两个，一是每隔一段时间，要是宕机，隔的时间里没了。比如说，每1分钟快照一次，第2分30秒挂了，那第2分钟到第二分钟30秒这三十秒的数据丢失了。二是新起一个进程，数据集较大时，备份会卡顿<br>AOF缺点在于，备份文件较大，重放耗时较长。<br>现在支持混合持久化，将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。</p>
<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道实际上不是redis的技术，而是来自于客户端的操作。管道简单来说，就是把多次读写请求放一起。<br>没有管道，客户端与服务端交互是：写“读数据1”请求，读“数据1”回应。写“读数据2”请求，读“数据2”回应。写“读数据2”请求，读“数据2”回应。这样来回操作。<br>使用管道，就是把请求放在一起，变成：写“读数据123”请求，读“数据123”回应。这样就节省了时间。<br>就像批处理请求，这样，使用管道的场景应该是，这些交互都是独立的，他们之间没有先后互不依赖，这样才可以放一起。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="无原子性"><a href="#无原子性" class="headerlink" title="无原子性"></a>无原子性</h2><p>redis的事务和数据库事务并不是同义词，即使使用了事务，也不能保证原子性，仅仅是满足了事务的「隔离性」，隔离性中的串行化——当前执行的事务有着不被其它事务打断的权利。<br>形式上和一般事务差不多，multi 指示事务的开始，exec 指示事务的执行，discard 指示事务的丢弃。但这里没有回滚。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为了性能，事务应该和管道一起进行。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>分布式锁是悲观锁，redis也有乐观锁机制，即watch。乐观锁就是监测变量在事务过程中有没有变化，要是没有，说明没有并发问题，就提交。<br>watch应该在multi之前。操作顺序应该是，watch 变量-&gt;变量操作-&gt;multi-&gt;set提交修改-&gt;exec；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    jedis.watch(key); //watch 变量</span><br><span class="line">    int value = Integer.parseInt(jedis.get(key));</span><br><span class="line">    value *= 2; // 变量操作</span><br><span class="line">    Transaction tx = jedis.multi(); //multi</span><br><span class="line">    tx.set(key, String.valueOf(value)); //set提交修改</span><br><span class="line">    List&lt;Object&gt; res = tx.exec(); //exec</span><br><span class="line">    if (res != null) &#123;</span><br><span class="line">      break; // 成功了</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Integer.parseInt(jedis.get(key)); // 重新获取余额</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>redis做的消息队列PubSub基本已经凉了，有个新的未发布的Disque。Redis5.0 新增了 Stream 数据结构，这个功能给 Redis 带来了持久化消息队列.</p>
<h1 id="小对象压缩"><a href="#小对象压缩" class="headerlink" title="小对象压缩"></a>小对象压缩</h1><h2 id="32位编译"><a href="#32位编译" class="headerlink" title="32位编译"></a>32位编译</h2><p>如果占用内存不超过4G，可以采用更快的32位编译，指令更短。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>当数据较少时，使用ziplist，将稀疏二维矩阵一维化，节省空间。<br>采用了类似池化的技术，并不直接回收内存，而是分页的方式留待下次使用。<br>内存分配没有自己做，用的第三方的，有facebook家的jemalloc，谷歌家的tcmalloc，默认的前者性能好。</p>
<h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><p>根据CAP定理，在网络分区下，一致性和可用性无法同时获得。白话来说，如果主机和从机之间的网络断开了，如果主机继续运行，从机无法备份，那么主从数据将不一致；如果主机暂时停机，等从机再连上，那么服务将暂时不可用。<br>在这种情况下，redis的取舍是牺牲一致性，也就是等连上了，从机再追回数据。</p>
<h2 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h2><p>主机将影响状态的增量操作存在缓存中，等连上了后，传给从机，从机同步数据。然而缓存有限，后面的数据会覆盖前面的，如果数据太多，有特别久的操作将无法同步。</p>
<h2 id="存量同步"><a href="#存量同步" class="headerlink" title="存量同步"></a>存量同步</h2><p>用快照将内存所有数据存在磁盘，再传给从库，从库复制数据。时间较长。</p>
<h2 id="同步死循环"><a href="#同步死循环" class="headerlink" title="同步死循环"></a>同步死循环</h2><p>存量同步时间较长，期间又产生了数据，如果此时的数据又太多溢出了，则同步失败。</p>
<h2 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h2><p>redis也支持放弃可用性，得到一致性。以同步阻塞的方式同步，wait指令。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Arvense</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">250</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>


  
</div>


  <div class="powered-by">Powered by <a>Arvense</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">blog   </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
