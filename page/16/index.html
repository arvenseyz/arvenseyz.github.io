<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Arvense, NexT">





  <link rel="alternate" href="/blog/atom.xml" title="Arvense" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Arvense">
<meta property="og:url" content="http://yoursite.com/blog/page/16/index.html">
<meta property="og:site_name" content="Arvense">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Arvense">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/blog/page/16/">





  <title>Arvense</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Arvense</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/07/12-7技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/07/12-7技术笔记/" itemprop="url">redis运营细节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T18:02:32+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>新版本redis退出了stream，这样基本实现了消息中间件功能。借鉴了很多kafka设计，功能似乎很齐全。</p>
<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>redis运维指令info，告诉各种运行状况</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>集群下使用分布式锁，有一致性问题，比如在 Sentinel 集群中，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。<br>如果不能容忍的话，redis有redlock算法，牺牲了性能，增加了类库，解决了这个问题。但是我觉得，还是应该从业务出发。redis应该性能优先，保证安全性不应该在redis这一层做。</p>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>为了避免很多同时过期，带来淘汰的压力。应该给expire加上个随机的时间，这样过期会均匀分布。</p>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>Redis基于内存的，但当内存空间不足时，需要和磁盘交互。此时采用的是随机方法逼近LRU(最近最久未使用)，即每次随机采样，淘汰最旧。但我觉得，不应该让redis内存溢出，而不是靠与磁盘交互来解决问题。</p>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>Java 程序一般都是多线程的应用程序，意味着我们很少直接使用 Jedis，而是要用到 Jedis 的连接池 —— JedisPool。同时因为 Jedis 对象不是线程安全的，当我们要使用 Jedis 对象时，需要从连接池中拿出一个 Jedis 对象独占，使用完毕后再将这个对象还给连接池。为了避免在使用时出现异常，应该用try-with-resource 语句来保护 Jedis 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    JedisPool pool = new JedisPool();</span><br><span class="line">    try (Jedis jedis = pool.getResource()) &#123; // 用完自动 close</span><br><span class="line">      doSomething(jedis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/06/12-6技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/06/12-6技术笔记/" itemprop="url">redis分布式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-06T19:55:00+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="主从备份"><a href="#主从备份" class="headerlink" title="主从备份"></a>主从备份</h1><p>redis支持主从备份，但从机只是防宕机的备份作用，采用读写分离可以缓解主机压力，但由于每次写操作后，主机数据同步到从机的过程，是非阻塞异步的，意味着这样有数据一致性的问题。</p>
<h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><p>哨兵机制是，主机挂了自动找到合适的从机，并且将从机切换为主机。功能上，监控了主机和各从机是否正常；如果某redis实例有故障，通知管理员；出现故障后，自动找到从机将其切换为主机；如果故障转移发生了，通知client客户端有新的master地址。<br>为了避免哨兵自己挂了，哨兵也是集群的方式。</p>
<h2 id="解决异步复制的一致性和脑裂问题"><a href="#解决异步复制的一致性和脑裂问题" class="headerlink" title="解决异步复制的一致性和脑裂问题"></a>解决异步复制的一致性和脑裂问题</h2><p>即，主机新的数据，还没复制到从机，主机就挂了怎么办。根据CAP定理，这个问题是无法完美解决的，只能有所取舍。取舍程度取决于两个参数：min-slaves-to-write 1 和 min-slaves-max-lag 10：<br>这两个参数的意思就是，要求至少有1个slave，数据复制和同步的延迟不能超过10s，如果说一旦所有的slave，数据复制和同步的延迟都超过10s，那么这个时候，master就不会再接受任何请求了。<br>一旦slave复制数据和ack延迟时间太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样就可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低到可控范围内。<br>如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保的说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求。这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失。</p>
<h1 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h1><p>redis单机单线程，解决方法最简单就是集群。Redis Cluster解决方法很简单，根据哈希值分池，对每个key值做CRC16取值，对16384求模后分池，redis cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot。hash slot让node的增加和移除很简单，增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去。<br>在redis cluster架构下，每个redis要放开两个端口号，比如一个是6379，另外一个就是加10000的端口号，比如16379。16379端口号是用来进行节点间通信的，也就是cluster bus的东西，集群总线。cluster bus的通信，用来进行故障检测，配置更新，故障转移授权等。cluster bus用了另外一种二进制的协议，主要用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/04/12-4技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/04/12-4技术笔记/" itemprop="url">redis原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-04T15:57:17+08:00">
                2018-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h1><p>redis是单线程的，内存的，但仍然很快，原因是多路复用技术。即事件轮询，select，NIO啊。</p>
<h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h1><p>redis用的自己的通信协议，是基于分隔符的，即回车换行符。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>持久化有两种方式，存量的RBD，增量的AOF。</p>
<h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>RDB是快照的形式每隔一段时间，新起一个<strong>进程</strong>，数据集快照写入磁盘。简单来说，fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>AOF是日志的形式，就是记录每一个对数据有改变的操作，存在日志里。以文本的方式记录，可以打开文件看到详细的操作记录。实际上文件在内存里，还需要写回磁盘，写回磁盘有三种策略，每次操作：性能很差；每秒：意味着秒级别的数据丢失；从无：依赖于操作系统，不安全。这么看一般都是用折中的每秒。<br>对于日益增长的AOF文件，还可以瘦身，即AOF重写，开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>RDB缺点有两个，一是每隔一段时间，要是宕机，隔的时间里没了。比如说，每1分钟快照一次，第2分30秒挂了，那第2分钟到第二分钟30秒这三十秒的数据丢失了。二是新起一个进程，数据集较大时，备份会卡顿<br>AOF缺点在于，备份文件较大，重放耗时较长。<br>现在支持混合持久化，将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。</p>
<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道实际上不是redis的技术，而是来自于客户端的操作。管道简单来说，就是把多次读写请求放一起。<br>没有管道，客户端与服务端交互是：写“读数据1”请求，读“数据1”回应。写“读数据2”请求，读“数据2”回应。写“读数据2”请求，读“数据2”回应。这样来回操作。<br>使用管道，就是把请求放在一起，变成：写“读数据123”请求，读“数据123”回应。这样就节省了时间。<br>就像批处理请求，这样，使用管道的场景应该是，这些交互都是独立的，他们之间没有先后互不依赖，这样才可以放一起。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="无原子性"><a href="#无原子性" class="headerlink" title="无原子性"></a>无原子性</h2><p>redis的事务和数据库事务并不是同义词，即使使用了事务，也不能保证原子性，仅仅是满足了事务的「隔离性」，隔离性中的串行化——当前执行的事务有着不被其它事务打断的权利。<br>形式上和一般事务差不多，multi 指示事务的开始，exec 指示事务的执行，discard 指示事务的丢弃。但这里没有回滚。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为了性能，事务应该和管道一起进行。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>分布式锁是悲观锁，redis也有乐观锁机制，即watch。乐观锁就是监测变量在事务过程中有没有变化，要是没有，说明没有并发问题，就提交。<br>watch应该在multi之前。操作顺序应该是，watch 变量-&gt;变量操作-&gt;multi-&gt;set提交修改-&gt;exec；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    jedis.watch(key); //watch 变量</span><br><span class="line">    int value = Integer.parseInt(jedis.get(key));</span><br><span class="line">    value *= 2; // 变量操作</span><br><span class="line">    Transaction tx = jedis.multi(); //multi</span><br><span class="line">    tx.set(key, String.valueOf(value)); //set提交修改</span><br><span class="line">    List&lt;Object&gt; res = tx.exec(); //exec</span><br><span class="line">    if (res != null) &#123;</span><br><span class="line">      break; // 成功了</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Integer.parseInt(jedis.get(key)); // 重新获取余额</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>redis做的消息队列PubSub基本已经凉了，有个新的未发布的Disque。Redis5.0 新增了 Stream 数据结构，这个功能给 Redis 带来了持久化消息队列.</p>
<h1 id="小对象压缩"><a href="#小对象压缩" class="headerlink" title="小对象压缩"></a>小对象压缩</h1><h2 id="32位编译"><a href="#32位编译" class="headerlink" title="32位编译"></a>32位编译</h2><p>如果占用内存不超过4G，可以采用更快的32位编译，指令更短。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>当数据较少时，使用ziplist，将稀疏二维矩阵一维化，节省空间。<br>采用了类似池化的技术，并不直接回收内存，而是分页的方式留待下次使用。<br>内存分配没有自己做，用的第三方的，有facebook家的jemalloc，谷歌家的tcmalloc，默认的前者性能好。</p>
<h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><p>根据CAP定理，在网络分区下，一致性和可用性无法同时获得。白话来说，如果主机和从机之间的网络断开了，如果主机继续运行，从机无法备份，那么主从数据将不一致；如果主机暂时停机，等从机再连上，那么服务将暂时不可用。<br>在这种情况下，redis的取舍是牺牲一致性，也就是等连上了，从机再追回数据。</p>
<h2 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h2><p>主机将影响状态的增量操作存在缓存中，等连上了后，传给从机，从机同步数据。然而缓存有限，后面的数据会覆盖前面的，如果数据太多，有特别久的操作将无法同步。</p>
<h2 id="存量同步"><a href="#存量同步" class="headerlink" title="存量同步"></a>存量同步</h2><p>用快照将内存所有数据存在磁盘，再传给从库，从库复制数据。时间较长。</p>
<h2 id="同步死循环"><a href="#同步死循环" class="headerlink" title="同步死循环"></a>同步死循环</h2><p>存量同步时间较长，期间又产生了数据，如果此时的数据又太多溢出了，则同步失败。</p>
<h2 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h2><p>redis也支持放弃可用性，得到一致性。以同步阻塞的方式同步，wait指令。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/12/03/12-3技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/03/12-3技术笔记/" itemprop="url">netty编解码器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-03T14:32:43+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>ByteToMessageDecoder有decodeLast方法，Netty提供的这个默认实现只是简单地调用了decode()方法。当Channel的状态变为非活动时，这个方法将会被调用一次。可以重写该方法以提供特殊的处理，比如产生一个一个 LastHttpContent 消息。</li>
<li>ReplayingDecoder扩展了ByteToMessageDecoder类，使得我们不必调用 readableBytes()方法。它通过使用一个自定义的ByteBuf实现 ，ReplayingDecoderByteBuf，包装传入的ByteBuf实现了这一点，其将在内部执行该调用。简单来说，不用数字节，每四个读一个int.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* if (in.readableBytes() &gt;= 4) &#123;</span><br><span class="line">  *     out.add(in.readInt());</span><br><span class="line">  &#125;*/</span><br><span class="line">//上面的操作被下面替代</span><br><span class="line">out.add(in.readInt());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>ReplayingDecoder 和ByteToMessageDecoder 最大的不同就是ReplayingDecoder 允许你实现decode()和decodeLast()就像所有的字节已经接收到一样，不需要判断可用的字节</p>
<ol start="3">
<li>由于 Netty 是一个异步框架，所以需要在字节可以解码之前在内存中缓冲它们。因此，不能让解码器缓冲大量的数据以至于耗尽可用的内存。为了解除这个常见的顾虑，Netty 提供了TooLongFrameException 类，该异常在ChannelHandler.exceptionCaught()其将由解码器在帧超出指定的大小限制时抛出。有些协议如HTTP可能有对应的操作，比如返回一个响应，但大部分选择都是关闭连接。</li>
<li>Codec结尾的编解码器是双向的。ByteToMessageCodec。我觉得，从这来看，发送的消息不一定要是个实体，以字节的形式发送，然后用ReplayingDecoder解决沾包拆包，最后接受方把收到的字节解析成实体，或许是更好的方式？</li>
<li><p>CombinedChannelDuplexHandler通过提供分别继承了解码器类和编码器类的类型，我们可以实现一个编解码器，而又不必直接扩展抽象的编解码器类。这样意义在于提高重用性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CombinedByteCharCodec extends</span><br><span class="line">CombinedChannelDuplexHandler&lt;ByteToCharDecoder, CharToByteEncoder&gt; &#123;</span><br><span class="line">  public CombinedByteCharCodec() &#123;</span><br><span class="line">      super(new ByteToCharDecoder(), new CharToByteEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>支持SSl/TSL非常简单，继承ChannelInitializer，把jdk的（或者netty的性能更好的）Handler加载pipeline的首位即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void initChannel(Channel ch) throws Exception &#123;</span><br><span class="line">  SSLEngine engine = context.newEngine(ch.alloc());</span><br><span class="line">  ch.pipeline().addFirst(&quot;ssl&quot;,</span><br><span class="line">  new SslHandler(engine, startTls));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP的支持同样简单，http+response/request+encoder/decoder,四种编解码器。此外还应该用聚合器HttpObjectAggregator来聚合消息，用服务器用压缩器HttpContentCompressor()压缩，客户端用HttpContentDecompressor()解压。</p>
</li>
<li><p>对websocket的支持也是通过Handler实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(</span><br><span class="line">        new HttpServerCodec(),</span><br><span class="line">        new HttpObjectAggregator(65536), //聚合</span><br><span class="line">        new WebSocketServerProtocolHandler(&quot;/websocket&quot;),//如果被请求 HttpRequest的端点是&quot;/websocket&quot;，则处理该升级握手</span><br><span class="line">        new TextFrameHandler(),//自己完成三种不同的数据帧处理器，来处理不同的websocket数据</span><br><span class="line">        new BinaryFrameHandler(),</span><br><span class="line">        new ContinuationFrameHandler());</span><br></pre></td></tr></table></figure>
</li>
<li><p>IdleStateHandler处理心跳和超时,当连接空闲时间太长时，将会触发一个 IdleStateEvent 事件。然后，你可以通过在你的 ChannelInboundHandler 中重写 userEventTriggered()方法来处理该IdleStateEvent 事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">        if(evt instanceof IdleStateEvent) &#123; //发送心跳消息，并在发送失败时关闭该连接</span><br><span class="line">            ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate()).addListener(</span><br><span class="line">                    ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            super.userEventTriggered(ctx, evt);//不是 IdleStateEvent事件，所以将它传递给下一个 ChannelInboundHandler</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此外还有ReadTimeoutHandler和WriteTimeoutHandler，他们会抛异常，捕获异常处理超时。</p>
<ol start="10">
<li>FileRegion写文件等大型数据,可以直接往channel里面写入一个FileRegion对象，而不需要相应的encoder,比如ch.write(region); 。在需要将数据从文件系统复制到用户内存中时，可以使用 ChunkedWriteHandler,要使用你自己的 ChunkedInput 实现，需要在 ChannelPipeline 中安装一个ChunkedWriteHandler。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final FileRegion region =  new DefaultFileRegion(raf.getChannel(), 0, fileLength);  </span><br><span class="line">ch.write(region);  </span><br><span class="line">@Override</span><br><span class="line">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">  super.channelActive(ctx);</span><br><span class="line">  ctx.writeAndFlush(new ChunkedStream(new FileInputStream(file)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/30/11-30技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/30/11-30技术笔记/" itemprop="url">redis高阶数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-30T15:50:23+08:00">
                2018-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>数据是布尔类型的时候，进行记录可以使用位图，即每个数据占一位而不是一字节。最简单的使用场景就是签到表啦。还有在线人数统计之内。<br>我看来，位图实际上是三维的，key,value,exist,所以很适合做签到这种事，因为也是三维的：用户，日期，是否签到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.setbit(offsetDate, user_id, 1);</span><br></pre></td></tr></table></figure></p>
<p>统计也很简单，某天的活跃用户数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String key = offsetDate;</span><br><span class="line">BitSet users = BitSet.valueOf(redis.get(key.getBytes()));</span><br><span class="line">users.cardinality();</span><br></pre></td></tr></table></figure></p>
<p>用BitSet相关计算，第一和第二天的交集，就是首日留存，之类的所有操作。<br>如果交换key,value值的位置，则是反过来统计，比如本月用户签到了多少次，某天用户是否签到。redis-&gt;bitCount($UserID)</p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><ol>
<li>HyperLogLog是去重计数器。比如统计访客数量，简单做法是，一个Set，来一个人就sadd加进集合，要计数就scard数一下集合里多少个。HyperLogLog就是针对这种情况设计的，功能单一，只有 pfadd 和 pfcount，加进去和计数。还有pfmerge合并计数器。   </li>
<li>优势：内部实现靠复杂的数学计算，而不是萝卜占坑，因而存储空间占用很小。   </li>
<li>缺点：其实是估算出来的，存在0.81%，也就是说不到1%的误差。    </li>
<li>使用场景：去重计数。    </li>
<li>原理和使用限制：分桶计数，用到的是 16384 个桶，也就是 2^14，每个桶的 maxbits 需要 6 个 bits 来存储，最大可以表示 maxbits=63，于是总共占用内存就是2^14 * 6 / 8 = 12k字节。即数据量很少也要12k，但适用于大量数据计数。    </li>
</ol>
<h2 id="布隆过滤器Bloom-Filter"><a href="#布隆过滤器Bloom-Filter" class="headerlink" title="布隆过滤器Bloom Filter"></a>布隆过滤器Bloom Filter</h2><ol>
<li>Bloom Filter和HyperLogLog类似，是一个估计工具。相当于节省空间结果粗略的哈希表。与HyperLogLog不同的是，布隆过滤器是查询集合内某元素是否存在。比如说，steam要存储用户的购买记录，很多用户很多购买记录，n个set，每个set也很大。只是想知道用户有没有买过某个游戏。这时可以用Bloom Filter。</li>
<li>它存储的是键值对，bf.add csgo user1，则user1购买了csgo。<br>bf.exists codehole user1，查询user1是否购买了csgo。<br>bf.madd和bf.mexists多值判断和查询</li>
<li>当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。虽然Bloom Filter是估测，但布隆过滤器对于已经见过的元素肯定不会误判，它只会误判那些没见过的元素。把编号1到10000的用户插入，然后再查它们是否存在，答案是都存在，不会有错误，但如果查10001到20000号用户是否存在，并不会回答都不存在，这里有误差，只会回答绝大部分的用户不存在。</li>
<li>自定义参数，可以自定义预计数量和误差范围，显然可知，要求的误差越小，所需要的存储空间越大。比如5万数据，0.1%误差：client.createFilter(“codehole”, 50000, 0.001);</li>
<li>使用的时候一是可以忍受误差的场景，比如说使用爬虫爬取URl,不爬重复的，这时就适合用布隆过滤器，即使有遗漏的，做统计也不要紧；二是利用“如果说不存在，那肯定不存在的特性”，在解决缓存攻击的时候, 也用到了布隆过滤器, 就是不法分子构造缓存中没有的key进行大量请求, 导致大量查询db, 这时候, 如果先在boom中查询一下是不是有这个key就可以抵挡这个攻击。如果布隆过滤器说该行不存在，那肯定不存在。那就不用查了。</li>
</ol>
<h2 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h2><blockquote>
<p><a href="https://www.cnblogs.com/LBSer/p/3310455.html" target="_blank" rel="noopener">https://www.cnblogs.com/LBSer/p/3310455.html</a>     </p>
</blockquote>
<p>理论基础，简单来说，希尔伯特曲线表示，一维曲线可以填满二维空间。这个理论的实际意义在于，将二维的坐标一维表示，这样我们就可以用B树索引了。<br>GeoHash使用看皮亚诺曲线，有突变的问题，解决方法是，不只查这个小正方形区域，还要查它周围的八个正方形。</p>
<ol>
<li>geoadd 指令携带集合名称以及多个经纬度名称三元组，注意这里可以加入多个三元组。简单来说，就是表示(经度，维度，谁)。</li>
<li>geodist 指令可以用来计算两个元素之间的距离，携带集合名称、2 个名称和距离单位。</li>
<li>geopos 指令可以获取集合中任意元素的经纬度坐标，可以一次获取多个。</li>
<li>geohash 可以获取元素的经纬度编码字符串，它是 base32 编码。 可以使用这个编码值直接查到地理位置。比如在<a href="http://geohash.org/" target="_blank" rel="noopener">http://geohash.org/</a></li>
<li><p>georadiusbymember可以用来查询指定元素附近的其它元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//范围 20 公里以内最多 3 个元素按距离倒排</span><br><span class="line">georadiusbymember company ireader 20 km count 3 desc</span><br></pre></td></tr></table></figure>
</li>
<li><p>GeoHash本质是zset，删除点用zset的命令，即zrem。</p>
</li>
</ol>
<h2 id="漏斗限流"><a href="#漏斗限流" class="headerlink" title="漏斗限流"></a>漏斗限流</h2><p>工作中对外提供的API 接口设计都要考虑限流，如果不考虑限流，会成系统的连锁反应，轻者响应缓慢，重者系统宕机，整个业务线崩溃，如何应对这种情况呢，我们可以对请求进行引流或者直接拒绝等操作，保持系统的可用性和稳定性，防止因流量暴增而导致的系统运行缓慢或宕机。<br>把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。即可以累积待处理的服务，但不能累积太多待处理的服务，并且处理速度恒定。</p>
<ol>
<li>在漏斗中没有水的时候：<br>如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，此时，不会积水。<br>如果进水速率大于最大出水速率，那么，漏斗以最大速率出水，此时，多余的水会积在漏斗中</li>
<li>在漏斗中有水的时候：<br>出水口以最大速率出水<br>如果漏斗未满，且有进水的话，那么这些水会积在漏斗中<br>如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外   </li>
</ol>
<p>Redis 4.0 提供了一个限流 Redis 模块，它叫 redis-cell。只有一个指令cl.throttle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; cl.throttle laoqian:reply 15 30 60 #参数分别是，漏斗容量15，每60秒处理30个，need 1 quota (可选参数，默认值也是1)。   </span><br><span class="line">1) (integer) 0   # 0 表示允许，1表示拒绝</span><br><span class="line">2) (integer) 15  # 漏斗容量capacity</span><br><span class="line">3) (integer) 14  # 漏斗剩余空间left_quota</span><br><span class="line">4) (integer) -1  # 如果拒绝了，需要多长时间后再试(漏斗有空间了，单位秒)</span><br><span class="line">5) (integer) 2   # 多长时间后，漏斗完全空出来(left_quota==capacity，单位秒)...</span><br></pre></td></tr></table></figure></p>
<h2 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h2><p>keys 用来列出所有满足特定正则字符串规则的 key，但其一该指令是阻塞的，而且算法复杂度O(n)，数据量太大会使Redis服务卡顿；其二，不支持各种粒度的参数，offset和limit之类。<br>后来提供了另一个的版本scan。通过游标实现，不会阻塞线程，但会带来并发问题。</p>
<ol>
<li>游标分步进行的，不会阻塞线程。</li>
<li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;</li>
<li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;也就是说在使用中，如果要遍历完，需要循环执行，每次将上一次传回的游标值作为参数，进行下一次遍历，知道返回游标为0.</li>
<li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</li>
<li>返回的结果可能会有重复，需要客户端去重复，这点非常重要;</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/29/11-29技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/29/11-29技术笔记/" itemprop="url">redis五种数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-29T16:55:17+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>实际上也是键值对，因为每个都有名字。其内部数据结构有点像ArrayList，有空余空间，满了翻倍，达到1M后，每次满了+1M。<br>如果value值是数字，还可以自增。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>可以设置过期时间，这样就变成了一个分布式锁：问题在于，存入和设置过期时间之间的这一小段时间有风险，即set后expire前挂了或者并发危险。为了解决这个问题，redis有相当于原子性业务，即set有个参数。<br>另一个问题是超时问题，即已经过期了，业务还没有完成，另一个线程持有了锁，就失去了锁的意义。Redis不能解决这个问题，简陋解决方案的给value加个参数，删除锁先匹配参数，但匹配和删除两个操作之间也有时间。 想要完美解决需要Lua,成本太大，不如从业务的角度，不要把这么长时间才能完成的业务用redis分布式锁，或者鸵鸟策略。<br>可重入锁需要自己封装，就是用TheadLocal记录使用次数。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List是链表，意味着增减很快，意味着链表实现的功能如队列和栈，都是用List实现。即左右push和pop。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>队列空了反复读有性能问题，所以有阻塞读：blpop，brpop，即blockingLeftPop的简写，会阻塞直到队列里有信息。<br>空连接会自动断开。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希和String似乎区别不大，在使用中，即可以把实体序列化整体存入String，也可以把实体的各个属性存入哈希，取决于是使用实体还是实体的某个属性频率。<br>hash结构和Java中的hashMap一样，数组加链表，把哈希碰撞的元素用链表连起来。区别在于reHash,Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 操作指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。当搬迁完成了，就会使用新的hash结构取而代之。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set的意义在于去重，而且是单值的，加进去后，一般意义在于查在不在集合里。</p>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>有序集合，也是键值对，根据值排序，所以有点像优先队列。通过跳表实现。</p>
<h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><p>延时队列可以通过 Redis 的 zset(有序列表) 来实现。我们将消息序列化成一个字符串作为 zset 的value，这个消息的到期处理时间作为score，然后用多个线程轮询 zset 获取到期的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。因为有多个线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>用时间做key值，行为做value值，就成了一个滑动窗口。比如说要限制用户行为，每分钟只能操作三次，每次操作前，移除时间窗口之前的行为记录 pipe.zremrangebyscore(key, 0, now_ts - period * 1000)，剩下的都是时间窗口内的，然后计数pipe.zcard(key)，如果达到了限制次数，则不能执行。同时应该设置过期时间，避免冷用户长期占用内存，pipe.expire(key, period + 1)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/27/11-27技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/27/11-27技术笔记/" itemprop="url">Netty技术杂记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-27T14:14:31+08:00">
                2018-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>netty中的操作返回的大多是ChannelFuture，比如bind(),connect(),write()。ChannelFuture继承自Future，可以addListener,isSuccess等方法。同时ChannelFuture 还持有Channel的引用。   </li>
<li>ChannelFuture提供了几种额外的方法，这些方法使得我们能够注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()，将会在对应的操作完成时被调用。</li>
<li>sync()是阻塞的，和await()差异在于它返回异常，因为netty中所有的操作都是异步的，而返回的ChannelFuture是同步的，如果方法后加sync()，意味着阻塞并等待该操作的完成。实际上，最好还是加个Listener，等返回了再处理，而不是等它返回。</li>
<li>EventLoop是和线程绑定的，与Channel是一对多的关系，一个 EventLoopGroup 包含一个或者多个 EventLoop；一个 EventLoopGroup 包含一个或者多个 EventLoop；</li>
<li>ChannelInitializer先注册自己，然后安装其他的ChannelHandler,最后移除自己。</li>
<li>为服务器需要两组不同的 Channel。第一组将只包含一个 ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传入客户端连接（对于每个服务器已经接受的连接都有一个）的 Channel。</li>
<li><p>池化的用法，当引用计数等于0的时候，Netty将Buffer回收致池中，在下一次申请Buffer的没某个时刻会被复用。为了降低分配和释放内存的开销，Netty 通过 interface ByteBufAllocator 实现了（ByteBuf 的）池化，它可以用来分配我们所描述过的任意类型的 ByteBuf 实例。可以通过 Channel（每个都可以有一个不同的 ByteBufAllocator 实例）或者绑定到ChannelHandler 的 ChannelHandlerContext 获取一个到 ByteBufAllocator 的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">ByteBufAllocator allocator = channel.alloc();</span><br><span class="line">ChannelHandlerContext ctx = ...;</span><br><span class="line">ByteBufAllocator allocator2 = ctx.alloc();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Bytebuf的最佳实践是在IO通信线程的读写缓冲区使用DirectByteBuf，后端业务使用HeapByteBuf。</p>
</li>
<li><p>复合缓冲区可以组合.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf messageBuf = Unpooled.compositeBuffer();</span><br><span class="line">ByteBuf headerBuf = ...; // can be backing or direct</span><br><span class="line">ByteBuf bodyBuf = ...; // can be backing or direct</span><br><span class="line">messageBuf.addComponents(headerBuf, bodyBuf);</span><br><span class="line">.....</span><br><span class="line">messageBuf.removeComponent(0); // remove the header</span><br><span class="line">for (ByteBuf buf : messageBuf) &#123;</span><br><span class="line">System.out.println(buf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每当通过调用 ChannelInboundHandler.channelRead()或者 ChannelOutboundHandler.write()方法来处理数据时，你都需要确保没有任何的资源泄漏。通过调用 ReferenceCountUtil.release()方法释放资源,在出站方向这边，如果你处理了 write()操作并丢弃了一个消息，那么你也应该负责释放它。重要的是，不仅要释放资源，还要通知 ChannelPromise。否则可能会出现 ChannelFutureListener收不到某个消息已经被处理了的通知的情况。</p>
</li>
<li>ChannelPromise接口扩展了Promise和ChannelFuture，绑定了Channel，又可写异步执行结构，又具备了监听者的功能，是Netty实际编程使用的表示异步执行的接口</li>
<li>ChannelHandlerContext的writeAndFlush()方法是从当前handler开始的，Channel的writeAndFlush()方法是从头开始的。</li>
<li><p>EventLoop是和线程绑定的，多线程有关操作应该通过EventLoop实现，定时任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Channel ch = ...</span><br><span class="line">ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate(</span><br><span class="line">  new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Run every 60 seconds&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 60, 60, TimeUnit.Seconds);</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端用bootstrap，服务端用ServerBootstrap进行引导，至少需要三部分，EventLoopGroup,channel或者channelFactory,Handler。</p>
</li>
<li><p>优雅地关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = group.shutdownGracefully();</span><br><span class="line">// block until the group has shutdown</span><br><span class="line">future.syncUninterruptibly();</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池，永远不要再IO你应该永远不要在 Netty 的 I/O 线程上执行任何非 CPU 限定的代码,这样会阻塞IO线程，正确的方法是放在线程池中，netty有继承了线程池的实现类。EventExecutorGroup默认实现类为DefaultEventExecutorGroup(int size),参数为线程数。使用时，在addlast()方法的重载方法中，第一个参数指定线程池就好。<br>应该使用类静态成员变量，这样各个连接共享线程池。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final EventExecutor executor = new DefaultEventExecutorGroup(16);</span><br><span class="line">//blabla</span><br><span class="line">pipeline.addlast(executor, new myhandler());</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/26/11-26技术笔记-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/26/11-26技术笔记-1/" itemprop="url">多线程笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-26T16:26:30+08:00">
                2018-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>终止线程只能用interrupt(),但该函数不一定能终止，方法是检测interrupt状态，因为interrupt()会抛异常，检测异常就好，或者直接return。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        RunTest rt = new RunTest();</span><br><span class="line">        Thread t = new Thread(rt);</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        t.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    class RunTest implements Runnable &#123;</span><br><span class="line">        //这种设计比较好,当调用阻塞操作时,会因为抛出异常退出,当不调用阻塞操作时,会因为检查中断状态而退出</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                Thread.sleep(1);</span><br><span class="line">                while(!Thread.interrupted())&#123;</span><br><span class="line">                    System.out.println(&quot;sleep 5s&quot;);</span><br><span class="line">                    Thread.sleep(5000);//接收到中断信号时，由于抛出异常退出，模拟耗时操作</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;Exit normal&quot;);</span><br><span class="line">            &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(&quot;interrupted and exit&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main线程是第一个线程，Thread0是第二次。</p>
</li>
<li>多个线程之间共享变量才会用冲突，体现在new Thread()的参数是同一个对象（该对象的类继承了Thread或者实现了runnable)。同样，synchronized是对象锁。</li>
<li>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。</li>
<li>ThreadPoolExecutor类是ExecutorSerivce接口的具体实现，一般用Executors就用后者，手动创建线程池new ThreadPoolExecutor()就用前者。强转也行。</li>
<li><p>向线程池里提交，只需要一个Runable接口的对象即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10,20,20, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;Runnable&gt;(6));</span><br><span class="line">Runnable runnable = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.printf(&quot;132&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">threadPoolExecutor.execute(runnable);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(10);</span><br><span class="line">ScheduledFuture&lt;?&gt; future = executor.schedule(</span><br><span class="line">  new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      System.out.println(&quot;60 seconds later&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 60, TimeUnit.SECONDS);</span><br><span class="line">//blabla</span><br><span class="line">  executor.shutdown();</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/26/11-26技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/26/11-26技术笔记/" itemprop="url">mybaits+Spring事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-26T14:26:57+08:00">
                2018-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>Spring.XML<br>需要命名空间xmlns:tx</li>
<li><p>事务管理器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;     </span><br><span class="line">          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mybaits配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- mybatis mappers, scanned automatically --&gt;  </span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;  </span><br><span class="line">    &lt;property name=&quot;basePackage&quot;&gt;  </span><br><span class="line">        &lt;value&gt;  </span><br><span class="line">            com.baobao.persistence.test  </span><br><span class="line">        &lt;/value&gt;  </span><br><span class="line">    &lt;/property&gt;  </span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务管理注解<br>开启注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:annotation-driven  transaction-manager=&quot;transactionManager&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务注解@Transactional<br>有传播级别，隔离级别设置，读写只读等属性</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2018/11/23/11-23技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/23/11-23技术笔记/" itemprop="url">netty心跳检测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-23T15:28:24+08:00">
                2018-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h2><p>连接假死的现象是：在某一端（服务端或者客户端）看来，底层的 TCP 连接已经断开了，但是应用程序并没有捕获到，因此会认为这条连接仍然是存在的，从 TCP 层面来说，只有收到四次握手数据包或者一个 RST 数据包，连接的状态才表示已断开。</p>
<h2 id="服务端心跳检测"><a href="#服务端心跳检测" class="headerlink" title="服务端心跳检测"></a>服务端心跳检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class IMIdleStateHandler extends IdleStateHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final int READER_IDLE_TIME = 15;</span><br><span class="line"></span><br><span class="line">    public IMIdleStateHandler() &#123;</span><br><span class="line">        super(READER_IDLE_TIME, 0, 0, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) &#123;</span><br><span class="line">        System.out.println(READER_IDLE_TIME + &quot;秒内未读到数据，关闭连接&quot;);</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>IMIdleStateHandler 的构造函数，他调用父类 IdleStateHandler 的构造函数，有四个参数，其中第一个表示读空闲时间，指的是在这段时间内如果没有数据读到，就表示连接假死；第二个是写空闲时间，指的是 在这段时间如果没有写数据，就表示连接假死；第三个参数是读写空闲时间，表示在这段时间内如果没有产生数据读或者写，就表示连接假死。写空闲和读写空闲为0，表示我们不关心者两类条件；最后一个参数表示时间单位。在我们的例子中，表示的是：如果 15 秒内没有读到数据，就表示连接假死。</li>
<li>连接假死之后会回调 channelIdle() 方法，我们这个方法里面打印消息，并手动关闭连接。</li>
<li>该handler需要插入在pipeline的最前面，是因为如果插入到最后面的话，如果这条连接读到了数据，但是在 inBound 传播的过程中出错了或者数据处理完完毕就不往后传递了（我们的应用程序属于这类），那么最终 IMIdleStateHandler 就不会读到数据，最终导致误判。<h2 id="客户端发送心跳"><a href="#客户端发送心跳" class="headerlink" title="客户端发送心跳"></a>客户端发送心跳</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HeartBeatTimerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private static final int HEARTBEAT_INTERVAL = 5;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        scheduleSendHeartBeat(ctx);</span><br><span class="line"></span><br><span class="line">        super.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void scheduleSendHeartBeat(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        ctx.executor().schedule(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            if (ctx.channel().isActive()) &#123;</span><br><span class="line">                ctx.writeAndFlush(new HeartBeatRequestPacket());</span><br><span class="line">                scheduleSendHeartBeat(ctx);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, HEARTBEAT_INTERVAL, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>ctx.executor() 返回的是当前的 channel 绑定的 NIO 线程，然后，NIO 线程有一个方法，schedule()，类似 jdk 的延时任务机制，可以隔一段时间之后执行一个任务，而我们这边是实现了每隔 5 秒，向服务端发送一个心跳数据包，这个时间段通常要比服务端的空闲检测时间的一半要短一些，我们这里直接定义为空闲检测时间的三分之一，主要是为了排除公网偶发的秒级抖动。</p>
<h2 id="服务端响应心跳"><a href="#服务端响应心跳" class="headerlink" title="服务端响应心跳"></a>服务端响应心跳</h2><p>服务端无需主动发送心跳，只需向客户端发送，我已经接收到了心跳的消息即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/blog/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/24/">24</a><a class="extend next" rel="next" href="/blog/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Arvense</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">233</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/blog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>


  
</div>


  <div class="powered-by">Powered by <a>Arvense</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">blog   </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
