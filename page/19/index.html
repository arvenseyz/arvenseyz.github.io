<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Arvense, NexT">





  <link rel="alternate" href="/atom.xml" title="Arvense" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Arvense">
<meta property="og:url" content="https://arvenseyz.github.io/page/19/index.html">
<meta property="og:site_name" content="Arvense">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Arvense">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://arvenseyz.github.io/page/19/">





  <title>Arvense</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Arvense</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/11/14/11-14技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/11-14技术笔记/" itemprop="url">ByteBuf与通信协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-14T14:18:20+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ByteBuf与内存管理"><a href="#ByteBuf与内存管理" class="headerlink" title="ByteBuf与内存管理"></a>ByteBuf与内存管理</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>ByteBuf结构上，类似一段连续的内存（数组），和其上的两个指针（读和写）。这样，通过读写指针的移动，可以控制到指定位置的读写。   </p>
<h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><p>为了支持可扩容，实际上还保存了当前容量，然后自动扩容。直到最大容量（默认为Interger.Max）。   </p>
<ol>
<li>capacity()表示 ByteBuf 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节），不同的底层实现机制有不同的计算方式</li>
<li>readableBytes() 表示 ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex，如果两者相等，则不可读，isReadable() 方法返回 false</li>
<li>writableBytes() 表示 ByteBuf 当前可写的字节数，它的值等于 capacity-writerIndex，如果两者相等，则表示不可写，isWritable() 返回 false，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往 ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity，而 maxWritableBytes() 就表示可写的最大字节数，它的值等于 maxCapacity-writerIndex.    </li>
</ol>
<h2 id="读写指针"><a href="#读写指针" class="headerlink" title="读写指针"></a>读写指针</h2><p>readerIndex()表示返回当前的读指针 readerIndex 与 readerIndex(int)表示设置读指针。<br>writeIndex()表示返回当前的写指针 writerIndex 与 writeIndex(int)表示设置写指针。<br>markReaderIndex()表示把当前的读指针保存起来 与 resetReaderIndex()表示把当前的读指针恢复到之前保存的值。<br>markWriterIndex() 与 resetWriterIndex()同理。   </p>
<h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><p>关于 ByteBuf 的读写都可以看作从指针开始的地方开始读写数据，write和read表示读写数据的同时指针移动，get和set只读写，指针不移动。<br>同时有Discard和clear等方法，抛弃前面的内容时，数组后面会延伸，以保持当年容量。</p>
<blockquote>
<p><a href="https://www.itcodemonkey.com/article/4655.html" target="_blank" rel="noopener">https://www.itcodemonkey.com/article/4655.html</a>    </p>
</blockquote>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>由于netty可以使用堆外内存，这里GC不工作，所以此处需要自己管理内存。所管理的应该是引用计数，当引用计数为0时，才会自动清除。<br>默认情况下，当创建完一个 ByteBuf，它的引用为1，然后每次调用 retain() 方法， 它的引用就加一， release() 方法原理是将引用计数减一，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存。<br>duplicate()和slice()创建的只是视图，也就是说对原内存的一个新的引用，对其内容的修改会导致原ByteBuf内容变化。</p>
<p>两种形式，池化和非池化；三个位置堆，直接内存，混合。组合出六种生成的方式。<br>池化需要ByteBufAllocator，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBufAllocator allocator = channel.alloc();</span><br><span class="line">ByteBufAllocator allocator2 = ctx.alloc();</span><br></pre></td></tr></table></figure></p>
<p>均可获得ByteBufAllocator对象。<br>heapBuffer()基于堆，directBuffer()基于直接内存，buffer()两者或，compositeBuffer()两者混合。<br>而非池化可以直接用Unpooled的静态方法。<br>buffer()基于堆，directBuffer()基于直接内存。</p>
<h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h1><h2 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h2><p>netty可以自己设计通信协议，为什么需要通信协议。比如说服务端接收到客户端的数据包，怎么知道传来的是用户名密码还是发的消息呢？对于用户名密码，怎么知道哪些字节是用户名，哪些字节是密码呢，这些都需要规定，规定的结果就是协议。<br><a href="https://imgchr.com/i/ijAp40" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/14/ijAp40.md.png" alt="ijAp40.md.png"></a>   </p>
<ol>
<li>第一个字段是魔数，通常情况下为固定的几个字节（我们这边规定为4个字节）。魔数是用来区分协议的，不同的协议不同的魔数。对比魔数才能找到协议。</li>
<li>第二个字段版本号。  </li>
<li>第三部分，序列化算法表示如何把 Java 对象转换二进制数据以及二进制数据如何转换回 Java 对象，比如 Java 自带的序列化，json，hessian 等序列化方式。</li>
<li>第四部分的字段表示指令，关于指令相关的介绍，我们在前面已经讨论过，服务端或者客户端每收到一种指令都会有相应的处理逻辑，正如之前说的区分账号密码还是说的话。</li>
<li>数据长度。</li>
<li>数据内容。    </li>
</ol>
<h2 id="（参考）实际上RPC协议"><a href="#（参考）实际上RPC协议" class="headerlink" title="（参考）实际上RPC协议"></a>（参考）实际上RPC协议</h2><p>一般 RPC 框架首先获取协议类型，根据这个协议类型得到协议处理器，然后再处理（一个端口处理多个协议的场景）。<br>生产级别的 RPC 通常较为复杂，以 SOFABolt 为例，需要以下字段：</p>
<ol>
<li>协议版本</li>
<li>请求类型，即指令（Request，Response， oneway）</li>
<li>指令版本</li>
<li>RequestID 负责数据对应</li>
<li>序列号器</li>
<li>协议开关（例如 CRC 校验，安全校验）</li>
<li>响应码，约定异常，简化异常</li>
<li>类名长度，Java rpc 框架必备</li>
<li>请求头长度（参照 http header）</li>
<li>请求体长度（参照http body）</li>
<li>类名</li>
<li>业务请求头内容（一般是 Map，SOFABolt 支持自定义，SOFARPC 里面藏着是否泛化调用等信息）</li>
<li>业务请求体内容（一般就是个Request对象或 Response对象，里面包含约定的属性，例如参数，返回值，超级多，SOFARPC 有个属性类 RemotingConstants，这里都有）</li>
<li>CRC 校验码（金融场景必备）</li>
</ol>
<h2 id="数据包设计"><a href="#数据包设计" class="headerlink" title="数据包设计"></a>数据包设计</h2><ol>
<li>数据包基类应该包括版本和指令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Packet &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 协议版本</span><br><span class="line">     */</span><br><span class="line">    @JSONField(deserialize = false, serialize = false)</span><br><span class="line">    private Byte version = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @JSONField(serialize = false)</span><br><span class="line">    public abstract Byte getCommand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>具体登陆数据包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LoginRequestPacket extends Packet &#123;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Byte getCommand() &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ol>
<li><p>定义序列化接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializer &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列化算法</span><br><span class="line">     */</span><br><span class="line">    byte getSerializerAlgorithm();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * java 对象转换成二进制</span><br><span class="line">     */</span><br><span class="line">    byte[] serialize(Object object);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 二进制转换成 java 对象</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);</span><br><span class="line">    /**</span><br><span class="line">    * 默认采用JSON</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">     Serializer DEFAULT = new JSONSerializer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 fastjson进行序列化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class JSONSerializer implements Serializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte getSerializerAlgorithm() &#123;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(Object object) &#123;</span><br><span class="line"></span><br><span class="line">        return JSON.toJSONBytes(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;</span><br><span class="line"></span><br><span class="line">        return JSON.parseObject(bytes, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAGIC_NUMBER = 0x12345678;</span><br><span class="line"></span><br><span class="line">public ByteBuf encode(Packet packet) &#123;</span><br><span class="line">    // 1. 创建 ByteBuf 对象</span><br><span class="line">    ByteBuf byteBuf = ByteBufAllocator.DEFAULT.ioBuffer();</span><br><span class="line">    // 2. 序列化 Java 对象</span><br><span class="line">    byte[] bytes = Serializer.DEFAULT.serialize(packet);</span><br><span class="line"></span><br><span class="line">    // 3. 实际编码过程</span><br><span class="line">    byteBuf.writeInt(MAGIC_NUMBER);</span><br><span class="line">    byteBuf.writeByte(packet.getVersion());</span><br><span class="line">    byteBuf.writeByte(Serializer.DEFAULT.getSerializerAlgorithm());</span><br><span class="line">    byteBuf.writeByte(packet.getCommand());</span><br><span class="line">    byteBuf.writeInt(bytes.length);</span><br><span class="line">    byteBuf.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">    return byteBuf;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>
<ol>
<li>首先，我们需要创建一个 ByteBuf，这里我们调用 Netty 的 ByteBuf 分配器来创建，ioBuffer() 方法会返回适配 io 读写相关的内存，它会尽可能创建一个直接内存，直接内存可以理解为不受 jvm 堆管理的内存空间，写到 IO 缓冲区的效果更高。</li>
<li>接下来，我们将 Java 对象序列化成二进制数据包。</li>
<li>最后，我们对照本小节开头协议的设计以及上一小节 ByteBuf 的 API，逐个往 ByteBuf 写入字段，即实现了编码过程，到此，编码过程结束</li>
</ol>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public Packet decode(ByteBuf byteBuf) &#123;</span><br><span class="line">    // 跳过 magic number</span><br><span class="line">    byteBuf.skipBytes(4);</span><br><span class="line"></span><br><span class="line">    // 跳过版本号</span><br><span class="line">    byteBuf.skipBytes(1);</span><br><span class="line"></span><br><span class="line">    // 序列化算法标识</span><br><span class="line">    byte serializeAlgorithm = byteBuf.readByte();</span><br><span class="line"></span><br><span class="line">    // 指令</span><br><span class="line">    byte command = byteBuf.readByte();</span><br><span class="line"></span><br><span class="line">    // 数据包长度</span><br><span class="line">    int length = byteBuf.readInt();</span><br><span class="line"></span><br><span class="line">    byte[] bytes = new byte[length];</span><br><span class="line">    byteBuf.readBytes(bytes);</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Packet&gt; requestType = getRequestType(command);</span><br><span class="line">    Serializer serializer = getSerializer(serializeAlgorithm);</span><br><span class="line"></span><br><span class="line">    if (requestType != null &amp;&amp; serializer != null) &#123;</span><br><span class="line">        return serializer.deserialize(requestType, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>我们假定 decode 方法传递进来的 ByteBuf 已经是合法的，即首四个字节是我们前面定义的魔数 0x12345678，这里我们调用 skipBytes 跳过这四个字节。</li>
<li>这里，我们暂时不关注协议版本，通常我们在没有遇到协议升级的时候，这个字段暂时不处理，因为，你会发现，绝大多数情况下，这个字段几乎用不着，但我们仍然需要暂时留着。</li>
<li>接下来，我们调用 ByteBuf 的 API 分别拿到序列化算法标识、指令、数据包的长度。</li>
<li>最后，我们根据拿到的数据包的长度取出数据，通过指令拿到该数据包对应的 Java 对象的类型，根据序列化算法标识拿到序列化对象，将字节数组转换为 Java 对象，至此，解码过程结束。</li>
<li>指令号对应的指令，序列法序号对应的序列化方法，储存在服务端，两个get函数既是查询本机的映射表，得到相应的映射方法。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/11/13/11-13技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/13/11-13技术笔记/" itemprop="url">netty基础搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-13T14:41:08+08:00">
                2018-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class NettyServer &#123;</span><br><span class="line"></span><br><span class="line">    private static final int BEGIN_PORT = 8000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /*</span><br><span class="line">        我们创建了两个NioEventLoopGroup，这两个对象可以看做是传统IO编程模型的两大线程组，</span><br><span class="line">        bossGroup表示监听端口，accept 新连接的线程组，workerGroup表示处理每一条连接的数据读写的线程组</span><br><span class="line">         */</span><br><span class="line">        NioEventLoopGroup boosGroup = new NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        /*</span><br><span class="line">        创建了一个引导类 ServerBootstrap，这个类将引导我们进行服务端的启动工作，直接new出来</span><br><span class="line">         */</span><br><span class="line">        final ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">        final AttributeKey&lt;Object&gt; clientKey = AttributeKey.newInstance(&quot;clientKey&quot;);</span><br><span class="line">        serverBootstrap</span><br><span class="line">                /*</span><br><span class="line">                我们通过.group(bossGroup, workerGroup)给引导类配置两大线程组，这个引导类的线程模型也就定型了。</span><br><span class="line">                 */</span><br><span class="line">                .group(boosGroup, workerGroup)</span><br><span class="line">                /*</span><br><span class="line">                指定我们服务端的 IO 模型为NIO，我们通过.channel(NioServerSocketChannel.class)来指定 IO 模型，</span><br><span class="line">                当然，这里也有其他的选择，如果你想指定 IO 模型为 BIO，那么这里配置上OioServerSocketChannel.class</span><br><span class="line">                类型即可，当然通常我们也不会这么做，因为Netty的优势就在于NIO。</span><br><span class="line">                 */</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                /*</span><br><span class="line">                childHandler()用于指定处理新连接数据的读写处理逻辑，handler()用于指定在服务端启动过程中的一些逻辑</span><br><span class="line">                 */</span><br><span class="line">                .handler(new ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">                        super.channelActive(ctx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                        System.out.println(ch.attr(clientKey).get());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                 /*</span><br><span class="line">                attr()方法可以给服务端的 channel，也就是NioServerSocketChannel指定一些自定义属性，</span><br><span class="line">                然后我们可以通过channel.attr()取出这个属性，</span><br><span class="line">                比如，下面的代码我们指定我们服务端channel的一个serverName属性，属性值为nettyServer</span><br><span class="line">                childAttr可以给每一条连接指定自定义属性，然后后续我们可以通过channel.attr()取出该属性。</span><br><span class="line">                 */</span><br><span class="line">                .attr(AttributeKey.newInstance(&quot;serverName&quot;), &quot;nettyServer&quot;)</span><br><span class="line">                .childAttr(clientKey, &quot;clientValue&quot;)</span><br><span class="line">                /*</span><br><span class="line">                childOption()可以给每条连接设置一些TCP底层相关的属性，比如上面，我们设置了两种TCP属性，其中</span><br><span class="line">                ChannelOption.SO_KEEPALIVE表示是否开启TCP底层心跳机制，true为开启</span><br><span class="line">                ChannelOption.TCP_NODELAY表示是否开启Nagle算法，true表示关闭，false表示开启，</span><br><span class="line">                通俗地说，如果要求高实时性，有数据发送时就马上发送，就关闭，如果需要减少发送次数减少网络交互，就开启。</span><br><span class="line"></span><br><span class="line">                除了给每个连接设置这一系列属性之外，我们还可以给服务端channel设置一些属性，最常见的就是so_backlog，</span><br><span class="line">                如下设置表示系统用于临时存放已完成三次握手的请求的队列的最大长度，如果连接建立频繁</span><br><span class="line">                ，服务器处理创建新连接较慢，可以适当调大这个参数...</span><br><span class="line">                 */</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        调用bind(8000)，我们就可以在本地绑定一个 8000 端口启动起来。</span><br><span class="line">        这里手写了重载函数，如果绑定失败，则绑定下一个端口。</span><br><span class="line">         */</span><br><span class="line">        bind(serverBootstrap, BEGIN_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void bind(final ServerBootstrap serverBootstrap, final int port) &#123;</span><br><span class="line">        serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">            if (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(&quot;端口[&quot; + port + &quot;]绑定成功!&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.err.println(&quot;端口[&quot; + port + &quot;]绑定失败!&quot;);</span><br><span class="line">                bind(serverBootstrap, port + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class NettyClient &#123;</span><br><span class="line">    private static final int MAX_RETRY = 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">        bootstrap</span><br><span class="line">                // 1.指定线程模型,客户端只需要一个EventLoopGroup</span><br><span class="line">                .group(workerGroup)</span><br><span class="line">                // 2.指定 IO 类型为 NIO</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                // 绑定自定义属性到 channel</span><br><span class="line">                .attr(AttributeKey.newInstance(&quot;clientName&quot;), &quot;nettyClient&quot;)</span><br><span class="line">                // 设置TCP底层属性</span><br><span class="line">                /*</span><br><span class="line">                 ChannelOption.CONNECT_TIMEOUT_MILLIS 表示连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span><br><span class="line">                 ChannelOption.SO_KEEPALIVE 表示是否开启 TCP 底层心跳机制，true 为开启</span><br><span class="line">                 ChannelOption.TCP_NODELAY 表示是否开始 Nagle 算法，true 表示关闭，false 表示开启。</span><br><span class="line">                 通俗地说，如果要求高实时性，有数据发送时就马上发送，就设置为 true 关闭，如果需要减少发送次数减少网络交互，就设置为 false 开启</span><br><span class="line">                 */</span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                // 3.IO 处理逻辑</span><br><span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        // 4.建立连接</span><br><span class="line">        connect(bootstrap, &quot;127.0.0.1&quot;, 8000, MAX_RETRY);</span><br><span class="line">    &#125;</span><br><span class="line">    //这里建立连接，为了避免失败，同样手写了方法，超时重试机制。</span><br><span class="line">    private static void connect(Bootstrap bootstrap, String host, int port, int retry) &#123;</span><br><span class="line">        bootstrap.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">            if(future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(&quot;连接成功!&quot;);</span><br><span class="line">            &#125;else if(retry == 0) &#123;</span><br><span class="line">                System.err.println(&quot;重试次数已用完，放弃连接！&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                // 第几次重连</span><br><span class="line">                int order = (MAX_RETRY - retry) + 1;</span><br><span class="line">                // 本次重连的间隔</span><br><span class="line">                int delay = 1 &lt;&lt; order;</span><br><span class="line">                System.err.println(new Date() + &quot;: 连接失败，第&quot; + order + &quot;次重连……&quot;);</span><br><span class="line">                bootstrap.config().group().schedule(() -&gt; connect(bootstrap, host, port, retry - 1), delay, TimeUnit</span><br><span class="line">                        .SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="服务端和客户端数据交互"><a href="#服务端和客户端数据交互" class="headerlink" title="服务端和客户端数据交互"></a>服务端和客户端数据交互</h1><h2 id="业务逻辑位置"><a href="#业务逻辑位置" class="headerlink" title="业务逻辑位置"></a>业务逻辑位置</h2><p>在客户端启动中，childHandler中并没有写业务逻辑，仅仅一个打印。实际上，所以的业务都应该写于此种，这里使用了责任链模式。NioSocketChannel中有pipeline，pipe里有个双向链表，向其中添加业务逻辑的ChannelHandler即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">        ch.pipeline().addLast(new FirstServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同样，在服务端中，数据读写是handler() 方法中的initChannel()。    </p>
<h2 id="客户端写出数据"><a href="#客户端写出数据" class="headerlink" title="客户端写出数据"></a>客户端写出数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class FirstClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    [覆盖了 channelActive()方法，这个方法会在客户端连接建立成功之后被调用]</span><br><span class="line">    写数据的逻辑分为两步：首先我们需要获取一个 netty 对二进制数据的抽象 ByteBuf，, ctx.alloc() 获取到一个 ByteBuf 的内存管理器，</span><br><span class="line">    这个内存管理器的作用就是分配一个 ByteBuf，然后我们把字符串的二进制数据填充到 ByteBuf，</span><br><span class="line">    这样我们就获取到了 Netty 需要的一个数据格式，最后我们调用 ctx.channel().writeAndFlush() 把数据写到服务端...</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        System.out.println(new Date() + &quot;: 客户端写出数据&quot;);</span><br><span class="line">        // 1.获取数据</span><br><span class="line">        ByteBuf buffer = getByteBuf(ctx);</span><br><span class="line">        // 2.写数据</span><br><span class="line">        ctx.channel().writeAndFlush(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    private ByteBuf getByteBuf(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        byte[] bytes = &quot;hello world!&quot;.getBytes(Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">        ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">        buffer.writeBytes(bytes);</span><br><span class="line">        return buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务端读入数据，写出数据"><a href="#服务端读入数据，写出数据" class="headerlink" title="服务端读入数据，写出数据"></a>服务端读入数据，写出数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class FirstServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    /*</span><br><span class="line">        [这里覆盖的方法是 channelRead()，这个方法在接收到客户端发来的数据之后被回调。]</span><br><span class="line">        这里的 msg 参数指的就是 Netty 里面数据读写的载体，</span><br><span class="line">        我们强转之后，然后调用 byteBuf.toString() 就能够拿到我们客户端发过来的字符串数据。</span><br><span class="line">         */</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(new Date() + &quot;: 服务端读到数据 -&gt; &quot; + byteBuf.toString(Charset.forName(&quot;utf-8&quot;)));</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">       服务端向客户端写数据逻辑与客户端侧的写数据逻辑一样，</span><br><span class="line">       先创建一个 ByteBuf，然后填充二进制数据，最后调用 writeAndFlush() 方法写出去</span><br><span class="line">        */</span><br><span class="line">        System.out.println(new Date() + &quot;: 服务端写出数据&quot;);</span><br><span class="line">        ByteBuf out = getByteBuf(ctx);</span><br><span class="line">        ctx.channel().writeAndFlush(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ByteBuf getByteBuf(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        byte[] bytes = &quot;你好!&quot;.getBytes(Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">        ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">        buffer.writeBytes(bytes);</span><br><span class="line">        return buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端再读入数据"><a href="#客户端再读入数据" class="headerlink" title="客户端再读入数据"></a>客户端再读入数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class FirstClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    // 写数据相关的逻辑省略</span><br><span class="line">    /*</span><br><span class="line">        客户端的读取数据的逻辑和服务端读取数据的逻辑一样，同样是覆盖 ChannelRead() 方法</span><br><span class="line">    */</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        System.out.println(new Date() + &quot;: 客户端读到数据 -&gt; &quot; + byteBuf.toString(Charset.forName(&quot;utf-8&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*异常处理覆盖的方法是 exceptionCaught()。记录 Throwable，关闭 Channel，在这个场景下，终止到服务器的连接*/</span><br><span class="line">@Override</span><br><span class="line">public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/11/08/11-8技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/11-8技术笔记/" itemprop="url">netty基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-08T15:37:36+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="netty特点"><a href="#netty特点" class="headerlink" title="netty特点"></a>netty特点</h2><ol>
<li><strong>高并发</strong>，通过非阻塞的NIO方式，使用了Selector，实现了高并发性。</li>
<li><strong>高传输</strong>，Netty针对这种情况，使用了NIO中的另一大特性——零拷贝，当他需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。</li>
<li><strong>封装好</strong>    </li>
</ol>
<h2 id="netty组成"><a href="#netty组成" class="headerlink" title="netty组成"></a>netty组成</h2><p> （客户端+服务端）*（启动连接+业务逻辑处理）。完成交互至少需要这四部分。</p>
<h2 id="netty术语"><a href="#netty术语" class="headerlink" title="netty术语"></a>netty术语</h2><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p><a href="https://imgchr.com/i/i7jEp8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/11/08/i7jEp8.md.png" alt="i7jEp8.md.png"></a>   </p>
<ol>
<li>Channel，表示一个连接，可以理解为每一个请求，就是一个Channel。</li>
<li>ChannelHandler，核心处理业务就在这里，用于处理业务请求。</li>
<li>ChannelHandlerContext，用于传输业务数据。</li>
<li>ChannelPipeline，用于保存处理过程需要用到的ChannelHandler和ChannelHandlerContext。   </li>
</ol>
<h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>ByteBuf是一个存储字节的容器，最大特点就是使用方便，它既有自己的读索引和写索引，方便你对整段字节缓存进行读写，也支持get/set，方便你对其中每一个字节进行读写.</p>
<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>EventLoopGroup 是用来处理I/O操作的多线程事件循环器.NioEventLoopGroup是其一个实现。<br>一般至少需要两个EventLoopGroup，boss这个EventLoopGroup作为一个acceptor负责接收来自客户端的请求，然后分发给worker这个EventLoopGroup来处理所有的事件event和channel的IO。    </p>
<h3 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h3><p>BootStrap在netty的应用程序中负责引导服务器和客户端。netty包含了两种不同类型的引导：</p>
<ol>
<li>使用服务器的ServerBootStrap，用于接受客户端的连接以及为已接受的连接创建子通道。</li>
<li>用于客户端的BootStrap，不接受新的连接，并且是在父通道类完成一些操作。<br>BootStrap配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(new SimpleChatServerInitializer())</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, 128)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, true);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>分别配置了BootStrap的EventLoop，channel，channelHandler来处理客户端的请求的channel的IO，设置TCP连接中的一些可选项，只作用于被acceptor(也就是boss EventLoopGroup)接收之后的channel的可选项。   </p>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>ChannelFuture是Channel结果的回调。当令Channel开始一个I/O操作时,会创建一个新的ChannelFuture去异步完成操作.<br>被创建时的ChannelFuture处于uncompleted状态(非失败,非成功,非取消);一旦ChannelFuture完成I/O操作,ChannelFuture将处于completed状态,结果可能有三种:</p>
<ol>
<li>操作成功</li>
<li>操作失败</li>
<li>操作被取消(I/O操作被主动终止)</li>
</ol>
<h2 id="channel生命周期"><a href="#channel生命周期" class="headerlink" title="channel生命周期"></a>channel生命周期</h2><p>下列重载函数在对应的时候触发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class LifeCyCleTestHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;逻辑处理器被添加：handlerAdded()&quot;);</span><br><span class="line">        super.handlerAdded(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 绑定到线程(NioEventLoop)：channelRegistered()&quot;);</span><br><span class="line">        super.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 准备就绪：channelActive()&quot;);</span><br><span class="line">        super.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 有数据可读：channelRead()&quot;);</span><br><span class="line">        super.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 某次数据读完：channelReadComplete()&quot;);</span><br><span class="line">        super.channelReadComplete(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 被关闭：channelInactive()&quot;);</span><br><span class="line">        super.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel 取消线程(NioEventLoop) 的绑定: channelUnregistered()&quot;);</span><br><span class="line">        super.channelUnregistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;逻辑处理器被移除：handlerRemoved()&quot;);</span><br><span class="line">        super.handlerRemoved(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/11/07/11-6技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/07/11-6技术笔记/" itemprop="url">SpringMVC+jsp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-07T11:13:45+08:00">
                2018-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>需要视图解析器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;</span><br><span class="line">  &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;/&gt;</span><br><span class="line">  &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果用jstl，还需要加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;taglibs&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;standard&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>为了避免.jsp进入spring的 DispatcherServlet类。DispatcherServlet中ServletMapping需要是/而不是/*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&lt; url-pattern &gt; / <url-pattern> 不会匹配到.jsp，即：.jsp不会进入spring的 DispatcherServlet类 。<br>&lt; url-pattern &gt; /<em> <url-pattern> 会匹配</url-pattern></em>.jsp，会出现返回jsp视图时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。</url-pattern></p>
<p>关于web.xml的url映射规则：<br>&lt; url-pattern&gt;/<url-pattern> 会匹配到/login这样的路径型url，不会匹配到模式为<em>.jsp这样的后缀型url<br>&lt; url-pattern&gt;/\</em></url-pattern> 会匹配所有url：路径型的和后缀型的url(包括/login,.jsp,.js和*.html等)</p>
<ol start="3">
<li>属性值引号冲突<br>如果属性的内容有引号，属性值的引号会冲突。实际上，HTML 中,属性值用双引号、单引号、不加引号都可以。此时，把双引号换成单引号即可。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/11/05/11-5技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/05/11-5技术笔记/" itemprop="url">数据库建表见闻</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-05T20:02:41+08:00">
                2018-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="UNIQUE-KEY"><a href="#UNIQUE-KEY" class="headerlink" title="UNIQUE KEY"></a>UNIQUE KEY</h2><p>UNIQUE KEY不但是字段不重复标识，还建立了索引，key和index是同义词。命名方式uk_字段名。</p>
<h2 id="VARCHAR"><a href="#VARCHAR" class="headerlink" title="VARCHAR"></a>VARCHAR</h2><p>varchar是变长的，再用两个字节来储存长度，所以varchar并不会怎么浪费空间。</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>不要想用null做标识（比如说null就是没激活，有值就是激活了）。因为不能=null。</p>
<h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><p>不要把enum的value定义为数字（0,1,2），不如直接用tinyint。<br>由以下原因：</p>
<ol>
<li><strong>无效值</strong> 如果将一个无效值插入一个 ENUM (即，一个不在允许值列表中的字符串)，空字符串将作为一个特殊的错误值被插入。事实上，这个字符串有别于一个”普通的”空字符串，因为这个字符串有个数字索引值为 0。如果一个 ENUM 被声明为 NULL，NULL 也是该列的一个合法值，并且该列的缺省值也将为 NULL 。如果一个 ENUM 被声明为 NOT NULL，该列的缺省值将是该列表所允许值的第一个成员。</li>
<li><strong>序号</strong> 在列说明中列表值所允许的成员值被从 1 开始编号。<strong>意味着你容易和数字搞混</strong> ，空字符串错误值的索引值为 0。这就意味着，你可以使用下面所示的 SELECT 语句找出被赋于无效 ENUM值的记录行。NULL 值的索引值为 NULL。<br>mysql&gt; SELECT * FROM tbl_name WHERE enum_col=0;   </li>
</ol>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>InnoDB经常访问的二级索引数据会自动被生成到hash索引里面去，这个功能可以开关。<br>可以想象，哈希索引等值查找更快，无法范围查找，大量数据有哈希冲突问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/11/01/11-1技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/01/11-1技术笔记/" itemprop="url">2PC,，3PC和Paxos</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-01T20:00:57+08:00">
                2018-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式数据一致性问题"><a href="#分布式数据一致性问题" class="headerlink" title="分布式数据一致性问题"></a>分布式数据一致性问题</h1><p>分布式一致性问题，即相互独立的节点之间如何就一项决议达成一致的问题。<br>根据CAP定理，分布式系统无法同时满足一致性，可用性和分区容错性。</p>
<ol>
<li>一致性是指，分布式的多个副本，其中一个在数据更新操作后，其他副本也要随之变化的能力。</li>
<li>可用性是指，系统提供的服务一直存在，即对于用户的每一个操作，总是能够在 <strong>有限的时间</strong>返回<strong>结果</strong>。无可用性意味着，如果部分故障了，系统将无法运行，只有等修好。</li>
<li>分区容错性是指，任何网络分区故障时，除非整个网络环境都发生了故障，仍然可以提供一致可用的服务，意思是别的地方不影响我这里。    </li>
</ol>
<p>BASE理论即使基于CAP定理的解决方案，BASE是指<strong>基本可用</strong>（如果故障，损失部分可用，比如延长返回时间，或者返回结果降级），<strong>软状态</strong>（允许数据存在中间状态，即允许有个延时同步的过程），<strong>最终一致</strong>（实时数据不一定同步，但最终一定是同步的）。</p>
<h1 id="2PC与3PC"><a href="#2PC与3PC" class="headerlink" title="2PC与3PC"></a>2PC与3PC</h1><p>分布式系统中，任何节点在事务操作后，通知其他节点同步时，不一定信息传输成功，其他节点也执行该事务也不定成功。2PC和3PC都是使用一个协调者，节点先将事务提交给协调者，协调者协调各节点执行。</p>
<h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>2PC形象的说，协调者就是神父，各节点就是新娘新郎，神父问，“你愿意吗”，如果都回答愿意，则结婚，如果有人回答不愿意或者无响应，则回滚。具体步骤：  </p>
<h3 id="阶段1：准备阶段"><a href="#阶段1：准备阶段" class="headerlink" title="阶段1：准备阶段"></a>阶段1：准备阶段</h3><p>　　1、协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。<br>　　2、各参与者执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）。<br>　　3、如参与者执行成功，给协调者反馈YES，即可以提交；如执行失败，给协调者反馈NO，即不可提交。</p>
<h3 id="阶段2：提交阶段"><a href="#阶段2：提交阶段" class="headerlink" title="阶段2：提交阶段"></a>阶段2：提交阶段</h3><p>　　此阶段分两种情况：所有参与者均反馈YES、或任何一个参与者反馈NO。<br>　　所有参与者均反馈YES时，即提交事务。<br>　　任何一个参与者反馈NO时，即中断事务。  </p>
<p>　　提交事务：（所有参与者均反馈YES）<br>　　1、协调者向所有参与者发出正式提交事务的请求（即Commit请求）。<br>　　2、参与者执行Commit请求，并释放整个事务期间占用的资源。<br>　　3、各参与者向协调者反馈Ack完成的消息。<br>　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务提交。<br><img src="https://s1.ax1x.com/2018/11/02/ihkmcD.png" alt="ihkmcD.png">  </p>
<p><img src="https://s1.ax1x.com/2018/11/02/ihke1O.png" alt="ihke1O.png"></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>同步阻塞问题。</strong> 执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。原因在于准备阶段各参与者已经执行了事务，如果协调者在等待超时，各参与者也阻塞了。</li>
<li><strong>单点故障。</strong> 由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li>
<li><strong>脑裂。</strong> 在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。</li>
<li><strong>未知事务提交</strong> ：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li>
</ol>
<h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><p>为了解决以上问题，把准备阶段再一分为二，变成三阶段，就是3PC。<br>3PC相比于2PC，相当于多了步预约，先确定一下是否可以执行事务操作，再让各参与者执行事务。而参与者也会超时。</p>
<h3 id="阶段1：CanCommit"><a href="#阶段1：CanCommit" class="headerlink" title="阶段1：CanCommit"></a>阶段1：CanCommit</h3><p>1、协调者向所有参与者发出包含事务内容的CanCommit请求，询问是否可以提交事务，并等待所有参与者答复。<br>2、参与者收到CanCommit请求后，如果认为可以执行事务操作，则反馈YES并进入预备状态，否则反馈NO。</p>
<h3 id="阶段2：PreCommit"><a href="#阶段2：PreCommit" class="headerlink" title="阶段2：PreCommit"></a>阶段2：PreCommit</h3><p>此阶段分两种情况：<br>　　1、所有参与者均反馈YES，即执行事务预提交。<br>　　2、任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。    </p>
<p>　　事务预提交：（所有参与者均反馈YES时）<br>　　1、协调者向所有参与者发出PreCommit请求，进入准备阶段。<br>　　2、参与者收到PreCommit请求后，执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）。<br>　　3、各参与者向协调者反馈Ack响应或No响应，并等待最终指令。   </p>
<p>　　中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）<br>　　1、协调者向所有参与者发出abort请求。<br>　　2、无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。       </p>
<h3 id="阶段3：do-Commit"><a href="#阶段3：do-Commit" class="headerlink" title="阶段3：do Commit"></a>阶段3：do Commit</h3><p>此阶段也存在两种情况：<br>　　1、所有参与者均反馈Ack响应，即执行真正的事务提交。<br>　　2、任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。    </p>
<p>　　提交事务：（所有参与者均反馈Ack响应时）<br>　　1、如果协调者处于工作状态，则向所有参与者发出do Commit请求。<br>　　2、参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源。<br>　　3、各参与者向协调者反馈Ack完成的消息。<br>　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务提交。    </p>
<p>　　中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）<br>　　1、如果协调者处于工作状态，向所有参与者发出abort请求。<br>　　2、参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源。<br>　　3、各参与者向协调者反馈Ack完成的消息。<br>　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务中断。    </p>
<p>　　注意：进入阶段三后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的do Commit请求或abort请求。此时，参与者都会在等待超时之后，继续执行事务提交。<br> <img src="https://s1.ax1x.com/2018/11/02/ihAYI1.png" alt="ihAYI1.png">   </p>
<h3 id="3PC解决了什么"><a href="#3PC解决了什么" class="headerlink" title="3PC解决了什么"></a>3PC解决了什么</h3><ol>
<li>同步阻塞问题，由于第一阶段未执行事务，减少了同步阻塞的时间段。</li>
<li>单点故障，如果第二阶段协调者超时，参与者会执行事务，减少协调者故障带来的影响。    </li>
</ol>
<h3 id="3PC还存在的问题"><a href="#3PC还存在的问题" class="headerlink" title="3PC还存在的问题"></a>3PC还存在的问题</h3><p>3PC依然是中心化的，那就依然有会局部数据不一致问题，在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。所以，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p>
<h1 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h1><p>只有Paxos是一致的，世上只有一种一致性算法，那就是Paxos。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一个分布式系统，储存了一个变量var，系统内部由多个accepter组成，他们多保存其副本，系统对外提供api,用来设置var变量的值<br>propose(var,V) =&gt; &lt;ok,f&gt; or <error>，将var的值设置为V，系统会返回ok和系统中已经确定的取值f，或者返回error。外部有多个Proposer机器任意请求系统，调用系统API(propose(var,V) =&gt; &lt;ok,f&gt; or <error>)来设置var变量的值。如果系统成功的将var设置成了V，那么返回的f应该就是V的值。否则，系统返回的f就是其他的Proposer设置的值。<br>系统需求：  </error></error></p>
<ol>
<li>一致性：如果var没有被设置过，那么他的初始值为null，一旦var的值被设置成功，则不可被更改，并且可以一直都能获取到这个值。</li>
<li>容错性：可以容忍任意proposer出现故障，可以容忍少数acceptor故障（半数以下）。   </li>
</ol>
<h2 id="解决方案大话版"><a href="#解决方案大话版" class="headerlink" title="解决方案大话版"></a>解决方案大话版</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>假如有一群驴友要决定中秋节去旅游，这群驴友分布在全国各地，假定一共25个人，分别在不同的省，要决定到底去拉萨、昆明、三亚等等哪个地点（会合时间中秋节已经定了，此时需要决定旅游地）。<br>这25个人找了另外的5个人（当然这5个人可以从25个人中选，这里为了描述方便，就单拿出另外5个人），25个人都给他们发短信，告诉自己倾向的旅游地。这5个人相互之间可以并不通信，只接受25个人发过来的短信。这25个人我们称为驴友，那5个人称为队长。</p>
<h3 id="驴友逻辑"><a href="#驴友逻辑" class="headerlink" title="驴友逻辑"></a>驴友逻辑</h3><h4 id="第一步（申请阶段）："><a href="#第一步（申请阶段）：" class="headerlink" title="第一步（申请阶段）："></a>第一步（申请阶段）：</h4><p>询问5个队长，试图与队长沟通旅游地。因为每个队长一直会收到不同驴友的短信，不能跟多个驴友一起沟通，在任何时刻只能跟一个驴友沟通，按照什么原则才能做到公平公正公开呢？这些短信都带有发送时间，队长采用的原则是同意与短信发送时间最新的驴友沟通，如果出现了更新的短信，则与短信更新的驴友沟通。总之，作为一个有话语权的人，只有时刻保持倾听最新的呼声，才能做出最明智的选择。在驴友发出短信后，等着队长回复。某些队长可能会回复说，你这条短信太老了，我不与你沟通；有些队长则可能返回说，你的短信是我收到的最新的，我同意跟你沟通。对于后面这些队长，还得返回自己决定的旅游地。关于队长是怎么决定旅游地的，后面再说。</p>
<p>对于驴友来说，第一步必须至少有半数以上队长都同意沟通了，才能进入下一步。否则，你连沟通的资格都没有，一直在那儿狂发吧。你发的短信越新，你获得沟通权的可能性才更大。。。。。。</p>
<p>因为至少有半数以上队长（也就是3个队长以上）同意，你才能与队长们进行实质性的沟通，也就是进入第二步；而队长在任何时候只能跟1个驴友沟通，所以，在任何时候，不可能出现两个驴友都达到了这个状态。。。当然，你可以通过狂发短信把沟通权抢了。。。。</p>
<p>对于获得沟通权的那个驴友（称为A），那些队长会给他发送他们自己决定的旅游地（也可能都还没有决定）。可以看出，各个队长是自己决定旅游地的，队长之间无需沟通。</p>
<h4 id="第二步（沟通阶段）："><a href="#第二步（沟通阶段）：" class="headerlink" title="第二步（沟通阶段）："></a>第二步（沟通阶段）：</h4><p>这个幸运的驴友收到了队长们给他发的旅游地，可能有几种情况：</p>
<p>第一种情况：跟A沟通的队长们（不一定是全部5个队长，但是半数以上）还没有决定到底去那儿旅游，此时驴友A心花怒放，给这些队长发第二条短信，告诉他们自己希望的旅游地（比如马尔代夫）；</p>
<p>可能会收到两种结果：一是半数以上队长都同意了，于是表明A建议的马尔代夫被半数以上队长都同意了，整个决定过程完毕了，其它驴友迟早会知道这个消息的，A先去收拾东西准备去马尔代夫；除此之外，表明失败。可能队长出故障了，比如某个队长在跟女朋友打电话等等，也可能被其它驴友抢占沟通权了（因为队长喜新厌旧嘛，只有要更新的驴友给自己发短信，自己就与新人沟通，A的建议队长不同意）等等。不管怎么说，苦逼的A还得重新从第一步开始，重新给队长们发短信申请。</p>
<p>第二种情况：至少有一个队长已经决定旅游地了，A可能会收到来自不同队长决定的多个旅游地，这些旅游地是不同队长跟不同驴友在不同时间上做出的决定，那么，A会先看一下，是不是有的旅游地已经被半数以上队长同意了（比如3个队长都同意去三亚，1个同意去昆明，另外一个没搭理A），如果出现了这种情况，那就别扯了，说明整个决定过程已经达成一致了，收拾收拾准备去三亚吧，结束了；如果都没有达到半数以上（比如1个同意去昆明，1个同意去三亚，2个同意去拉萨，1个没搭理我），A作为一个高素质驴友，也不按照自己的意愿乱来了（Paxos的关键所在，后者认同前者，否则整个决定过程永无止境），虽然自己原来可能想去马尔代夫等等。就给队长们发第二条短信的时候，告诉他们自己希望的旅游地，就是自己收到的那堆旅游地中最新决定的那个。（比如，去昆明那个是北京那个队长前1分钟决定的，去三亚的决定是上海那个队长1个小时之前做出来的，于是顶昆明）。驴友A的想法是，既然有队长已经做决定了，那我就干脆顶最新那个决定。</p>
<p>从上面的逻辑可以看出，一旦某个时刻有半数以上队长同意了某个地点比如昆明，紧跟着后面的驴友B继续发短信时，如果获得沟通权，因为半数以上队长都同意与B沟通了，说明B收到了来自半数以上队长发过来的消息，B必然会收到至少一个队长给他发的昆明这个结果（抽屉原理），B于是会顶这个最新地点，不会更改，因为后面的驴友都会顶昆明，因此同意昆明的队长越来越多，最终必然达成一致。</p>
<h2 id="队长逻辑"><a href="#队长逻辑" class="headerlink" title="队长逻辑"></a>队长逻辑</h2><p>队长的逻辑比较简单。</p>
<p>在申请阶段，队长只会选择与最新发申请短信的驴友沟通，队长知道自己接收到最新短信的时间，对于更老的短信，队长不会搭理；队长同意沟通了的话，会把自己决定的旅游地（或者还没决定这一信息）发给驴友。</p>
<p>在沟通阶段，驴友C会把自己希望的旅游地发过来（同时会附加上自己申请短信的时间，比如3分钟前），所以队长要检查一下，如果这个时间（3分钟前）确实是当前自己最新接收到申请短信的时间（说明这段时间没有驴友要跟自己沟通），那么，队长就同意驴友C的这个旅游地了（比如昆明，哪怕自己1个小时前已经做过去三亚的决定，谁让C更新呢，于是更新为昆明）；如果不是最新的，说明这3分钟内又有其它驴友D跟自己申请了，因为自己是个喜新厌旧的家伙，同意与D沟通了，所以驴友C的决定自己不会同意，等着D一会儿要发过来的决定吧。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Paxos主要用于保证分布式存储中副本（或者状态）的一致性。副本要保持一致，那么，所有副本的更新序列就要保持一致。因为数据的增删改查操作一般都存在多个客户端并发操作，到底哪个客户端先做，哪个客户端后做，这就是更新顺序。<br>Paxos解决这一问题利用的是选举，少数服从多数的思想，只要2N+1个节点中，有N个以上同意了某个决定，则认为系统达到了一致，并且按照Paxos原则，最终理论上也达到了一致，不会再改变。这样的话，客户端不必与所有服务器通信，选择与大部分通信即可；也无需服务器都全部处于工作状态，有一些服务器挂掉，只有保证半数以上存活着，整个过程也能持续下去，容错性相当好。          </p>
<ol>
<li>实际上，上面的驴友方案，还是有问题，就是在沟通阶段，有可能两个人互相循环占有，导致死锁，为了解决这个问题，采用加权的方式，也就是主提案者来解决。      </li>
<li>而沟通阶段最后的达成阶段，也不需要向全队长集合发送响应，只需要向一个超过半数的队长集合响应，并获得批准即可。因为两个半数以上集合交集必然不是空集。</li>
<li>实际系统不止提案者（驴友）和接受者（队长），还包括学习者，就像驴友其实是导游。学习者只获取消息，没有决定权。学习者获取消息方法有三种：第一是，接受者每批准一个提案，都发给所有学习者，缺点是消息太多；第二是，选一个信使，接受者告诉信使，信使告诉学习者，这样太中心化了；第三折中就是，选取一个信使集合。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/30/10-30技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/30/10-30技术笔记/" itemprop="url">HTTPS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-30T17:36:23+08:00">
                2018-10-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>HPPTS是对HTTPS的改进，之所以使用HTTPS,主要出于安全性的考虑。防嗅探，防篡改，防假冒。</p>
<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>HTTPS=HTTP+SSL/TSL;<br>SSL/TLS是安全层套结，简单来说，使用非对称加密的方式，处理传输的信息，保证安全。</p>
<h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><p>操作步骤，简单来说，由于客户端向服务端索要一个非对称加密的公钥，使用数字证书/CA的方式，验证索要的公钥，同时服务端持有私钥。由于非对称加密速度较慢，所以采用双重加密的方式，非对称加密用来加密【对称加密】的密钥，这样一次会话只用一次非对称加密。随后双方用对称加密进行交流。<br>具体步骤<br><img src="https://s1.ax1x.com/2018/10/30/i2xFbD.png" alt="i2xFbD.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/29/10-29技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/10-29技术笔记/" itemprop="url">注解@PostConstruct和@PreDestroy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-29T16:45:30+08:00">
                2018-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PostConstruct和-PreDestroy"><a href="#PostConstruct和-PreDestroy" class="headerlink" title="@PostConstruct和@PreDestroy"></a>@PostConstruct和@PreDestroy</h1><p>方法注解，实现Bean初始化之前和销毁之前的自定义操作。<br>在项目中@PostConstruct主要应用场景是在初始化Servlet时加载一些缓存数据等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class TsyeService &#123;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @PostConstruct</span><br><span class="line">    void post()&#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @PreDestroy</span><br><span class="line">    void pre()&#123;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/26/10-26技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/10-26技术笔记/" itemprop="url">push，pull，长轮询</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-26T19:12:06+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="push，pull，长轮询"><a href="#push，pull，长轮询" class="headerlink" title="push，pull，长轮询"></a>push，pull，长轮询</h1><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>push模式就是服务器和客户端保持连接，服务器一旦有信息，就“推送”至客户端。但实际上，由于tcp协议的原因，保持连接几乎不可能。问题在于：第一服务端一直在工作压力大，第二客户端处理能力各不相同且不受客户端控制，有客户端堆积的风险。  </p>
<h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>pull就是，客户端一直在工作，不断从服务端拉取数据保存在本地，只要满足设定的条件，就一直向服务端索取数据。</p>
<h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>服务端不一定一直有消息，每隔一秒问一次有没有数据，结果都没有，这样就很浪费，不如派一个委托，在那里等着，一旦有数据就返回，或者等太久了也返回。这就是长轮询。实际上现在的push一般都是由长轮询实现。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/25/10-25技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/10-25技术笔记/" itemprop="url">范式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-25T17:18:52+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><p>第一范式很简单，是关系型数据库的基础，简单来说，每个属性，即每列，只有一个值。</p>
<h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><p>第二范式开始考虑依赖，数据库很多列，一些列的存在依赖于其他列，这就是依赖关系。比如说，学生表，属性有学号，姓名，性别，年龄。后三个属性都依赖于学号，也就是说，只要给一个学号，就能给出其他三个属性的值，反之则不能。<br>属性的集合有很多元素，从中找到一组最基础的元素，其他元素都可以由这组元素得出，这组元素则为联合主键。比如选课表，属性有学号，姓名，性别，课程码，课程名，授课老师，授课老师电话，成绩。则联合主键为（学号，课程码），姓名、性别由学号决定，课程名、老师、授课老师电话由课程码决定，成绩由学号课程码联合决定。<br>那么此时，非联合主键中的元素，一些由联合主键全部元素决定，另一些由联合主键中部分元素决定。前者叫完全依赖，后者叫部分依赖。<br>第二范式就是不能有部分依赖。如果有部分依赖，应该拆表。<br>比如选课表就应该拆成三个，姓名、性别由学号决定：是学生表；课程名、老师、授课老师电话由课程码决定；是课程表；成绩由学号、课程码联合决定，是选课表。  </p>
<h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><p>我们单独再看课程表，虽然对于任何一个课程码，我们都可以说出课程名、老师、授课老师电话，但是其实这些非主键元素，内部依然有依赖关系。我们并不是直接知道授课老师电话的，实际上授课老师电话依赖于老师，我们通过课程码知道老师，通过老师知道了电话，这之间有个传递的过程，这就是传递依赖。<br>第三范式就是讲，不能有传递依赖。为解决继续拆表。<br>老师电话依赖于老师，拆出一个通讯录表。</p>
<h1 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h1><p>BC范式相当于是3.5范式，相比于第三范式，追加了要求，不但非主键元素不依赖，主键元素也不能有依赖关系。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Arvense</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">248</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>


  
</div>


  <div class="powered-by">Powered by <a>Arvense</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">blog   </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
