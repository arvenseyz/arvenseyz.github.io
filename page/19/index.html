<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Arvense, NexT">





  <link rel="alternate" href="/atom.xml" title="Arvense" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Arvense">
<meta property="og:url" content="https://arvenseyz.github.io/page/19/index.html">
<meta property="og:site_name" content="Arvense">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Arvense">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://arvenseyz.github.io/page/19/">





  <title>Arvense</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Arvense</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/11/01/11-1技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/01/11-1技术笔记/" itemprop="url">2PC,，3PC和Paxos</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-01T20:00:57+08:00">
                2018-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式数据一致性问题"><a href="#分布式数据一致性问题" class="headerlink" title="分布式数据一致性问题"></a>分布式数据一致性问题</h1><p>分布式一致性问题，即相互独立的节点之间如何就一项决议达成一致的问题。<br>根据CAP定理，分布式系统无法同时满足一致性，可用性和分区容错性。</p>
<ol>
<li>一致性是指，分布式的多个副本，其中一个在数据更新操作后，其他副本也要随之变化的能力。</li>
<li>可用性是指，系统提供的服务一直存在，即对于用户的每一个操作，总是能够在 <strong>有限的时间</strong>返回<strong>结果</strong>。无可用性意味着，如果部分故障了，系统将无法运行，只有等修好。</li>
<li>分区容错性是指，任何网络分区故障时，除非整个网络环境都发生了故障，仍然可以提供一致可用的服务，意思是别的地方不影响我这里。    </li>
</ol>
<p>BASE理论即使基于CAP定理的解决方案，BASE是指<strong>基本可用</strong>（如果故障，损失部分可用，比如延长返回时间，或者返回结果降级），<strong>软状态</strong>（允许数据存在中间状态，即允许有个延时同步的过程），<strong>最终一致</strong>（实时数据不一定同步，但最终一定是同步的）。</p>
<h1 id="2PC与3PC"><a href="#2PC与3PC" class="headerlink" title="2PC与3PC"></a>2PC与3PC</h1><p>分布式系统中，任何节点在事务操作后，通知其他节点同步时，不一定信息传输成功，其他节点也执行该事务也不定成功。2PC和3PC都是使用一个协调者，节点先将事务提交给协调者，协调者协调各节点执行。</p>
<h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>2PC形象的说，协调者就是神父，各节点就是新娘新郎，神父问，“你愿意吗”，如果都回答愿意，则结婚，如果有人回答不愿意或者无响应，则回滚。具体步骤：  </p>
<h3 id="阶段1：准备阶段"><a href="#阶段1：准备阶段" class="headerlink" title="阶段1：准备阶段"></a>阶段1：准备阶段</h3><p>　　1、协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。<br>　　2、各参与者执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）。<br>　　3、如参与者执行成功，给协调者反馈YES，即可以提交；如执行失败，给协调者反馈NO，即不可提交。</p>
<h3 id="阶段2：提交阶段"><a href="#阶段2：提交阶段" class="headerlink" title="阶段2：提交阶段"></a>阶段2：提交阶段</h3><p>　　此阶段分两种情况：所有参与者均反馈YES、或任何一个参与者反馈NO。<br>　　所有参与者均反馈YES时，即提交事务。<br>　　任何一个参与者反馈NO时，即中断事务。  </p>
<p>　　提交事务：（所有参与者均反馈YES）<br>　　1、协调者向所有参与者发出正式提交事务的请求（即Commit请求）。<br>　　2、参与者执行Commit请求，并释放整个事务期间占用的资源。<br>　　3、各参与者向协调者反馈Ack完成的消息。<br>　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务提交。<br><img src="https://s1.ax1x.com/2018/11/02/ihkmcD.png" alt="ihkmcD.png">  </p>
<p><img src="https://s1.ax1x.com/2018/11/02/ihke1O.png" alt="ihke1O.png"></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>同步阻塞问题。</strong> 执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。原因在于准备阶段各参与者已经执行了事务，如果协调者在等待超时，各参与者也阻塞了。</li>
<li><strong>单点故障。</strong> 由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li>
<li><strong>脑裂。</strong> 在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。</li>
<li><strong>未知事务提交</strong> ：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li>
</ol>
<h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><p>为了解决以上问题，把准备阶段再一分为二，变成三阶段，就是3PC。<br>3PC相比于2PC，相当于多了步预约，先确定一下是否可以执行事务操作，再让各参与者执行事务。而参与者也会超时。</p>
<h3 id="阶段1：CanCommit"><a href="#阶段1：CanCommit" class="headerlink" title="阶段1：CanCommit"></a>阶段1：CanCommit</h3><p>1、协调者向所有参与者发出包含事务内容的CanCommit请求，询问是否可以提交事务，并等待所有参与者答复。<br>2、参与者收到CanCommit请求后，如果认为可以执行事务操作，则反馈YES并进入预备状态，否则反馈NO。</p>
<h3 id="阶段2：PreCommit"><a href="#阶段2：PreCommit" class="headerlink" title="阶段2：PreCommit"></a>阶段2：PreCommit</h3><p>此阶段分两种情况：<br>　　1、所有参与者均反馈YES，即执行事务预提交。<br>　　2、任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。    </p>
<p>　　事务预提交：（所有参与者均反馈YES时）<br>　　1、协调者向所有参与者发出PreCommit请求，进入准备阶段。<br>　　2、参与者收到PreCommit请求后，执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）。<br>　　3、各参与者向协调者反馈Ack响应或No响应，并等待最终指令。   </p>
<p>　　中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）<br>　　1、协调者向所有参与者发出abort请求。<br>　　2、无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。       </p>
<h3 id="阶段3：do-Commit"><a href="#阶段3：do-Commit" class="headerlink" title="阶段3：do Commit"></a>阶段3：do Commit</h3><p>此阶段也存在两种情况：<br>　　1、所有参与者均反馈Ack响应，即执行真正的事务提交。<br>　　2、任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。    </p>
<p>　　提交事务：（所有参与者均反馈Ack响应时）<br>　　1、如果协调者处于工作状态，则向所有参与者发出do Commit请求。<br>　　2、参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源。<br>　　3、各参与者向协调者反馈Ack完成的消息。<br>　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务提交。    </p>
<p>　　中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）<br>　　1、如果协调者处于工作状态，向所有参与者发出abort请求。<br>　　2、参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源。<br>　　3、各参与者向协调者反馈Ack完成的消息。<br>　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务中断。    </p>
<p>　　注意：进入阶段三后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的do Commit请求或abort请求。此时，参与者都会在等待超时之后，继续执行事务提交。<br> <img src="https://s1.ax1x.com/2018/11/02/ihAYI1.png" alt="ihAYI1.png">   </p>
<h3 id="3PC解决了什么"><a href="#3PC解决了什么" class="headerlink" title="3PC解决了什么"></a>3PC解决了什么</h3><ol>
<li>同步阻塞问题，由于第一阶段未执行事务，减少了同步阻塞的时间段。</li>
<li>单点故障，如果第二阶段协调者超时，参与者会执行事务，减少协调者故障带来的影响。    </li>
</ol>
<h3 id="3PC还存在的问题"><a href="#3PC还存在的问题" class="headerlink" title="3PC还存在的问题"></a>3PC还存在的问题</h3><p>3PC依然是中心化的，那就依然有会局部数据不一致问题，在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。所以，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p>
<h1 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h1><p>只有Paxos是一致的，世上只有一种一致性算法，那就是Paxos。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一个分布式系统，储存了一个变量var，系统内部由多个accepter组成，他们多保存其副本，系统对外提供api,用来设置var变量的值<br>propose(var,V) =&gt; &lt;ok,f&gt; or <error>，将var的值设置为V，系统会返回ok和系统中已经确定的取值f，或者返回error。外部有多个Proposer机器任意请求系统，调用系统API(propose(var,V) =&gt; &lt;ok,f&gt; or <error>)来设置var变量的值。如果系统成功的将var设置成了V，那么返回的f应该就是V的值。否则，系统返回的f就是其他的Proposer设置的值。<br>系统需求：  </error></error></p>
<ol>
<li>一致性：如果var没有被设置过，那么他的初始值为null，一旦var的值被设置成功，则不可被更改，并且可以一直都能获取到这个值。</li>
<li>容错性：可以容忍任意proposer出现故障，可以容忍少数acceptor故障（半数以下）。   </li>
</ol>
<h2 id="解决方案大话版"><a href="#解决方案大话版" class="headerlink" title="解决方案大话版"></a>解决方案大话版</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>假如有一群驴友要决定中秋节去旅游，这群驴友分布在全国各地，假定一共25个人，分别在不同的省，要决定到底去拉萨、昆明、三亚等等哪个地点（会合时间中秋节已经定了，此时需要决定旅游地）。<br>这25个人找了另外的5个人（当然这5个人可以从25个人中选，这里为了描述方便，就单拿出另外5个人），25个人都给他们发短信，告诉自己倾向的旅游地。这5个人相互之间可以并不通信，只接受25个人发过来的短信。这25个人我们称为驴友，那5个人称为队长。</p>
<h3 id="驴友逻辑"><a href="#驴友逻辑" class="headerlink" title="驴友逻辑"></a>驴友逻辑</h3><h4 id="第一步（申请阶段）："><a href="#第一步（申请阶段）：" class="headerlink" title="第一步（申请阶段）："></a>第一步（申请阶段）：</h4><p>询问5个队长，试图与队长沟通旅游地。因为每个队长一直会收到不同驴友的短信，不能跟多个驴友一起沟通，在任何时刻只能跟一个驴友沟通，按照什么原则才能做到公平公正公开呢？这些短信都带有发送时间，队长采用的原则是同意与短信发送时间最新的驴友沟通，如果出现了更新的短信，则与短信更新的驴友沟通。总之，作为一个有话语权的人，只有时刻保持倾听最新的呼声，才能做出最明智的选择。在驴友发出短信后，等着队长回复。某些队长可能会回复说，你这条短信太老了，我不与你沟通；有些队长则可能返回说，你的短信是我收到的最新的，我同意跟你沟通。对于后面这些队长，还得返回自己决定的旅游地。关于队长是怎么决定旅游地的，后面再说。</p>
<p>对于驴友来说，第一步必须至少有半数以上队长都同意沟通了，才能进入下一步。否则，你连沟通的资格都没有，一直在那儿狂发吧。你发的短信越新，你获得沟通权的可能性才更大。。。。。。</p>
<p>因为至少有半数以上队长（也就是3个队长以上）同意，你才能与队长们进行实质性的沟通，也就是进入第二步；而队长在任何时候只能跟1个驴友沟通，所以，在任何时候，不可能出现两个驴友都达到了这个状态。。。当然，你可以通过狂发短信把沟通权抢了。。。。</p>
<p>对于获得沟通权的那个驴友（称为A），那些队长会给他发送他们自己决定的旅游地（也可能都还没有决定）。可以看出，各个队长是自己决定旅游地的，队长之间无需沟通。</p>
<h4 id="第二步（沟通阶段）："><a href="#第二步（沟通阶段）：" class="headerlink" title="第二步（沟通阶段）："></a>第二步（沟通阶段）：</h4><p>这个幸运的驴友收到了队长们给他发的旅游地，可能有几种情况：</p>
<p>第一种情况：跟A沟通的队长们（不一定是全部5个队长，但是半数以上）还没有决定到底去那儿旅游，此时驴友A心花怒放，给这些队长发第二条短信，告诉他们自己希望的旅游地（比如马尔代夫）；</p>
<p>可能会收到两种结果：一是半数以上队长都同意了，于是表明A建议的马尔代夫被半数以上队长都同意了，整个决定过程完毕了，其它驴友迟早会知道这个消息的，A先去收拾东西准备去马尔代夫；除此之外，表明失败。可能队长出故障了，比如某个队长在跟女朋友打电话等等，也可能被其它驴友抢占沟通权了（因为队长喜新厌旧嘛，只有要更新的驴友给自己发短信，自己就与新人沟通，A的建议队长不同意）等等。不管怎么说，苦逼的A还得重新从第一步开始，重新给队长们发短信申请。</p>
<p>第二种情况：至少有一个队长已经决定旅游地了，A可能会收到来自不同队长决定的多个旅游地，这些旅游地是不同队长跟不同驴友在不同时间上做出的决定，那么，A会先看一下，是不是有的旅游地已经被半数以上队长同意了（比如3个队长都同意去三亚，1个同意去昆明，另外一个没搭理A），如果出现了这种情况，那就别扯了，说明整个决定过程已经达成一致了，收拾收拾准备去三亚吧，结束了；如果都没有达到半数以上（比如1个同意去昆明，1个同意去三亚，2个同意去拉萨，1个没搭理我），A作为一个高素质驴友，也不按照自己的意愿乱来了（Paxos的关键所在，后者认同前者，否则整个决定过程永无止境），虽然自己原来可能想去马尔代夫等等。就给队长们发第二条短信的时候，告诉他们自己希望的旅游地，就是自己收到的那堆旅游地中最新决定的那个。（比如，去昆明那个是北京那个队长前1分钟决定的，去三亚的决定是上海那个队长1个小时之前做出来的，于是顶昆明）。驴友A的想法是，既然有队长已经做决定了，那我就干脆顶最新那个决定。</p>
<p>从上面的逻辑可以看出，一旦某个时刻有半数以上队长同意了某个地点比如昆明，紧跟着后面的驴友B继续发短信时，如果获得沟通权，因为半数以上队长都同意与B沟通了，说明B收到了来自半数以上队长发过来的消息，B必然会收到至少一个队长给他发的昆明这个结果（抽屉原理），B于是会顶这个最新地点，不会更改，因为后面的驴友都会顶昆明，因此同意昆明的队长越来越多，最终必然达成一致。</p>
<h2 id="队长逻辑"><a href="#队长逻辑" class="headerlink" title="队长逻辑"></a>队长逻辑</h2><p>队长的逻辑比较简单。</p>
<p>在申请阶段，队长只会选择与最新发申请短信的驴友沟通，队长知道自己接收到最新短信的时间，对于更老的短信，队长不会搭理；队长同意沟通了的话，会把自己决定的旅游地（或者还没决定这一信息）发给驴友。</p>
<p>在沟通阶段，驴友C会把自己希望的旅游地发过来（同时会附加上自己申请短信的时间，比如3分钟前），所以队长要检查一下，如果这个时间（3分钟前）确实是当前自己最新接收到申请短信的时间（说明这段时间没有驴友要跟自己沟通），那么，队长就同意驴友C的这个旅游地了（比如昆明，哪怕自己1个小时前已经做过去三亚的决定，谁让C更新呢，于是更新为昆明）；如果不是最新的，说明这3分钟内又有其它驴友D跟自己申请了，因为自己是个喜新厌旧的家伙，同意与D沟通了，所以驴友C的决定自己不会同意，等着D一会儿要发过来的决定吧。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Paxos主要用于保证分布式存储中副本（或者状态）的一致性。副本要保持一致，那么，所有副本的更新序列就要保持一致。因为数据的增删改查操作一般都存在多个客户端并发操作，到底哪个客户端先做，哪个客户端后做，这就是更新顺序。<br>Paxos解决这一问题利用的是选举，少数服从多数的思想，只要2N+1个节点中，有N个以上同意了某个决定，则认为系统达到了一致，并且按照Paxos原则，最终理论上也达到了一致，不会再改变。这样的话，客户端不必与所有服务器通信，选择与大部分通信即可；也无需服务器都全部处于工作状态，有一些服务器挂掉，只有保证半数以上存活着，整个过程也能持续下去，容错性相当好。          </p>
<ol>
<li>实际上，上面的驴友方案，还是有问题，就是在沟通阶段，有可能两个人互相循环占有，导致死锁，为了解决这个问题，采用加权的方式，也就是主提案者来解决。      </li>
<li>而沟通阶段最后的达成阶段，也不需要向全队长集合发送响应，只需要向一个超过半数的队长集合响应，并获得批准即可。因为两个半数以上集合交集必然不是空集。</li>
<li>实际系统不止提案者（驴友）和接受者（队长），还包括学习者，就像驴友其实是导游。学习者只获取消息，没有决定权。学习者获取消息方法有三种：第一是，接受者每批准一个提案，都发给所有学习者，缺点是消息太多；第二是，选一个信使，接受者告诉信使，信使告诉学习者，这样太中心化了；第三折中就是，选取一个信使集合。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/30/10-30技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/30/10-30技术笔记/" itemprop="url">HTTPS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-30T17:36:23+08:00">
                2018-10-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>HPPTS是对HTTPS的改进，之所以使用HTTPS,主要出于安全性的考虑。防嗅探，防篡改，防假冒。</p>
<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>HTTPS=HTTP+SSL/TSL;<br>SSL/TLS是安全层套结，简单来说，使用非对称加密的方式，处理传输的信息，保证安全。</p>
<h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><p>操作步骤，简单来说，由于客户端向服务端索要一个非对称加密的公钥，使用数字证书/CA的方式，验证索要的公钥，同时服务端持有私钥。由于非对称加密速度较慢，所以采用双重加密的方式，非对称加密用来加密【对称加密】的密钥，这样一次会话只用一次非对称加密。随后双方用对称加密进行交流。<br>具体步骤<br><img src="https://s1.ax1x.com/2018/10/30/i2xFbD.png" alt="i2xFbD.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/29/10-29技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/10-29技术笔记/" itemprop="url">注解@PostConstruct和@PreDestroy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-29T16:45:30+08:00">
                2018-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PostConstruct和-PreDestroy"><a href="#PostConstruct和-PreDestroy" class="headerlink" title="@PostConstruct和@PreDestroy"></a>@PostConstruct和@PreDestroy</h1><p>方法注解，实现Bean初始化之前和销毁之前的自定义操作。<br>在项目中@PostConstruct主要应用场景是在初始化Servlet时加载一些缓存数据等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class TsyeService &#123;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @PostConstruct</span><br><span class="line">    void post()&#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @PreDestroy</span><br><span class="line">    void pre()&#123;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/26/10-26技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/10-26技术笔记/" itemprop="url">push，pull，长轮询</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-26T19:12:06+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="push，pull，长轮询"><a href="#push，pull，长轮询" class="headerlink" title="push，pull，长轮询"></a>push，pull，长轮询</h1><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>push模式就是服务器和客户端保持连接，服务器一旦有信息，就“推送”至客户端。但实际上，由于tcp协议的原因，保持连接几乎不可能。问题在于：第一服务端一直在工作压力大，第二客户端处理能力各不相同且不受客户端控制，有客户端堆积的风险。  </p>
<h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>pull就是，客户端一直在工作，不断从服务端拉取数据保存在本地，只要满足设定的条件，就一直向服务端索取数据。</p>
<h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>服务端不一定一直有消息，每隔一秒问一次有没有数据，结果都没有，这样就很浪费，不如派一个委托，在那里等着，一旦有数据就返回，或者等太久了也返回。这就是长轮询。实际上现在的push一般都是由长轮询实现。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/25/10-25技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/10-25技术笔记/" itemprop="url">范式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-25T17:18:52+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><p>第一范式很简单，是关系型数据库的基础，简单来说，每个属性，即每列，只有一个值。</p>
<h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><p>第二范式开始考虑依赖，数据库很多列，一些列的存在依赖于其他列，这就是依赖关系。比如说，学生表，属性有学号，姓名，性别，年龄。后三个属性都依赖于学号，也就是说，只要给一个学号，就能给出其他三个属性的值，反之则不能。<br>属性的集合有很多元素，从中找到一组最基础的元素，其他元素都可以由这组元素得出，这组元素则为联合主键。比如选课表，属性有学号，姓名，性别，课程码，课程名，授课老师，授课老师电话，成绩。则联合主键为（学号，课程码），姓名、性别由学号决定，课程名、老师、授课老师电话由课程码决定，成绩由学号课程码联合决定。<br>那么此时，非联合主键中的元素，一些由联合主键全部元素决定，另一些由联合主键中部分元素决定。前者叫完全依赖，后者叫部分依赖。<br>第二范式就是不能有部分依赖。如果有部分依赖，应该拆表。<br>比如选课表就应该拆成三个，姓名、性别由学号决定：是学生表；课程名、老师、授课老师电话由课程码决定；是课程表；成绩由学号、课程码联合决定，是选课表。  </p>
<h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><p>我们单独再看课程表，虽然对于任何一个课程码，我们都可以说出课程名、老师、授课老师电话，但是其实这些非主键元素，内部依然有依赖关系。我们并不是直接知道授课老师电话的，实际上授课老师电话依赖于老师，我们通过课程码知道老师，通过老师知道了电话，这之间有个传递的过程，这就是传递依赖。<br>第三范式就是讲，不能有传递依赖。为解决继续拆表。<br>老师电话依赖于老师，拆出一个通讯录表。</p>
<h1 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h1><p>BC范式相当于是3.5范式，相比于第三范式，追加了要求，不但非主键元素不依赖，主键元素也不能有依赖关系。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/24/反派最重要的是品味/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/24/反派最重要的是品味/" itemprop="url">反派最重要的是品味</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-24T20:33:17+08:00">
                2018-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看了港片《无双》，被誉为近年来最好的港片，的确不错，虽然有《搏击俱乐部》的意思，但故事的爱情部分，前面有种欧亨利的味道，加上发哥挺拉风的，我还是比较喜欢。<br>周润发这次演的不错，虽然总还是给我一种赌神的感觉，但重要的一点是，他演的很有品味。<br>细想看过的电影，给人留下深刻影响的，《蝙蝠侠：黑暗骑士》的小丑，《这个杀手不太冷》的古典味爱好者反派，以及此作的发哥，一个共同的特点是，很有品位。这么看来，一个电影的反派，要是想给人，或者说至少给我，留下深刻的印象，方法是很有品味。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/18/10-18技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/18/10-18技术笔记/" itemprop="url">Date，Calendar，Time</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-18T16:43:25+08:00">
                2018-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><p>实际上Date大部分方法都被废弃了，只剩无参构造函数：根据现在时间构造date，Long参数构造函数：根据相对Unix时间戳的时间构造Date，以及各种比较方法。根据我的理解，Date类现在想表达的，是相对时间戳过去的豪秒数。setTime转化为Calendar。</p>
<h1 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h1><p>Calendar就是日期类，静态方法getInstance获得日期对象，set函数设值，getTime转化为Date，add方法调时间，get获得任何想要的。<br><strong>坑点一：月份从0开始编号，或者使用Calendar类中的静态常量。<br>坑点二：每周第一天是星期天，第二天是星期一:)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar =Calendar.getInstance();</span><br><span class="line">calendar.set(2018,5-1,12,17,24,52);</span><br><span class="line">calendar.set(2018,Calendar.MAY,12);</span><br><span class="line">calendar.add(Calendar.MINUTE,20);</span><br><span class="line">int week = calendar.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">Date i = calendar.getTime();</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure></p>
<h1 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h1><p>格式化输出Date，构造方法接受一个字符串，为格式化方法，format方法把Date转化为String。parse方法把String转化为Date。<br><strong>注意:MM是月，mm是分钟；HH是24小时制，hh是12小时制;a上午还是下午</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss a&quot;);</span><br><span class="line">System.out.println(simpleDateFormat.format(new Date()));</span><br><span class="line">date = simpleDateFormat.parse(&quot;2018-10-19 11:08:15 上午&quot;);</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure></p>
<h1 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h1><p>java8新的Time包，优点在于，第一是线程安全；第二是消歧义；精确区分了瞬间，时间段，日期，时刻，时区时间，机器时间等。<br>LocalDate只有日期，LocalTime只有时间，LocalDateTime包括日期和时间，Zonedatetime还包括时区，这四者操作类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">localDateTime = LocalDateTime.of(2018,7,13,1,1,50);</span><br><span class="line">int month = localDateTime.getMonthValue(); //是7</span><br><span class="line">System.out.println(localDateTime.getDayOfWeek());//输出FRIDAY</span><br><span class="line">localDateTime.plusDays(40);</span><br><span class="line">localDateTime.plus(1, ChronoUnit.MONTHS);</span><br><span class="line">DateTimeFormatter dateTimeFormatter =  DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">System.out.println(localDateTime.format(dateTimeFormatter));</span><br><span class="line">Date date = Date.from( localDateTime.atZone(ZoneId.systemDefault()).toInstant());</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/17/10-17技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/17/10-17技术笔记/" itemprop="url">哈希树，字典树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-17T19:30:58+08:00">
                2018-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="哈希树"><a href="#哈希树" class="headerlink" title="哈希树"></a>哈希树</h1><h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>哈希树可以广泛应用于那些需要对大容量数据进行快速匹配操作的地方。例如：数据库索引系统、短信息中的收条匹配、大量号码路由匹配、信息过滤匹配。哈希树不需要额外的平衡和防止退化的操作，效率十分理想。<br>哈希树是为了解决哈希表的冲突问题，而产生的数据结构，在处理数字时，其理论基础为质数分辨定理。<br>“分辨”就是指这些连续的整数不可能有完全相同的余数序列。 比如2和3可以分辨6个数，1到6对2和3取余，余数分别是(1,1),(0,2),(1,0)(0,1),(1,2),(0,0)，这六组余数互不相同，实际上任意6个连续整数的余数都不相同。<br>而连续10个质数就可以分辨大约M(10) =2<em>3</em>5<em>7</em>11<em>13</em>17<em>19</em>23*29= 6464693230 个数，已经超过计算机中常用整数（32bit）的表达范围。连续100个质数就可以分辨大约M(100) = 4.711930 乘以10的219次方。<br>而按照目前的CPU水平，100次取余的整数除法操作几乎不算什么难事。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>我们选择质数分辨算法来建立一棵哈希树。<br>选择从2开始的连续质数来建立一个十层的哈希树。第一层结点为根结点，根结点下有2个结点；第二层的每个结点下有3个结点；依此类推，即每层结点的子节点数目为连续的质数。到第十层，每个结点下有29个结点。<br>同一结点中的子结点，从左到右代表不同的余数结果。<br>例如：第二层结点下有三个子节点。那么从左到右分别代表：除3余0，除3余1，除3余2.<br>对质数进行取余操作得到的余数决定了处理的路径。<br><img src="https://s1.ax1x.com/2018/10/17/idoBmd.png" alt="插入"><br>由于质数分辨定理，不可能一直冲突下去，最多冲突十次，这样就存储了所有的数。<br>其实也可以像b+树那样，非叶子节点只有索引信息，但这样似乎没有优势。</p>
<h2 id="查找和删除"><a href="#查找和删除" class="headerlink" title="查找和删除"></a>查找和删除</h2><p>哈希树的节点查找过程和节点插入过程类似，就是对关键字用质数序列取余，根据余数确定下一节点的分叉路径，直到找到目标节点。<br>如上图，最小”哈希树(HashTree)在从4G个对象中找出所匹配的对象，比较次数不超过10次。也就是说：最多属于O(10)。在实际应用中，调整了质数的范围，使得比较次数一般不超过5次。也就是说：最多属于O(5)。因此可以根据自身需要在时间和空间上寻求一个平衡点。<br>哈希树的节点删除过程也很简单，哈希树在删除的时候，并不做任何结构调整。<br>只是先查到到要删除的节点，然后把此节点的“占位标记”置为false即可（即表示此节点为空节点，但并不进行物理删除）。</p>
<h2 id="大字符串"><a href="#大字符串" class="headerlink" title="大字符串"></a>大字符串</h2><p>我们可以用MD5等消息压缩算法将大字符串转换成定长的整数。</p>
<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>字典树思路很简单，把一个个单词存在树里，这样查单词直接在树里查即可，其实类似于哈希树，n层字典树可以存26^n个不同单词。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/16/10-16技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/16/10-16技术笔记/" itemprop="url">跳跃表，红黑树的优势</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-16T17:08:26+08:00">
                2018-10-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>链表的插入删除速度很快，但有序链表查找无法使用二分法，速度只有O(n)，跳跃表就是为了解决这个问题。</p>
<h2 id="构建思路"><a href="#构建思路" class="headerlink" title="构建思路"></a>构建思路</h2><p>假设有个有序链表<br>1-&gt;4-&gt;5-&gt;8-&gt;10-&gt;11-&gt;13<br>查找一个元素的时间复杂度为O(n)。我们建立一个索引。<br>1—–&gt;5—–&gt;10——&gt;13<br>↓——-↓——–↓———↓<br>1-&gt;4-&gt;5-&gt;8-&gt;10-&gt;11-&gt;13<br>这样查询速度提升了，查询时从上往下。查11时路线1,5,10,11。四次。<br>为了优化，继续建立索引的索引。<br>1————-&gt;10<br>1—–&gt;5—–&gt;10——&gt;13<br>↓——-↓——–↓———↓<br>1-&gt;4-&gt;5-&gt;8-&gt;10-&gt;11-&gt;13<br>这样查11只用3次，1,10,11。这样不断建立索引，一共有log(2,n)层，每一层平均查两次，查询时间复杂度，O(2log2N)。  </p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>这样每次折半建立索引，查找虽然快，但维护（增减数据）非常困难，可以说无法维护，以保持结构。为了解决这个问题，建立索引用”掷硬币法”，即，每个元素有50%的概念向上建立索引，当新增元素时，50%往上建立索引点，索引点的索引也是50%往上建立，最后依靠频率接近概率的方法，建立跳跃表。</p>
<h2 id="掷骰子的方法"><a href="#掷骰子的方法" class="headerlink" title="掷骰子的方法"></a>掷骰子的方法</h2><p>表有很多层，层数取决于对数，显然有个因子e，实际上，从效率上来说，建立索引点的概率应该是1/e。</p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树其实相当于AVL树的优化，相比于AVL树，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决。因而插入删除时，平衡节点的花费更低，优势在此。<br>总之，AVL树的高度最多为~1.44log（N），低于红黑树的最大高度，~2log（N）。但是，在插入时，AVL树可能需要O（log（N））操作来重新平衡树，但是红黑树需要O（1）。这意味着AVL树在搜索时可能更快，但在插入时速度更慢。<br>此外，红黑树更容易实现为持久数据结构。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://arvenseyz.github.io/2018/10/15/10-15技术笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvense">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arvense">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/15/10-15技术笔记/" itemprop="url">多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-15T15:49:46+08:00">
                2018-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h1><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>阻塞是指一个线程进入临界区后，其它线程就必须在临界区外等待，待进去的线程执行完任务离开临界区后，其它线程才能再进去。</p>
<h2 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h2><ul>
<li>自由出入临界区</li>
<li>无竞争时，有限步内完成操作</li>
<li>有竞争时，回滚数据  </li>
</ul>
<p>乐观锁？<br>无障碍并不要求一个线程进入临界区之后，其它线程在临界区外等待。所有线程都可以自由地进入临界区，它是一种最弱的非阻塞调度。<br>跟阻塞调度比较，阻塞调度可以认为是一种悲观的策略，它会认为多个线程一起修改数据会使数据损坏，所以阻塞调度每次只能允许一个线程去修改数据。而非阻塞调度相对来说比较乐观，它认为如果多个线程一起修改也未必会把造成数据损坏，所以它允许多个线程同时进入临界区，但无障碍是一种宽进严出的策略，进的时候不作限制，所有的线程都能进入临界区做其想做的事情，包括读与写，但是出来的时候就不那么宽松了，如果一个线程在临界区中的操作遇到了数据竞争，跟其它线程产生了冲突，它就会回滚这条数据，然后重试自己的操作。比如读取x与y的值，这个操作是分步进行的先读x，再读y,当读完x，发现别的线程修改了y，再读y就已经没有意义了，因为可能会读到一个错误的数据，所以该线程会重试，再去读取一次，直到自己读到的x、y没有问题为止，所以无障碍是一种会不断重试的调度策略，但它会保证没有数据竞争时，线程必然能在有限的步骤内执行完任务。</p>
<p>在无障碍的调度方式当中，所有的线程都相当于在拿取一个系统当前的快照，它们会一直重试，直到拿到的快照有效为止</p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><ul>
<li>保证有一个线程可以胜出  </li>
</ul>
<p>前面说的无障碍是指所有的线程都能进入临界区，但如果发生了竞争，无障碍并不保证临界区的线程能够顺利的出来，因为如果线程发现自己的数据每次去读取或者去操作，总是跟其它线程产生冲突，它就会不停地重试，如果在临界区当中有10个线程，线程1修改了部分数据，结果它被线程2干扰了，线程2又被线程3干扰，依此类推，最后线程1它又可能去干扰线程10，如果它们之间是彼此干扰的，最终会导致所有的线程都卡死在里面，系统的性能会受到比较严重的影响，因此，无锁必须在无障碍的基础上加一个约束，保证在竞争当中有一个线程是必然能够胜出的，这样就能保证在临界区的线程当中至少有一个是能顺利走出去的，而不至于全部在里面阵亡掉，如果至少有一个线程能够出去，那么就有第二个线程能够出去，假设里面有一百个线程，第一个线程竞争胜利，走出了临界区，剩下99个再竞争又必然能胜利一个，因为每次竞争它必然保证能有一个胜利，使得系统至少是能够顺畅的执行下去的，这就是无锁。</p>
<h2 id="无等待"><a href="#无等待" class="headerlink" title="无等待"></a>无等待</h2><ul>
<li>要求所有的线程都必须在有限步内完成</li>
<li>无饥饿的  </li>
</ul>
<p>无锁是能保证至少有一个线程能够在有限步当中完成它的操作，所有的线程在不停地竞争直到有一个胜出为止。无等待相比于无锁更进一步，它首先要求是无锁的，保证所有线程能进并且至少有一个线程能出来，同时无等待它在提高要求，它要求所有进入临界区的线程都能够在有限步当中完成其操作，这个要求很高，因为任何线程都能够无障碍进入临界区，并且任何线程都能够在有限步当中完成操作后离开临界区，这就会使得整个系统的运行变得非常顺畅，无等待可以说是并行最高级别了，它基本上能使整个系统发挥到最好佳效率。</p>
<p>无等待必须然也是无饥饿的，因为所有的线程都能在有限步当中完成，因此必然不会有线程永久地呆在临界区内出不去，所以它一定是无饥饿的。</p>
<p>无等待的一个典型案例是，有读写两个线程，如果说只有读线程没有写线程，那么所有的读线程之间必然是无等待的，因为读不会修改数据，如果有一个写线程在里面，由于会修改数据 ，写线程必然会导致读线程不是无等待。因此可以提出一种算法去作一点改进，比如说有一种算法它会这样做，因为写可能会影响到读，所以每次写之前先把数据拷贝一份副本，线程修改的是这个副本而非原始数据，修改数据的过程可能需要一点时间，因为修改的是副本数据而不是原始数据，所以这个修改的过程也不影响线程读，因此在这个过程当中所有的读线程一样是无等待的，它们都能够在有限的步骤当中完成自己的操作，而所有的写线程相对来讲，因为每个写线程它都是写自己的副本，因此它们的写也是无等待的，所以它们都不需要去跟彼此作同步，最后需要同步的只是将写完之后的数据覆盖原始数据，而这个覆盖原始数据的动作是非常快的，因为我们并不需要作大量的写操作，只不过是一个指针或引用作一个替换而已，不管哪个写线程胜出，总是能够保证替换上去的数据是一致的，并不像其它的算法一样，可能会把数据写坏，因为大家都写的是副本，最后是一个指针指向谁的问题，这样数据必然是安全的，这种方式它就是无等待的一个典型的实现。</p>
<h1 id="CompletableFuture：异步多线程"><a href="#CompletableFuture：异步多线程" class="headerlink" title="CompletableFuture：异步多线程"></a>CompletableFuture：异步多线程</h1><h2 id="任务方法"><a href="#任务方法" class="headerlink" title="任务方法"></a>任务方法</h2><p>有supplyAsync和runAsync两个方法，分别适用于有无返回值，各有两个重载方法，可手动指定线程池。</p>
<h2 id="获得结果"><a href="#获得结果" class="headerlink" title="获得结果"></a>获得结果</h2><p>completableFuture.get();</p>
<h2 id="简单示例，不用CompletionStage"><a href="#简单示例，不用CompletionStage" class="headerlink" title="简单示例，不用CompletionStage"></a>简单示例，不用CompletionStage</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br><span class="line">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(()-&gt;cal(),executorService);</span><br><span class="line">System.out.println(f1.get());</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Arvense</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">243</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>


  
</div>


  <div class="powered-by">Powered by <a>Arvense</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">blog   </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
